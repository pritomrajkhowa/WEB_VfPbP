# February 20, 2016

# February 29, 2016: 1. change axioms for if1 and if2 to make all axioms of the form x = ... 2. add last label as an output of translate0

# March 10 - April 27: a new translation for while-loop that parameterizes loop input variables and replaces smallest macros by inductive definition. Also a small correction to simplify()

# April 29: combining the two translations (c2l.py.old3 and c2l.py.old4): keep the old translation for program variables but use a new way to inductively define smallest macro: 
# N(x,y) = if C(x,y) then 0 else C(f(x),g(x)), where f and g is the new value of x and y, respectively, after one iteration
# in c2l.py.old4, f and g are the output functions for the body, here we parameterize f and g first, and use f(1,x) and g(1,y) to replace f(x) and g(y), respectively

# May 18: (not done yet) making functions first-order objects by using "+": f+[t1,...,tk,v] stands for the
# function f1 such that forall x1,...,xk: 
# f1(x1,...,xk) = ite(x1=t1 & ... & xk=tk, v, f(x1,...,xk))
# A translator from C to FOL in python 

# June 18: add solve_rec() by Pritom to solve recurrences in translating while-loop
# assume that the only dynamic functions are the program variables given by v and the system generated temporary functions including big N (is_program_var())
# this makes _base redundant

# August 30: add function definitions and function calls and define program as a sequence of functions. See program definitions just before translate1()

#example run: translate1(fact,vfact,1) or translate1(fact,vfact,2)


"""
Assumptions:
1. Program variables:
  - can be any word \w+
  - cannot be _x\d*, _n\d*, _N\d*,_y\d* 
    (these are reserved for general variables,
    natural number variables, and smallest macro constants
    in our axioms)
  - for a variable, its temporary variants are constructed 
    by adding to it TEMP+number
    and its output values after a labeled statement are 
    constructed by adding to it LABEL+number.
    (Currently, TEMP is empty and LABEL is '_'.) 
    This menas that if V is a variable, then
    V+TEMP+\d+ and V+LABEL+\d+ are not allowed to be variables 
    (right now it means that
    V1,V2,... and V_1,V_2,... cannot be variables).
  - smallest is a reserved word so cannot be a variable
"""


import sys
import os

currentdirectory = os.path.dirname(os.path.realpath(__file__))

sys.path.append(currentdirectory+"/packages/ply/")
sys.path.append(currentdirectory+"/packages/plyj/")
sys.path.append(currentdirectory+"/packages/pyparsing/")
sys.path.append(currentdirectory+"/packages/pycparser1/")
sys.path.append(currentdirectory+"/packages/pycparserext/")
sys.path.append(currentdirectory+"/packages/regex/")
sys.path.append(currentdirectory+"/packages/mpmath/")
sys.path.append(currentdirectory+"/packages/sympy/")
sys.path.append(currentdirectory+"/packages/z3/python/")
sys.path.append(currentdirectory+"/packages/configparser/src/")



import xml.dom.minidom
import re
import random
#add by Pritom Rajkhowa
#import numpy as np
import resource
import hashlib
#import wolframalpha
#import sys
import itertools
import plyj.parser
import plyj.model as m
import subprocess
from sympy import *
import regex
#import os
import copy
import time
import datetime
import configparser as ConfigParser
import SyntaxFilter
import commandclass
import graphclass
import solution_closed_form
import FOL_translation
import fun_utiles
import wolfformSolution
import my_module
from pyparsing import *
from sympy.core.relational import Relational
from pycparser1 import parse_file,c_parser, c_ast, c_generator
from pycparserext.ext_c_parser import GnuCParser
from pycparserext.ext_c_generator import GnuCGenerator
from itertools import permutations
ParserElement.enablePackrat()


#resource.setrlimit(resource.RLIMIT_STACK, [0x10000000, resource.RLIM_INFINITY])
#sys.setrecursionlimit(0x100000)

#resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
#sys.setrecursionlimit(10**6)
#os.system('ulimit -s ulimited')

sys.setrecursionlimit(100000)

def is_empty(any_structure):
    if any_structure:
        return False
    else:
        return True




def is_number(s):
    if s=='j':
    	return False
    try:
        float(s) # for int, long and float
    except ValueError:
        try:
            complex(s) # for complex
        except ValueError:
            return False
    return True

def is_hex(input_string):
        flag=True
        if input_string is None:
            return None
        try:
            flag=int(input_string, 16)
        except ValueError:
            return None
        if flag:
               if '0x' in input_string:
                   return str(int(input_string, 16))
               else:
                   return None
        else:
               return None


#Find Intersection of Two lists


def intersect3(c1,c2,c3):
	return list(set(list(set(c1) & set(c2)))-set(c3))

def intersect2(c1,c2):
	return list(set(c1) & set(c2))


config = ConfigParser.RawConfigParser()
config.read(currentdirectory+'/config.properties')
timeout=config.get('ConfigurationSection', 'timeout');
app_id=config.get('ConfigurationSection', 'app_id');



#Time Out 
if timeout.strip()!='' and timeout.strip()!='None' and is_number(timeout.strip())!=False:
	TIMEOUT=timeout.strip()
else:
	TIMEOUT=40000

if app_id.strip()!='' and app_id.strip()!='None':
	Mathematica_id=app_id.strip()
else:
	Mathematica_id=None


# base language (non dynamic, not changed by the program)
# do not use name with number in the end
# these names are not supposed to be used as prorgam variables

_base = ['=','==','!=','<','<=','>','>=','*','**','!','+','-','/', '%', 'ite', 'and', 'or', 'not', 'implies', 'all', 'some', 'null','>>','<<','&','|']
_infix_op = ['=','==','!=','<','<=','>','>=','*','**','+','-','/', '%', 'implies','<<','>>','&','|']

# variables introduced in the translation

def isvariable(x):
    if x.startswith('_x') or  x.startswith('_y') or  x.startswith('_n') or  x.startswith('_s'):
        return True
    else:
        return False



# program variables and temporary program variables and big N

def is_program_var(x,v):
    if x.startswith('_N'):
        return True
    for y in v:
        if x==y or x.startswith(y+OUT) or (x.startswith(y+TEMP) and 
                                           x[len(y+TEMP):].isdigit()) or x.startswith(y+LABEL):
            return True
    return False


current_milli_time = lambda: int(round(time.time() * 1000))

"""
#Get timestap
"""

def getTimeStamp():
	ts = time.time()
	st = datetime.datetime.fromtimestamp(ts).strftime('%Y-%m-%d %H:%M:%S')
	return "\n***********************\n"+str(st)+"\n***********************\n"


"""
RET for return value of a function
Temporary function names are constructed as: 
variable-name + TEMP + TC
Output function names are: 
variable-name + LABEL
for those with label, or
variable-name + OUT
for those without label.
 TC: TempCount, a global counter for naming temporary variables
 LC: LoopCount, a global counter for naming loop constants and variables
"""

RET='RET'
#OUT='Z' #so don't name variables xZ, yZ...
OUT='1' #so don't name variables x1, y1...
#TEMP = 'T' #so if x is a variable, then don't name variables xT, 
TEMP = '' #so if x is a variable, then don't name variables x2,x3,... (temp starts at 2)
LABEL = '_' #so if x is a variable, then don't name variables x_1,x_2, 
TC = 1  # for generating temporary functions to yield xt1,xt2,...
LC = 0  # for generating smallest macro constants in a loop _N1, _N2,... as well as
               # natural number variables _n1,_n2,...
"""
 Expressions: (f e1 ... ek) is represented as [f,e1,...,ek].
 Example: a+1 is ['+', ['a'],['1']]; constant a is ['a']; 
 sum(i+1,j) is ['sum', ['+', ['i'], ['1']], ['j']]
"""


#constructor: functor - a string like '+', '*', 'and', 
# or constants like '1', 'x'; args - a list of exprs
def expres(functor,args=[]):
    return [functor]+args

#accessor
def expr_op(e):
    return e[0]
def expr_args(e):
    return e[1:]

#prefix printing
def expr2string(e):
    if len(e)==1:
        return e[0]
    else:
        return '(' + e[0] +' '+ ' '.join(list(expr2string(x) for x in e[1:]))+ ')'

#normal infix printing
def expr2string1(e):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                return expr2string1(args[0])
            else:
                return '('+(' '+op+' ').join(list(expr2string1(x) for x in args))+')'
        elif op=='not' and len(args)==1:
            return 'not '+expr2string1(args[0])
        elif op=='implies' and len(args)==2:
            return expr2string1(args[0])+ ' -> '+expr2string1(args[1])
        elif op in _infix_op and len(args)==2:
            return '(' + expr2string1(args[0])+ op+expr2string1(args[1])+')'
        else:
            return op +'('+ ','.join(list(expr2string1(x) for x in args))+ ')'



def expr2stringvfact(e,var_map):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                return expr2stringvfact(args[0],var_map)
            else:
                return '('+(' '+op+' ').join(list(expr2stringvfact(x,var_map) for x in args))+')'
        elif op=='not' and len(args)==1:
            return 'not '+expr2stringvfact(args[0],var_map)
        elif op=='implies' and len(args)==2:
            return expr2stringvfact(args[0],var_map)+ ' -> '+expr2stringvfact(args[1],var_map)
        elif op in _infix_op and len(args)==2:
            t1=args[0][0]
            if t1 not in _base and is_number(t1)==False:
            	parameter=[]
            	
            	for x in range(0, len(args[0])):
            		parameter.append('int')
            	var_map[t1]=parameter
            t2=args[1][0]
            if t2 not in _base and is_number(t2)==False:
            	parameter=[]
            	
            	for x in range(0, len(args[1])):
            		parameter.append('int')
            		
            	var_map[t2]=parameter
            return '(' + expr2stringvfact(args[0],var_map)+ op+expr2stringvfact(args[1],var_map)+')'
        else:
            if isArrayFunction(op)==True:
            	count=0
            	for parameter in args:
            	
            		if len(parameter)==1:
            			name=expr2stringvfact(parameter,var_map)
            			if is_number(name)==False:
            				type_list=[]
            				if count==0:
            					type_list.append('array')
            				else:
            					type_list.append('int')
            				count=count+1
            			
            				var_map[name]=type_list
            			
            return op +'('+ ','.join(list(expr2stringvfact(x,var_map) for x in args))+ ')'





def expr2stringvfact2(e,var_map,allvariablelist,constraints):
    args=expr_args(e)
    op=expr_op(e)
    constraint=None
    if len(args)==0:
        if op not in list(var_map.keys()) and is_number(op)==False and is_hex(op)==None and op not in _base:
                element=[]
                element.append(op)
                element.append(0)
                element_para=[]
                element.append(element_para)
                typename=getVariableType(op,allvariablelist)
                if typename is None:
                        if '__VERIFIER_nondet_double' in op:
                            element_para.append('double')
                        elif '__VERIFIER_nondet_float' in op:
                            element_para.append('float')
                        else:
                            element_para.append('int')
                else:
                        if isVariableArray(op,allvariablelist) is not None:
                                element_para.append('array')
                        else:
                                if typename=='unsigned':
                                        constraint=e
                                        element_para.append('int')
                                elif typename=='long':
                                     element_para.append('int')
                                else:
                                     element_para.append(typename)
                var_map[op]=element
                if constraint is not None or '__VERIFIER_nondet_uint' in op:
                    con_equ=[]
                    con_equ.append('c1')
                    con_equ1=[]
                    con_equ1.append('>=')
                    con_equ1.append(e)
                    con_equ1.append(eval("['0']"))
                    con_equ.append(con_equ1)
                    constraints.append(wff2z3_update_postCond(con_equ))
                constraint=None  
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                return expr2stringvfact2(args[0],var_map,allvariablelist,constraints)
            else:
                return '('+(' '+op+' ').join(list(expr2stringvfact2(x,var_map,allvariablelist,constraints) for x in args))+')'
        elif op=='not' and len(args)==1:
            return 'not '+expr2stringvfact2(args[0],var_map,allvariablelist,constraints)
        elif op=='implies' and len(args)==2:
            return expr2stringvfact2(args[0],var_map,allvariablelist,constraints)+ ' -> '+expr2stringvfact2(args[1],var_map,allvariablelist,constraints)
        elif op in _infix_op and len(args)==2:
            return '(' + expr2stringvfact2(args[0],var_map,allvariablelist,constraints)+ op+expr2stringvfact2(args[1],var_map,allvariablelist,constraints)+')'
        else:
            if isArrayFunction(op)==True:
                count=0
                element=[]
                element.append(op)
                element.append(len(args))
                element_para=[]
                array_type=None
                for parameter in args:
                       if count==0:
                                element_para.append('array')
                                element_in=[]
                                para_value=expr2stringvfact2(parameter,var_map,allvariablelist,constraints)
                                element_in.append(para_value)
                                element_in.append(0)
                                element_para_in=[]
                                element_para_in.append('array')
                                element_in.append(element_para_in)
                                var_map[para_value]=element_in
                                array_type=getVariableType(parameter,allvariablelist)
                       else:
                                expr2stringvfact2(parameter,var_map,allvariablelist,constraints)
                                typename=getVariableType(parameter,allvariablelist)
                                if typename is None:
                                        element_para.append('int')
                                else:
                                        if typename=='unsigned':
                                               element_para.append('int')
                                        elif typename=='long':
                                               element_para.append('int')
                                        else:
                                               element_para.append(typename)
                       count=count+1
                if array_type is None:
                        element_para.append('int')
                else:
                        if typename=='unsigned':
                                constraint=e
                                element_para.append('int')
                        elif typename=='long':
                                constraint=e
                                element_para.append('int')
                        else:
                                element_para.append(array_type)
                element.append(element_para)
                var_map[op]=element
                if constraint is not None or '__VERIFIER_nondet_uint' in op:
                    con_equ=[]
                    con_equ.append('c1')
                    con_equ1=[]
                    con_equ1.append('>=')
                    con_equ1.append(e)
                    con_equ1.append(eval("['0']"))
                    con_equ.append(con_equ1)
                    constraints.append(wff2z3_update_postCond(con_equ))
                constraint=None  
            else:

                if op not in list(var_map.keys()) and op is not 'ite' and op not in _base:
                    element=[]
                    element.append(op)
                    element.append(len(args))
                    element_para=[]
                    if len(args)>0:
                                for x in args:
                                        typename=getVariableType(expr2stringvfact2(x,var_map,allvariablelist,constraints),allvariablelist)
                                        if typename is None:
                                                element_para.append('int')
                                        else:
                                                element_para.append(typename)
                                typename=getVariableType(op,allvariablelist)
                                if typename is None:
                                    if '__VERIFIER_nondet_double' in op:
                                        element_para.append('double')
                                    elif '__VERIFIER_nondet_float' in op:
                                        element_para.append('float')
                                    else:
                                        element_para.append('int')
                                else:
                                    if typename=='unsigned':
                                        constraint=e
                                        element_para.append('int')
                                    elif typename=='long':
                                        element_para.append('int')
                                    else:
                                        element_para.append(typename)
                    else:
                        typename=getVariableType(op,allvariablelist)
                        if typename is None:
                                    if '__VERIFIER_nondet_double' in op:
                                        element_para.append('double')
                                    elif '__VERIFIER_nondet_float' in op:
                                        element_para.append('float')
                                    else:
                                        element_para.append('int')
                        else:
                                    if typename=='unsigned':
                                        constraint=e
                                        element_para.append('int')
                                    elif typename=='long':
                                        element_para.append('int')
                                    else:
                                        element_para.append(typename)
                    element.append(element_para)
                    var_map[op]=element
                    if constraint is not None or '__VERIFIER_nondet_uint' in op:
                        con_equ=[]
                        con_equ.append('c1')
                        con_equ1=[]
                        con_equ1.append('>=')
                        con_equ1.append(e)
                        con_equ1.append(eval("['0']"))
                        con_equ.append(con_equ1)
                        constraints.append(wff2z3_update_postCond(con_equ))
                    constraint=None           	            			
            return op +'('+ ','.join(list(expr2stringvfact2(x,var_map,allvariablelist,constraints) for x in args))+ ')'


#normal infix printing
def expr2stringSimplify(e):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                return expr2stringSimplify(args[0])
            else:
                return '('+(' '+op+' ').join(list(expr2stringSimplify(x) for x in args))+')'
        elif op=='not' and len(args)==1:
            return 'not '+expr2stringSimplify(args[0])
        elif op=='implies' and len(args)==2:
            return expr2stringSimplify(args[0])+ ' -> '+expr2stringSimplify(args[1])
        elif op in _infix_op and len(args)==2:
            return '(' + expr2stringSimplify(args[0])+ op+expr2stringSimplify(args[1])+')'
        else:
            if op is 'ite':
                expresion1 = expr2stringSimplify(args[1])
                expresion2 =  expr2stringSimplify(args[2])
                if ('and' not in expresion1 and 'or' not in expresion1 and 'ite' not in expresion1) and ('and' not in expresion2 and 'or' not in expresion2 and 'ite' not in expresion2) and simplify(expresion1+'=='+expresion2)==True:
            		
                        return expresion1
                else:
                        return op +'('+ ','.join(list(expr2stringSimplify(x) for x in args))+ ')'
            else:
                return op +'('+ ','.join(list(expr2stringSimplify(x) for x in args))+ ')'


#Function to Simplify equation using Array Map

#e=['i1', 3, '_n1', ['d2array3', ['_x1'], ['_x2'], ['_x3'], ['+', ['_n1'], ['1']],['_n2'], ['_n3']], ['ite', ['and', ['=', ['_x1'], ['C']], ['=', ['_x2'], ['+', ['_n3'], ['0']]], ['=', ['_x3'], ['+', ['_n1'], ['0']]]], ['+', ['ite', ['and', ['=', ['C'], ['C']], ['=', ['+', ['_n3'], ['0']], ['+', ['_n3'], ['0']]], ['=', ['+', ['_n1'], ['0']], ['+', ['_n1'], ['0']]]], ['0'], ['d2array3', ['C'], ['+',['_n3'], ['0']], ['+', ['_n1'], ['0']], ['_n1'], ['_n2'], ['_n3']]], ['*', ['ite', ['and', ['=', ['A'], ['C']], ['=', ['+', ['_n3'], ['0']], ['+', ['_n3'], ['0']]], ['=', ['+', ['_n2'], ['0']], ['+', ['_n1'], ['0']]]], ['0'], ['d2array3', ['A'], ['+', ['_n3'], ['0']], ['+', ['_n2'], ['0']], ['_n1'], ['_n2'], ['_n3']]], ['ite', ['and', ['=', ['B'], ['C']], ['=', ['+', ['_n2'], ['0']], ['+', ['_n3'], ['0']]], ['=', ['+', ['_n1'], ['0']], ['+', ['_n1'], ['0']]]], ['0'], ['d2array3', ['B'], ['+', ['_n2'], ['0']], ['+', ['_n1'], ['0']], ['_n1'], ['_n2'], ['_n3']]]]], ['ite', ['and', ['=', ['_x1'], ['C']], ['=', ['_x2'], ['+', ['_n3'], ['0']]], ['=', ['_x3'], ['+', ['_n1'], ['0']]]], ['0'], ['d2array3', ['_x1'], ['_x2'], ['_x3'], ['_n1'], ['_n2'], ['_n3']]]]]
#array_list=['A','B','C']

def simplify_ind_equation(e,array_list):
        if e[:1]==['ite']:
        	temp=[]
        	count=0
        	ifcase=None
        	elsecase=None
        	status=None
        	for x in expr_args(e):
        		parameter=simplify_ind_equation(x,array_list)
        		if count==0:
                                status=evaluateCondition(parameter,array_list)
                                if status == 'Unknown':
                                    parameter = evaluateConditionModify(parameter,array_list)
        		elif count==1:
        			ifcase=parameter
        		elif count==2:
        			elsecase=parameter
        		temp.append(parameter)
        		count=count+1
        	if status=='True':
        		return ifcase
        	elif status=='False':
        		return elsecase
        	else:
        		return e[:1]+temp
        else:
        	return e[:1]+list(simplify_ind_equation(x,array_list) for x in expr_args(e))




def simplify_ind_equation_array(e,array_list):
        if e[:1]==['ite']:
        	temp=[]
        	count=0
        	ifcase=None
        	elsecase=None
        	status=None
        	for x in expr_args(e):
        		parameter=simplify_ind_equation_array(x,array_list)
        		if count==0:
                                status=evaluateConditionArray(parameter,array_list)
                                if status is not None:
                                    parameter=status
        		elif count==1:
        			ifcase=parameter
        		elif count==2:
        			elsecase=parameter
        		temp.append(parameter)
        		count=count+1
        	if status is None:
        		return ifcase
        	else:
        		return e[:1]+temp
        else:
        	return e[:1]+list(simplify_ind_equation_array(x,array_list) for x in expr_args(e))


def evaluateConditionArray(e,array_list):
        if e[:1]==['and']:
                status=None
                temp=[]
                for x in expr_args(e):
                        parameter=simplify_ind_equation(x,array_list)
                        left=expr2string1(parameter[1])
                        right=expr2string1(parameter[2])
                        expression=expr2string1(parameter)
                        if  parameter[0]== '=' and 'and' not in expression and 'or' not in expression and 'implies' not in expression and 'ite' not in expression and left in array_list and right in array_list:
                                    c_status=simplify(left)==simplify(right)
                                    if c_status==False :
                                        return 
                        else:
                            temp.append(x)
                if len(temp)>0:
                    return e[:1]+temp
                else:
                    return None
        else:
            return e







def evaluateCondition(e,array_list):
        if e[:1]==['and']:
                status=None
                for x in expr_args(e):
                        parameter=simplify_ind_equation(x,array_list)
                        expression=expr2string1(parameter)
                        if  parameter[0]== '=' and 'and' not in expression and 'or' not in expression and 'implies' not in expression and 'ite' not in expression:
                                left=expr2string1(parameter[1])
                                right=expr2string1(parameter[2])
                                c_status=simplify(left)==simplify(right)
                                if c_status==True:
                                        if status==None:
                                                status='True'
                                        elif status=='Unknown':
                                                status='Unknown'
                                        elif status=='False':
                                                status='False'
                                        elif status=='True':
                                                status='True'
                                        else:
                                                status='Unknown'
                                elif c_status==False and left in array_list and right in array_list:
                                        status='False'
                                elif c_status==False and status==None:
                                        status='False'
                                else:
                                        if status=='False':
                                                #status_ieq1=simplify(left)>=simplify(right)
                                                #status_ieq2=simplify(left)<=simplify(right)
                                                #if status_ieq1==False
                                                status='False'
                                        else:
                                                status_ieq2=simplify(simplify(left)<=simplify(right))
                                                status_ieq1=simplify(simplify(left)>=simplify(right))
                                                if status_ieq1==True and status_ieq2==False:
                                                    status='False'
                                                elif status_ieq1==False and status_ieq2==True:
                                                    status='False'
                                                else:
                                                    status='Unknown'
                        else:
                                if status=='False':
                                        status='False'
                                else:
                                        status='Unknown'
                return status
        elif e[:1]==['or']:
                status=None
                for x in expr_args(e):
                        parameter=simplify_ind_equation(x,array_list)
                        expression=expr2string1(parameter)
                        if  parameter[0] is '=' and 'and' not in expression and 'or' not in expression and 'implies' not in expression and 'ite' not in expression:
                                left=expr2string1(expr2string1(parameter[1]))
                                right=expr2string1(expr2string1(parameter[2]))
                                c_status=simplify(left)==simplify(right)
                                if c_status==True:
                                        if status==None:
                                                status='True'
                                        elif status=='Unknown':
                                                status='True'
                                        elif status=='False':
                                                status='True'
                                        elif status=='True':
                                                status='True'
                                        else:
                                                status='Unknown'
                                elif c_status==False and left in array_list and right in array_list:
                                        status='False'
                                else:
                                        if status=='True':
                                                status='True'
                                        else:
                                                status='Unknown'
                        else:
                                if status=='True':
                                        status='True'
                                else:
                                        status='Unknown'
                return status
        elif e[:1]==['='] and e[1][0] in array_list and  e[1][0] in array_list and e[1][0]!=e[2][0]:
                status='False'
                return status
        elif e[:1]==['='] and e[1][0] in array_list and  e[1][0] in array_list and e[1][0]==e[2][0]:
                status='True'
                return status
            


def evaluateConditionModify(e,array_list):
        modify_parameter=[]
        if e[:1]==['and']:
                status=None
                for x in expr_args(e):
                        parameter=simplify_ind_equation(x,array_list)
                        expression=expr2string1(parameter)
                        if  parameter[0]== '=' and 'and' not in expression and 'or' not in expression and 'implies' not in expression and 'ite' not in expression:
                                left=expr2string1(parameter[1])
                                right=expr2string1(parameter[2])
                                c_status=simplify(left)==simplify(right)
                                if c_status!=True:
                                   modify_parameter.append(x)
                        else:
                                modify_parameter.append(x)
                if len(modify_parameter)==1:
                    return modify_parameter[0]
                else:
                    return e[:1]+modify_parameter
        elif e[:1]==['or']:
                status=None
                for x in expr_args(e):
                        parameter=simplify_ind_equation(x,array_list)
                        expression=expr2string1(parameter)
                        if  parameter[0] is '=' and 'and' not in expression and 'or' not in expression and 'implies' not in expression and 'ite' not in expression:
                                left=expr2string1(expr2string1(parameter[1]))
                                right=expr2string1(expr2string1(parameter[2]))
                                c_status=simplify(left)==simplify(right)
                                if c_status!=True:
                                   modify_parameter.append(x)
                        else:
                            modify_parameter.append(x)
                if len(modify_parameter)==1:
                    return modify_parameter[0]
                else:
                    return e[:1]+modify_parameter
















def expr2python(e,tab):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                return expr2python(args[0],tab)
            else:
                return '('+(' '+op+' ').join(list(expr2python(x,tab) for x in args))+')'
        elif op=='not' and len(args)==1:
            return 'not '+expr2python(args[0],tab)
        elif op=='implies' and len(args)==2:
            return expr2python(args[0],tab)+ ' -> '+expr2python(args[1],tab)
        elif op in _infix_op and len(args)==2:
            return '(' + expr2python(args[0],tab)+ op+expr2python(args[1],tab)+')'
        else:
            if op is 'ite':
            	cond = expr2python(args[0],tab+'\t')
            	expresion1 = expr2python(args[1],tab+'\t')
            	expresion2 =  expr2python(args[2],tab+'\t')
            	return '\n'+tab+'if '+cond+' : \n'+tab+'\treturn '+expresion1+'\n'+tab+'else : \n'+tab+'\treturn '+expresion2+'\n'
            else:
            	return op +'('+ ','.join(list(expr2python(x,tab) for x in args))+ ')'









#Get Variable Type

def getVariableType(variable,allvariablelist):
    for var in list(allvariablelist.keys()):
        if var in variable and variable[0] is not '_':
                variableType=allvariablelist[var]
                return variableType.getVariableType()
        elif '__VERIFIER_nondet_double' in variable:
                return 'double'
        elif '__VERIFIER_nondet_float' in variable:
                return 'float'
        elif '__VERIFIER_nondet_int' in variable:
                return 'int'
        elif '__VERIFIER_nondet_uint' in variable:
                return 'int'
    return None


#Is Variable a Array

def isVariableArray(variable,allvariablelist):
        for var in list(allvariablelist.keys()):
		#if var in variable:                    
                if isTempVar(variable,var)==True or variable==var:
                        variableType=allvariablelist[var]
                        return variableType.getDimensions()
        return None


#variable='maker1'
#pattern='maker'
#isTempVar( 'maker1', 'maker')
def isTempVar( variable, pattern):
        status=False
        reg_expreesion=""+pattern+"\d"
        find=regex.compile(reg_expreesion)
        group = find.search(variable)
        find1=regex.compile(""+pattern+"\d[_]")
        group1 = find1.search(variable)
        if group is not None:
           status=True
        if group1 is not None:
           status=False
        return status



#expression to z3 constraint
def expr2z3(e,var_cstr_map):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        if isvariable(op)==True:
           var_cstr_map[op]=op+">=0"
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                return expr2z3(args[0],var_cstr_map)
            else:
                parameter1=None
                parameter2=None
                for x in args:
                    if parameter1==None:
                    	parameter1=expr2z3(x,var_cstr_map)
                    else:
                    	parameter2=expr2z3(x,var_cstr_map)
                if op=='or':
                	return 'Or('+parameter1+','+parameter2+')'
                else:
                	if op=='and':
                		return 'And('+parameter1+','+parameter2+')'
                #return '('+(' '+op+' ').join(list(expr2z3(x,var_cstr_map) for x in args))+')'
        elif op=='not' and len(args)==1:
            return 'Not('+expr2z3(args[0],var_cstr_map)+')'
        elif op=='implies' and len(args)==2:
            
            if len(var_cstr_map)==0:
            	return 'Implies('+expr2z3(args[0],var_cstr_map)+ ','+expr2z3(args[1],var_cstr_map)+')'
            else:
                list_constrn=""
                for x in var_cstr_map:
                        if list_constrn=="":
                                list_constrn="And("+expr2z3(args[0],var_cstr_map)+","+var_cstr_map[x]+")"
                        else:
                                list_constrn="And("+list_constrn+","+var_cstr_map[x]+")"
                return 'Implies('+list_constrn+ ','+expr2z3(args[1],var_cstr_map)+')'
        elif op in _infix_op and len(args)==2:
            return '((' + expr2z3(args[0],var_cstr_map)+')'+ op+'('+expr2z3(args[1],var_cstr_map)+'))'
        else:
            return op +'('+ ','.join(list(trim_p(expr2z3(x,var_cstr_map)) for x in args))+ ')'





#expression to z3 constraint

#e=['or', ['or', ['or', ['<=', ['B'], ['0']], ['<=', ['A'], ['0']]], ['<=', ['+', ['A'], ['B']], ['B']]], ['<=', ['+',['A'], ['B']], ['A']]]

#e=['+', ['*', ['*', ['/', ['B'], ['']], ['/', ['A'], ['C']]], ['+', ['+', ['A'], ['B']], ['B']]], ['-', ['+',['A'], ['B']], ['A']]]

#e=['Y3', ['+', ['_n1'], ['1']], ['A'], ['B']], ['ite', ['>', ['A'], ['B']], ['Y3', ['_n1'], ['A'], ['B']], ['+', ['A'], ['*', ['2'], ['B']]]]

#e=['ite', ['>', ['A'], ['B']], ['Y3', ['_n1'], ['A'], ['B']], ['+', ['A'], ['*', ['2'], ['B']]]]

#e=['==', ['d1array3', ['a'], ['+', ['+', ['_k1'], ['1']], ['0']], ['+', ['+', ['_k1'], ['1']], ['1']]], ['d1array3', ['b'], ['+', ['*', ['9'], ['+', ['_k1'], ['1']]], ['1']], ['+', ['_k1'], ['1']]]]

#var_cstr_map={}

def expr2z3_update(e,var_cstr_map):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        if isvariable(op)==True:
            var_cstr_map[op]=op+">=0"
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                expression=expr2z3_update(args[0],var_cstr_map)
                if '/' not in expression and 'Or' not in expression and '==' not in expression and 'And' not in expression and 'If' not in expression and 'Implies' not in expression:
                       expression=simplify_expand_sympy(expression)
                return expression
            else:
                e_array=[]
                for x in args:
                        parameter1=expr2z3_update(x,var_cstr_map)
                        if '/' not in parameter1 and 'Or' not in parameter1 and '==' not in parameter1 and 'And' not in parameter1 and 'If' not in parameter1 and 'Implies' not in parameter1:                    		
                                parameter1=convert_pow_op_fun(simplify_expand_sympy(parameter1))
                                
                        elif 'Or' not in parameter1 and 'And' not in parameter1 and 'If' not in parameter1 and 'Implies' not in parameter1:
                                parameter1=convert_pow_op_fun(parameter1)
                        e_array.append(parameter1)
                if op=='or':
                	#return 'Or('+parameter1+','+parameter2+')'
                	return constructAndOr(e_array,'Or')
                else:
                	if op=='and':
                		#return 'And('+parameter1+','+parameter2+')'
                		return constructAndOr(e_array,'And')
        elif op=='not' and len(args)==1:
            expression=expr2z3_update(args[0],var_cstr_map)
            if '/' not in expression and 'Or' not in expression and '==' not in expression and 'And' not in expression and 'If' not in expression and 'Implies' not in expression:
            	expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            elif 'Or' not in expression and 'And' not in expression and 'If' not in expression and 'Implies' not in expression:
            	expression=convert_pow_op_fun(expression)
            return 'Not('+expression+')'
        elif op=='implies' and len(args)==2:
            if len(var_cstr_map)==0:
            	expression1=expr2z3_update(args[0],var_cstr_map)
            	expression2=expr2z3_update(args[1],var_cstr_map)
            	if '/' not in expression1 and 'Or' not in expression1 and '==' not in expression1 and 'And' not in expression1 and 'If' not in expression1 and 'Implies' not in expression1:
            		expression1=convert_pow_op_fun(simplify_expand_sympy(expression1))
            	elif 'Or' not in expression1 and 'And' not in expression1 and 'If' not in expression1 and 'Implies' not in expression1:
                        expression1=convert_pow_op_fun(expression1)
            	if '/' not in expression2 and 'Or' not in expression2 and '==' not in expression2 and 'And' not in expression2 and 'If' not in expression2 and 'Implies' not in expression2:
                        expression2=convert_pow_op_fun(simplify_expand_sympy(expression2))
            	elif 'Or' not in expression2 and 'And' not in expression2 and 'If' not in expression2 and 'Implies' not in expression2:
                        expression2=convert_pow_op_fun(expression2)
            	return 'Implies('+expression1+ ','+expression2+')'
            else:
                list_constrn=""
                for x in var_cstr_map:
                      if list_constrn=="":
                                expression1=expr2z3_update(args[0],var_cstr_map)
                                if '/' not in expression1 and 'Or' not in expression1 and '==' not in expression1 and 'And' not in expression1 and 'If' not in expression1 and 'Implies' not in expression1:
                                        expression1=convert_pow_op_fun(simplify_expand_sympy(expression1))
                                elif 'Or' not in expression1 and 'And' not in expression1 and 'If' not in expression1 and 'Implies' not in expression1:
                                        expression1=convert_pow_op_fun(expression1)
                                        list_constrn="And("+expression1+","+var_cstr_map[x]+")"
                      else:
                                list_constrn="And("+list_constrn+","+var_cstr_map[x]+")"
                expression2=expr2z3_update(args[1],var_cstr_map)
                if '/' not in expression2 and 'Or' not in expression2 and '==' not in expression2 and 'And' not in expression2 and 'If' not in expression2 and 'Implies' not in expression2:
                        expression1=simplify_expand_sympy(expression2)
                elif 'Or' not in expression2 and 'And' not in expression2 and 'If' not in expression2 and 'Implies' not in expression2:
                        expression2=convert_pow_op_fun(expression2)
                return 'Implies('+list_constrn+ ','+expression2+')'
        elif op in _infix_op and len(args)==2:
            expression1=expr2z3_update(args[0],var_cstr_map)
            expression2=expr2z3_update(args[1],var_cstr_map)
            if '/' not in expression1 and 'Or' not in expression1 and '==' not in expression1 and 'And' not in expression1 and 'If' not in expression1 and 'Implies' not in expression1:
                expression1=simplify_expand_sympy(expression1)
            if '/' not in expression2 and 'Or' not in expression2 and '==' not in expression2 and 'And' not in expression2 and 'If' not in expression2 and 'Implies' not in expression2:
                expression2=simplify_expand_sympy(expression2)
            if op=='/':
                   return '((' + expression1+')'+op+'('+expression2+'))'
            elif op=='**':
                   if expression2=='2':
                       return expression1+'*'+expression1
                   else:
                       return 'power((' + expression1+')'+','+'('+expression2+'))'
            elif op=='=':
                   return '((' + expression1+ ')==('+expression2+'))'
            else:
                        if op=='*':
                            expression='((' + expression1+')'+ op+'('+expression2+'))'
                        else:
                            expression='((' + expression1+')'+ op+'('+expression2+'))'
                        if '/' not in expression and 'Or' not in expression and '==' not in expression and 'And' not in expression and '.' not in expression:
                                return simplify_expand_sympy(expression)
                        else:
                                return expression
        else:
            if op=='ite':
            	return 'If('+ ','.join(list(conditionSimplifyPower(expr2z3_update(x,var_cstr_map)) for x in args))+ ')'
            else:
                if isArrayFunction(op)==True:
                    parameter_list=[]
                    defineDetailtemp=[]
                    defineDetailtemp.append(op)
                    parameter_list.append('array')
                    for x in range(0, len(args)):
                        parameter_list.append('int')
                    defineDetailtemp.append(len(args))
                    defineDetailtemp.append(parameter_list)
                    defineDetaillist.append(defineDetailtemp)
                return op +'('+ ','.join(list(expr2z3_update(x,var_cstr_map) for x in args))+ ')'





def expr2z3_update1(e,var_cstr_map):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        if isvariable(op)==True:
            var_cstr_map[op]=op+">=0"
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                expression=expr2z3_update1(args[0],var_cstr_map)
                return expression
            else:
                e_array=[]
                for x in args:
                        parameter1=expr2z3_update1(x,var_cstr_map)
                        e_array.append(parameter1)
                if op=='or':
                	#return 'Or('+parameter1+','+parameter2+')'
                	return constructAndOr(e_array,'Or')
                else:
                	if op=='and':
                		#return 'And('+parameter1+','+parameter2+')'
                		return constructAndOr(e_array,'And')
        elif op=='not' and len(args)==1:
            expression=expr2z3_update1(args[0],var_cstr_map)
            return 'Not('+expression+')'
        elif op=='implies' and len(args)==2:
            if len(var_cstr_map)==0:
            	expression1=expr2z3_update1(args[0],var_cstr_map)
            	expression2=expr2z3_update1(args[1],var_cstr_map)
            	return 'Implies('+expression1+ ','+expression2+')'
            else:
                list_constrn=""
                for x in var_cstr_map:
                      if list_constrn=="":
                                expression1=expr2z3_update1(args[0],var_cstr_map)
                                list_constrn="And("+expression1+","+var_cstr_map[x]+")"
                      else:
                                list_constrn="And("+list_constrn+","+var_cstr_map[x]+")"
                expression2=expr2z3_update1(args[1],var_cstr_map)
                return 'Implies('+list_constrn+ ','+expression2+')'
        elif op in _infix_op and len(args)==2:
                expression1=expr2z3_update1(args[0],var_cstr_map)
                expression2=expr2z3_update1(args[1],var_cstr_map)
                if op=='/':
                        return '((' + expression1+')'+op+'('+expression2+'))'
                elif op=='**':
                        if expression2=='2':
                            return expression1+'*'+expression1
                        else:
                            return 'power((' + expression1+')'+','+'('+expression2+'))'
                elif op=='=':
                        return '((' + expression1+ ')==('+expression2+'))'
                else:
                        if op=='*':
                            expression='((' + expression1+')'+ op+'('+expression2+'))'
                        else:
                            expression='((' + expression1+')'+ op+'('+expression2+'))'
                        return expression
        else:
            if op=='ite':
            	return 'If('+ ','.join(list(expr2z3_update1(x,var_cstr_map) for x in args))+ ')'
            else:
            	if isArrayFunction(op)==True:
            		parameter_list=[]
            		defineDetailtemp=[]
            		defineDetailtemp.append(op)
            		parameter_list.append('array')
            		for x in range(0, len(args)):
            			parameter_list.append('int')
            		defineDetailtemp.append(len(args))
            		defineDetailtemp.append(parameter_list)
            		defineDetaillist.append(defineDetailtemp)
            	return op +'('+ ','.join(list(expr2z3_update1(x,var_cstr_map) for x in args))+ ')'














def constructAndOr(e_array,operator):
	if len(e_array)>2:
		return operator+'('+e_array[0]+','+constructAndOr(e_array[1:],operator)+')'
	if len(e_array)==2:
		return operator+'('+e_array[0]+','+e_array[1]+')'
	else:
		return e_array[0]
                
                
def constructAndOrArray(e_array,operator):
	if len(e_array)>2:
		return eval("['"+operator+"',"+str(e_array[0])+','+str(constructAndOrArray(e_array[1:],operator))+']')
	if len(e_array)==2:
		return eval("['"+operator+"',"+str(e_array[0])+','+str(e_array[1])+']')
	else:
		return e_array[0]





def expr2z3_update_postCond(e,var_cstr_map):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        if isvariable(op)==True:
            var_cstr_map[op]=op+">=0"
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                expression=expr2z3_update_postCond(args[0],var_cstr_map)
                if '/' not in expression and 'Or' not in expression and '==' not in expression and 'And' not in expression and 'Implies' not in expression and 'If' not in expression:
                    expression=simplify_expand_sympy(expression)
                return expression
            else:
                parameter1=None
                parameter2=None
                for x in args:
                    if parameter1==None:
                    	parameter1=expr2z3_update_postCond(x,var_cstr_map)
                    	if '/' not in parameter1 and 'Or' not in parameter1 and '==' not in parameter1 and 'And' not in parameter1 and 'Implies' not in parameter1 and 'If' not in parameter1:
                    		parameter1=convert_pow_op_fun(simplify_expand_sympy(parameter1))
                    	elif 'Or' not in parameter1 and 'And' not in parameter1 and 'If' not in parameter1 and 'Implies' not in parameter1 and 'If' not in parameter1:
                    		parameter1=convert_pow_op_fun(parameter1)
                    else:
                    	parameter2=expr2z3_update_postCond(x,var_cstr_map)
                    	if '/' not in parameter2 and 'Or' not in parameter2 and '==' not in parameter2 and 'And' not in parameter2 and 'Implies' not in parameter2 and 'If' not in parameter2:
                    		parameter2=convert_pow_op_fun(simplify_expand_sympy(parameter2))
                    	elif 'Or' not in parameter2 and 'And' not in parameter2 and 'If' not in parameter2 and 'Implies' not in parameter2 and 'If' not in parameter2:
                    		parameter2=convert_pow_op_fun(parameter2)
                if op=='or':
                	return 'Or('+parameter1+','+parameter2+')'
                else:
                	if op=='and':
                		return 'And('+parameter1+','+parameter2+')'
        elif op=='not' and len(args)==1:
            expression=expr2z3_update_postCond(args[0],var_cstr_map)
            if '/' not in expression and 'Or' not in expression and '==' not in expression and 'And' not in expression and 'Implies' not in expression and 'If' not in expression:
            	expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            elif 'Or' not in expression and 'And' not in expression and 'Implies' not in expression and 'If' not in expression:
            	expression=convert_pow_op_fun(expression)
            return 'Not('+expression+')'
        elif op=='implies' and len(args)==2:
            if len(var_cstr_map)==0:
                expression1=expr2z3_update_postCond(args[0],var_cstr_map)
                expression2=expr2z3_update_postCond(args[1],var_cstr_map)
                if '/' not in expression1 and 'Or' not in expression1 and '==' not in expression1 and 'And' not in expression1 and 'Implies' not in expression1 and 'If' not in expression1:
                        expression1=convert_pow_op_fun(simplify_expand_sympy(expression1))
                elif 'Or' not in expression1 and 'And' not in expression1 and 'Implies' not in expression1 and 'If' not in expression1:
                        expression1=convert_pow_op_fun(expression1)
                if '/' not in expression2 and 'Or' not in expression2 and '==' not in expression2 and 'And' not in expression2 and 'Implies' not in expression2 and 'If' not in expression2:
                        expression2=convert_pow_op_fun(simplify_expand_sympy(expression2))
                elif 'Or' not in expression2 and 'And' not in expression2 and 'Implies' not in expression2 and 'If' not in expression2:
                        expression2=convert_pow_op_fun(expression2)
                return 'Implies('+expression1+ ','+expression2+')'
            else:
                list_constrn=""
                for x in var_cstr_map:
                        if list_constrn=="":
                            expression1=expr2z3_update_postCond(args[0],var_cstr_map)
                        if '/' not in expression1 and 'Or' not in expression1 and '==' not in expression1 and 'And' not in expression1 and 'Implies' not in expression1 and 'If' not in expression1:
                            expression1=convert_pow_op_fun(simplify_expand_sympy(expression1))
                        elif 'Or' not in expression1 and 'And' not in expression1 and 'Implies' not in expression1 and 'If' not in expression1:
                            expression1=convert_pow_op_fun(expression1)
                            list_constrn="And("+expression1+","+var_cstr_map[x]+")"
                        else:
                            list_constrn="And("+list_constrn+","+var_cstr_map[x]+")"
                expression2=expr2z3_update_postCond(args[1],var_cstr_map)
                if '/' not in expression2 and 'Or' not in expression2 and '==' not in expression2 and 'And' not in expression2 and 'Implies' not in expression2 and 'If' not in expression2:
                    expression1=simplify_expand_sympy(expression2)
                elif 'Or' not in expression2 and 'And' not in expression2 and 'Implies' not in expression2 and 'If' not in expression2:
                     expression2=convert_pow_op_fun(expression2)
                return 'Implies('+list_constrn+ ','+expression2+')'
        elif op in _infix_op and len(args)==2:
            expression1=expr2z3_update_postCond(args[0],var_cstr_map)
            expression2=expr2z3_update_postCond(args[1],var_cstr_map)
            if '/' not in expression1 and 'Or' not in expression1 and '==' not in expression1 and 'And' not in expression1 and 'Implies' not in expression1 and 'If' not in expression1:
                expression1=simplify_expand_sympy(expression1)
            if '/' not in expression2 and 'Or' not in expression2 and '==' not in expression2 and 'And' not in expression2 and 'Implies' not in expression2 and 'If' not in expression2:
                expression2=simplify_expand_sympy(expression2)
            if op=='/':
                return '(' + expression1+ op+expression2+')'
            elif op=='**':
                if is_number(expression1)==True and is_number(expression2)==True:
                    return str(simplify(expression1+"**"+expression2))
                else:
                    return 'power((' + expression1+')'+','+'('+expression2+'))'
            elif op=='=':
                return '((' + expression1+ ')==('+expression2+'))'
            else:
                expression='((' + expression1+')'+ op+'('+expression2+'))'
                if '/' not in expression and 'Or' not in expression and '==' not in expression and 'And' not in expression and 'Implies' not in expression and 'If' not in expression:
                      return simplify_expand_sympy(expression)
                else:
                      return expression
        else:
            if op=='ite':
            	stmt_list=[]
            	final_stmt=''
            	for x in args:
                        stmt=conditionSimplifyPower(expr2z3_update_postCond(x,var_cstr_map))
                        if str(stmt)!='0':
                                stmt_list.append(stmt)
                        elif str(stmt)=='0' and '>' not in args[1] and '<' not in args[1] :
                                stmt_list.append(stmt)
            	if len(stmt_list)==2:
            		final_stmt='Implies('+final_stmt+','.join(stmt_list)+')'
            	else:
            		final_stmt='If('+final_stmt+','.join(stmt_list)+')'
            	return final_stmt
            else:
                if isArrayFunction(op)==True:
                       parameter_list=[]
                       defineDetailtemp=[]
                       defineDetailtemp.append(op)
                       parameter_list.append('array')
                       for x in range(0, len(args)):
                           parameter_list.append('int')
                       defineDetailtemp.append(len(args))
                       defineDetailtemp.append(parameter_list)
                       defineDetaillist.append(defineDetailtemp)
                return op +'('+ ','.join(list(expr2z3_update_postCond(x,var_cstr_map) for x in args))+ ')'









def conditionSimplifyPower(expression):
	if '/' not in expression and 'Or' not in expression and '==' not in expression and 'And' not in expression and 'If' not in expression and 'char(' not in expression and 'Implies' not in expression:
		return convert_pow_op_fun(simplify_expand_sympy(expression))
	elif 'Or' not in expression and 'And' not in expression and 'If' not in expression and 'char(' not in expression and 'Implies' not in expression:
		return convert_pow_op_fun(expression)
	else:
		return expression

#get variable
def expr2varlist(e,variable_list):
    args=expr_args(e)    
    op=expr_op(e)
    if len(args)==0:
    	if '_n' not in op and is_number(op)==False:
    		variable_list.append(op)
    else:
        if op=='and' or op=='or':
            if len(args)==1:
               expr2varlist(args[0],variable_list)
            else:
                for x in args:
                    expr2varlist(x,variable_list)
        elif op=='not' and len(args)==1:
            expr2varlist(args[0],variable_list)
        elif op=='implies' and len(args)==2:
        	expr2varlist(args[0],variable_list)
        	expr2varlist(args[1],variable_list)
        elif op in _infix_op and len(args)==2:
        	expr2varlist(args[0],variable_list)
        	expr2varlist(args[1],variable_list)
        else:
            for x in args:
                expr2varlist(x,variable_list)


#return the list of program variables in an expression 

def expr_func(e,v): #e - expr
    ret = []
    f = expr_op(e)
    if is_program_var(f,v) or '__VERIFIER_nondet' in f:
        ret.append(f)
    for e1 in expr_args(e):
        ret = ret + expr_func(e1,v)
    return ret
    

#substitution of functors: in e, replace functor n1 by n2
def expr_sub(e,n1,n2): # e - expr; n1,n2 - strings
    e1=list(expr_sub(x,n1,n2) for x in e[1:])
    if e[0]==n1:
        return [n2]+e1
    else:
        return e[:1]+e1
        

#substitution of functors in a set: in e, for all x in v1 but not in v2, replace x+n1 by x+n2
def expr_sub_set(e,n1,n2,v1,v2): #e - expr; n1,n2 - strings, v1, v2 - sets of strings
    e1 = list(expr_sub_set(e2,n1,n2,v1,v2) for e2 in e[1:])
    if e[0].endswith(n1):
        x = e[0][:len(e[0])-len(n1)]
        if (x in v1) and (not x in v2):
            return [x+n2]+e1
        else:
            return e[:1]+e1
    else:
        return e[:1]+e1
        
        

# expr_replace(e,e1,e2): replace all subterm e1 in e by e2

def expr_replace(e,e1,e2): #e,e1,e2: expr
    if e==e1:
        return e2
    else:
        return e[:1]+list(expr_replace(x,e1,e2) for x in expr_args(e))
        
        

# expr_sub_dict(e,d): d is a dictonary of substitutions: functor 'f' to e1=d['f'] so that in e, each f term f(t1,...,tk) is replaced by e1(_x1/t1,...,_xk/tk)

def expr_sub_dict(e,d):
    args = expr_args(e)
    args1 = list(expr_sub_dict(x,d) for x in args)
    if expr_op(e) in d:
        return expr_sub_var_list(d[expr_op(e)],list(expres('_x'+str(i+1)) for i in range(len(args))),args1)
    else:
        return expres(expr_op(e),args1)
        

# expr_sub_var_list(e,l1,l2): in e, replace all terms in l1 by the corresponding terms in l2

def expr_sub_var_list(e,l1,l2): #e: expr, l1,l2: lists of the same length of exprs
    for i,x in enumerate(l1):
        if e==x:
            return l2[i]
    return e[:1]+list(expr_sub_var_list(y,l1,l2) for y in expr_args(e))


# compute E[n] extend(e,n,excl,v). n is an expr like ['_n1'], excl is a container of strings that are not to be extended
def extend(e,n,excl,v):
    op = expr_op(e)
    x = [n] if (is_program_var(op,v) and not (op in excl)) or '__VERIFIER_nondet' in op else []
    return expres(op, list(extend(e1,n,excl,v) for e1 in expr_args(e)) + x)


#A dictionary of dependencies para is such that, if x is an input variable, then para[x] is a list whose first element is 1 and the second element is the variable's parameter name; otherwise, para[x] is the list of input variables that x is depended on. 
#example: para = { 'X':[1,['_y1']], 'X11':[0,['_y1','_y2'], ['X','Y']],...} meaning 'X' is an input variable parameterized as '_y1' and 'X11' is a function depending on X and Y whose corresponding parameters are '_y1' and '_y2', respectively.
#So after parameterization, X11(a,X) will become X11(a,_y1,_y1,_y2)

def parameterize_expres(e,para): 
    if e[0] in para:
        if para[e[0]][0] == 1:
            return para[e[0]][1]+list(parameterize_expres(x,para) for x in e[1:])
        else:
            return e[:1]+list(parameterize_expres(x,para) for x in e[1:])+para[e[0]][1]
    else:
        return e[:1]+list(parameterize_expres(x,para) for x in e[1:])


#parameterize non-input functions then restore the input variables to its name
#given above para, X11(a,X) will become X11(a,X,X,Y), assuming that _y2 corresponds to Y

def parameterize_expr_sub(e,para): 
    if e[0] in para:
        if para[e[0]][0] == 1:
            return [e[0]]+list(parameterize_expr_sub(x,para) for x in e[1:])
        else:
            return e[:1]+list(parameterize_expr_sub(x,para) for x in e[1:])+para[e[0]][2]
    else:
        return e[:1]+list(parameterize_expr_sub(x,para) for x in e[1:])




        


"""
 Formulas:
 1. equations f(x) = e: ['e',e1,e2], 
    where e1 is expression for f(x) and e2 for e
 2. inductive definition:
 - base case f(x1,...,xk,0,...,xm)=e: ['i0',k,e1,e2] 
   where e1 is Expr for f(x1,...,xk,0,...,xm) and e2 the Expr for e
 - inductive case f(x1,...,xk,n+1,...,xm)=e: ['i1',k,'n',e1,e2] 
    where e1 is Expr for f(x1,...,xk,n+1,...,xm) and e2 the Expr for e
 3. inductive definition for functions that return natural numbers 
    (like N in smallest macro):
 - base case f(x) = 0 iff C: ['d0',e,c] 
   where e is the Expr for f(x) and c an expression for condition C
 - inductive case f(x) = n+1 iff C(n): ['d1','n',e,c] 
   where e is the Expr for f(x) and c an Expr for condition C
 4. any other axioms: A: ['a',e], where e is the Expr for A
 5. constraints from smallest macro smallest(N,n,e):
    ['s0', e(N)] 
    ['s1', forall n<N -> not e]

 Examples: a' = a+1: ['e', ['a\''], ['+',['a'],['1']]]
 N(x) = 0 if x<I else N(x-1)+1 is divided into two axioms:
 N(x) = 0 iff x<I:  
 ['d0', ['N',['x']], ['<', ['x'],['I']]] and
 N(x) = n+1 iff n=N(x-1): 
 ['d1','n', ['N',['x']], ['=',['n'], ['N', ['-', ['x'],['1']]]]]
"""


# constructors
def wff_e(e1,e2): #e1,e2: expr
    return ['e',e1,e2]

def wff_i0(k,e1,e2): #k: int; e1,e2: expr
    return ['i0',k,e1,e2]

def wff_i1(k,v,e1,e2): #k: int; v: string; e1,e2: expr
    return ['i1',k,v,e1,e2]

def wff_d0(e,c): #e: expr; c: expr
    return ['d0',e,c]

def wff_d1(v,e,c): #v: string, e and c: expr
    return ['d1',v,e,c]

def wff_a(e): #e: expr
    return ['a',e]

def wff_s0(e):
    return ['s0',e]
def wff_s1(e):
    return ['s1',e]
    
    
#print in prefix notation
def wff2string(w):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1' or w[0] == 'R':
            return '(= '+expr2string(w[-2])+' '+expr2string(w[-1]) +')'
        elif w[0] == 'd0':
            return '(iff (= '+expr2string(w[1])+' 0) '+ expr2string(w[2])+')'
        elif w[0] == 'd1':
            return '(iff (= '+expr2string(w[2])+' (+ '+w[1]+' 1)) '+expr2string(w[3])+')'
        elif w[0]=='a' or w[0]=='s0' or w[0]=='s1' or w[0]=='c1' or w[0] == 'R':
            return expr2string(w[1])

#print in normal infix notation
def wff2string1(w):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1' or w[0] == 'R':
            return expr2string1(w[-2])+' = '+ expr2string1(w[-1])
        elif w[0] == 'd0':
            return expr2string1(w[1])+'=0 <=> '+ expr2string1(w[2])
        elif w[0] == 'd1':
            return expr2string1(w[2])+'='+w[1]+'+1 <=> '+expr2string1(w[3])
        elif w[0]=='a' or w[0]=='s0' or w[0]=='s1' or w[0]=='c1':
            return expr2string1(w[1])

            
#print in normal infix notation
def wff2stringvfact(w,var_map):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1' or w[0] == 'R':
            return expr2stringvfact(w[-2],var_map)+' = '+ expr2stringvfact(w[-1],var_map)
        elif w[0] == 'd0':
            return expr2stringvfact(w[1],var_map)+'=0 <=> '+ expr2stringvfact(w[2],var_map)
        elif w[0] == 'd1':
            return expr2stringvfact(w[2],var_map)+'='+w[1]+'+1 <=> '+expr2stringvfact(w[3],var_map)
        elif w[0]=='a' or w[0]=='s0' or w[0]=='s1' or w[0]=='c1':
            return expr2stringvfact(w[1],var_map)



#print in normal infix notation
def wff2stringvfact2(w,var_map,allvariablelist,constraints):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1' or w[0] == 'R':
            return expr2stringvfact2(w[-2],var_map,allvariablelist,constraints)+' = '+ expr2stringvfact2(w[-1],var_map,allvariablelist,constraints)
        elif w[0] == 'd0':
            return expr2stringvfact2(w[1],var_map,allvariablelist,constraints)+'=0 <=> '+ expr2stringvfact2(w[2],var_map,allvariablelist,constraints)
        elif w[0] == 'd1':
            return expr2stringvfact2(w[2],var_map,allvariablelist,constraints)+'='+w[1]+'+1 <=> '+expr2stringvfact2(w[3],var_map,allvariablelist,constraints)
        elif w[0]=='a' or w[0]=='s0' or w[0]=='s1' or w[0]=='c1' :
            return expr2stringvfact2(w[1],var_map,allvariablelist,constraints)



def getConstraints_Eq(w,allvariablelist,constraints):
    if w[0] == 'i1':
        temp_eq=copy.deepcopy(w[3])
        temp_eq=expr_replace(temp_eq,eval("['+',['"+w[2]+"'],['1']]"),eval("['"+w[2]+"']"))
        if isArrayFunction(w[3][0])==False:
            typename=getVariableType(w[3][0],allvariablelist)
            if typename=='unsigned':
                con_equ=[]
                con_equ.append('c1')
                con_equ1=[]
                con_equ1.append('>=')
                con_equ1.append(temp_eq)
                con_equ1.append(eval("['0']"))
                con_equ.append(con_equ1)
                return wff2z3_update_postCond(con_equ)
    return None

    




#strip '(' at the beginning and matching ')' in the end of a string
def trim_p(s):
    if s.startswith('(') and s.endswith(')'):
        return trim_p(s[1:-1])
    else:
        return s


#convert wff to z3 constraint
def wff2z3(w):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1':
            var_cstr_map={}
            lhs=expr2z3(w[-2],var_cstr_map)
            rhs=expr2z3(w[-1],var_cstr_map)
            list_var_str=qualifier_list(list(var_cstr_map.keys()))
            list_cstr_str=cstr_list(list(var_cstr_map.values()))
            lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                if w[0] == 'i1':
                        return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"
                else:
                        return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'd0': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
            lhs=expr2z3(w[1],var_cstr_map)
            rhs=expr2z3(w[2],var_cstr_map)
            list_var_str=qualifier_list(list(var_cstr_map.keys()))
            list_cstr_str=cstr_list(list(var_cstr_map.values()))
            lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                #return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+'=0 == '+ rhs+"))"
                return 'ForAll(['+list_var_str+'],'+lhs+'=0 == '+ rhs+")"
            else:
                return lhs+'=0 == '+ rhs
        elif w[0] == 'd1': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
            lhs=expr2z3(w[2],var_cstr_map)
            rhs=expr2z3(w[3],var_cstr_map)
            list_var_str=qualifier_list(list(var_cstr_map.keys()))
            list_cstr_str=cstr_list(var_cstr_map.values())
            lhs=convert_pow_op_fun(simplify_expand_sympy(w[1]+'+1'))
            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                #return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+rhs+"))"
                return "ForAll(["+list_var_str+"],"+lhs+' == '+rhs+")"
            else:
                return lhs+' == '+rhs
        elif w[0]=='a' or w[0]=='s0':
            var_cstr_map={}
            expression=expr2z3(w[1],var_cstr_map)
            list_var_str=qualifier_list(list(var_cstr_map.keys()))
            list_cstr_str=cstr_list(var_cstr_map.values())
            expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    arg_list[1]='Or('+axms[1]+'==0,'+arg_list[1].replace(axms[0],'('+axms[1]+'-1)')+')'
                    if list_var_str is not None and list_cstr_str is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies('+str(list_cstr_str)+','+arg_list[1]+'))'
                        #return 'ForAll(['+list_var_str+'],Implies('+arg_list[0]+','+arg_list[1]+'))'
                    else:
                        return arg_list[1]
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
                    #return 'ForAll(['+list_var_str+'],'+expression+')'
            else:
                return expression
        elif w[0]=='s1':
            var_cstr_map={}
            equations=[]
            expression=expr2z3(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    var_cstr_map_mod={}
                    for x in list(var_cstr_map.keys()):
                        if x!=axms[0]:
                            var_cstr_map_mod[x]=var_cstr_map[x]
                    list_var_str_new=qualifier_list(var_cstr_map_mod.keys())
                    list_cstr_str_new=cstr_list(var_cstr_map_mod.values())
                    old_arg_list=arg_list[1]
                    arg_list[1]='Or('+axms[1]+'==0,'+simplify_expand_sympy(arg_list[1].replace(axms[0],'('+axms[1]+'-1)'))+')'
                    if list_var_str_new is not None and list_cstr_str_new is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                        #equations.append('ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))')
                        #equations.append('ForAll(['+str(list_var_str_new)+'],Implies('+str(list_cstr_str_new)+','+arg_list[1]+'))')
                        #return equations
                        #return 'ForAll(['+list_var_str+'],Implies('+arg_list[0]+','+arg_list[1]+'))'
                    else:
                    	return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                        #equations.append('ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))')
                        #equations.append(arg_list[1])
                        #return equations
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
                    #return 'ForAll(['+list_var_str+'],'+expression+')'
        elif w[0] == 'R':
            var_cstr_map={}
            lhs=expr2z3(w[2],var_cstr_map)
            rhs=expr2z3(w[3],var_cstr_map)
            list_var_str=qualifier_list(w[1])
            lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs

        else:
            return expression







#convert wff to z3 constraint
def wff2z3_update(w):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1':
            var_cstr_map={}
            flag_constr=False
            lhs=expr2z3_update(w[-2],var_cstr_map)
            rhs=expr2z3_update(w[-1],var_cstr_map) 
            list_var_str=qualifier_list(var_cstr_map.keys())
            if isArrayFunction(w[-2][0])==True:
            	if '_x1' in list(var_cstr_map.keys()):
            		del var_cstr_map['_x1']
            	flag_constr=True
            if '_s1' in list(var_cstr_map.keys()):
                del var_cstr_map['_s1']
                flag_constr=True
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if w[-1][0] in ['==','<=','>=','>','<','!=','or','and']:
                rhs='If(('+rhs+')==0,0,1)'
            if list_var_str is not None and list_cstr_str is not None:
                if w[0] == 'i1':
                	return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"
                else:
                    if flag_constr==True:
                            return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"
                    else:
                            return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'd0': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
            lhs=expr2z3_update(w[1],var_cstr_map)
            rhs=expr2z3_update(w[2],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
                lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+'=0 == '+ rhs+")"
            else:
                return lhs+'=0 == '+ rhs
        elif w[0] == 'd1': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
            lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            lhs=w[1]+'+1'
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
                lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return "ForAll(["+list_var_str+"],"+lhs+' == '+rhs+")"
            else:
                return lhs+' == '+rhs
        elif w[0]=='a' or w[0]=='s0':
            var_cstr_map={}
            expression=expr2z3_update(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
                expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    arg_list[1]='Or('+axms[1]+'==0,'+arg_list[1].replace(axms[0],'('+axms[1]+'-1)')+')'
                    if list_var_str is not None and list_cstr_str is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies('+str(list_cstr_str)+','+arg_list[1]+'))'
                    else:
                        return arg_list[1]
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
                    
            else:
                return expression
        elif w[0]=='s1':
            var_cstr_map={}
            equations=[]
            expression=expr2z3_update(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
                expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    if '<' in str(constr):
                       axms=str(constr).split('<')
                       axms[0]=axms[0].strip()
                       axms[1]=axms[1].strip()
                    elif '>' in str(constr):
                       axms=str(constr).split('>')
                       axms[0]=axms[0].strip()
                       axms[1]=axms[1].strip()
                       temp = axms[0]
                       axms[0] = axms[1]
                       axms[0] = temp
                       
                    var_cstr_map_mod={}
                    for x in var_cstr_map.keys():
                        if x!=axms[0]:
                            var_cstr_map_mod[x]=var_cstr_map[x]
                    list_var_str_new=qualifier_list(var_cstr_map_mod.keys())
                    list_cstr_str_new=cstr_list(var_cstr_map_mod.values())

                    new_w = copy.deepcopy(w)
                    for element in var_cstr_map.keys():
                    	fun=[]
                    	fun.append('_f')
                    	parameter=[]
                    	parameter.append(element)
                    	fun.append(parameter)
                    	sub=[]
                    	sub.append(element)
                    	new_w[1]=expr_replace(new_w[1],sub,fun) #expr_replace_const(new_w[1],element,fun)
                    new_expression=expr2z3_update(new_w[1],var_cstr_map)
                    new_arg_list=extract_args(new_expression)
                    
                    #old_arg_list=arg_list[1]
                    old_arg_list=new_arg_list[1]
                    arg_list[1]='Or('+axms[1]+'==0,'+simplify_expand_sympy(arg_list[1].replace(axms[0],'('+axms[1]+'-1)'))+')'
                    if list_var_str_new is not None and list_cstr_str_new is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                    else:
                    	return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'

        elif w[0]=='c1':
            var_cstr_map={}
            equations=[]
            expression=expr2z3_update(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if list_var_str is not None and list_cstr_str is not None:
                return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
            else:
                return expression
        elif w[0]=='L1':
            var_cstr_map={}
            flag_constr=False
            lhs=expr2z3_update(w[-2],var_cstr_map)
            rhs=expr2z3_update(w[-1],var_cstr_map)           
            list_var_str=qualifier_list(var_cstr_map.keys())
            if isArrayFunction(w[-2][0])==True:
            		if '_x1' in var_cstr_map.keys():
            			del var_cstr_map['_x1']
            		flag_constr=True
            if '_s1' in var_cstr_map.keys():
                    del var_cstr_map['_s1']
                    flag_constr=True
            list_cstr_str=cstr_list(var_cstr_map.values())
            list_cstr_str2=cstr_list(var_cstr_map.values())
            if list_cstr_str is not None:
            		constant=w[2].replace('n','L')
            		list_cstr_str='And(And('+list_cstr_str+','+w[2]+'<'+constant+'),'+constant+'>0'+')'
            		list_cstr_str2='And(And('+list_cstr_str2+','+w[2]+'<'+constant+'+1),'+constant+'>0'+')'
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            		lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            		rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                    if w[0] == 'i1':
                        return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+lhs+' == '+ rhs+"))"+")"
                    else:
                       if flag_constr==True:
                           return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+lhs+' == '+ rhs+"))"+")"
                       else:
                            return "Implies("+'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"+","+'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"+")"
            else:
                    return "Implies("+lhs+' == '+ rhs+","+lhs+' == '+ rhs+")"
        elif w[0]=='L2':
                var_cstr_map={}
                flag_constr=False
                lhs=expr2z3_update(w[2],var_cstr_map)
                rhs=expr2z3_update(w[3],var_cstr_map)           
                list_var_str=qualifier_list(var_cstr_map.keys())
                list_cstr_str=cstr_list(var_cstr_map.values())
                list_cstr_str2=cstr_list(var_cstr_map.values())
                if list_cstr_str is not None:
                        constant=w[1].replace('n','L')
                        list_cstr_str='And(And('+list_cstr_str+','+w[1]+'<'+constant+'),'+constant+'>0'+')'
                        list_cstr_str2='And(And('+list_cstr_str+','+w[1]+'<'+constant+'+1),'+constant+'>0'+')'
                if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
                        lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                if list_var_str is not None and list_cstr_str is not None:
            	        return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+rhs+"))"+")"
                else:
                        return "Implies("+lhs+","+rhs+")"
        elif w[0] == 'R':
            var_cstr_map={}
            lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            list_var_str=qualifier_list(w[1])
            if list_var_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'RE':
            var_cstr_map={}
            if len(w[2])==0:
                lhs=None
            else:
                lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            if len(w[1])==0:
                list_var_str=None
            else:
                list_var_str=qualifier_list(w[1])
            if list_var_str is not None:
                if lhs!='' and lhs is not None:
                    return 'ForAll(['+list_var_str+'],Implies('+lhs+','+rhs+"))"
                else:
                    return 'ForAll(['+list_var_str+'],'+rhs+")"
            elif lhs!='' and lhs is not None:
                return 'Implies('+lhs+','+rhs+")"
            else:
                return rhs
        else:
            return expression







#convert wff to z3 constraint
def wff2z3_update_postCond(w):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1':
            var_cstr_map={}
            flag_constr=False
            lhs=expr2z3_update_postCond(w[-2],var_cstr_map)
            rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
            
            list_var_str=qualifier_list(var_cstr_map.keys())
            
            if isArrayFunction(w[-2][0])==True:
                del var_cstr_map['_x1']
                flag_constr=True
            if '_s1' in var_cstr_map.keys():
                del var_cstr_map['_s1']
                flag_constr=True
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                    
            if list_var_str is not None and list_cstr_str is not None:
                if w[0] == 'i1':
                    return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"
                else:
                    if flag_constr==True:
                        return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'd0': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
            lhs=expr2z3_update_postCond(w[1],var_cstr_map)
            rhs=expr2z3_update_postCond(w[2],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
                lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+'=0 == '+ rhs+")"
            else:
                return lhs+'=0 == '+ rhs
        elif w[0] == 'd1': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
            lhs=expr2z3_update_postCond(w[2],var_cstr_map)
            rhs=expr2z3_update_postCond(w[3],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            lhs=w[1]+'+1'
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
                lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return "ForAll(["+list_var_str+"],"+lhs+' == '+rhs+")"
            else:
                return lhs+' == '+rhs
        elif w[0]=='a' or w[0]=='s0':
            var_cstr_map={}
            expression=expr2z3_update_postCond(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
                expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    arg_list[1]='Or('+axms[1]+'==0,'+arg_list[1].replace(axms[0],'('+axms[1]+'-1)')+')'
                    if list_var_str is not None and list_cstr_str is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies('+str(list_cstr_str)+','+arg_list[1]+'))'
                    else:
                        return arg_list[1]
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
                    
            else:
                return expression
        elif w[0]=='s1':
            var_cstr_map={}
            equations=[]
            expression=expr2z3_update_postCond(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
                expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    var_cstr_map_mod={}
                    for x in var_cstr_map.keys():
                        if x!=axms[0]:
                            var_cstr_map_mod[x]=var_cstr_map[x]
                    list_var_str_new=qualifier_list(var_cstr_map_mod.keys())
                    list_cstr_str_new=cstr_list(var_cstr_map_mod.values())
                    old_arg_list=arg_list[1]
                    arg_list[1]='Or('+axms[1]+'==0,'+simplify_expand_sympy(arg_list[1].replace(axms[0],'('+axms[1]+'-1)'))+')'
                    if list_var_str_new is not None and list_cstr_str_new is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                    else:
                    	return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'

        elif w[0]=='c1':
            var_cstr_map={}
            equations=[]
            expression=expr2z3_update(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if list_var_str is not None and list_cstr_str is not None:
                return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
            else:
                return expression     
        elif w[0] == 'R':
            var_cstr_map={}
            lhs=expr2z3_update_postCond(w[2],var_cstr_map)
            rhs=expr2z3_update_postCond(w[3],var_cstr_map)
            list_var_str=qualifier_list(w[1])
            lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'RE':
            var_cstr_map={}
            lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            list_var_str=qualifier_list(w[1])
            if list_var_str is not None:
                if lhs!='' and lhs is not None:
                    return 'ForAll(['+list_var_str+'],Implies('+lhs+','+rhs+"))"
                else:
                    return 'ForAll(['+list_var_str+'],'+lhs+")"
            else:
                return lhs
        else:
            return expression








#convert wff to z3 constraint
def wff2z3_update1(w,const_var_map):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1':
            var_cstr_map={}
            flag_constr=False
            lhs=expr2z3_update(w[-2],var_cstr_map)
            rhs=expr2z3_update(w[-1],var_cstr_map) 
            list_var_str=qualifier_list(var_cstr_map.keys())
            #print '----------------------'
            #print list_var_str
            #print '----------------------'
            if isArrayFunction(w[-2][0])==True:
            	if '_x1' in var_cstr_map.keys():
            		del var_cstr_map['_x1']
            	flag_constr=True
            if '_s1' in var_cstr_map.keys():
                del var_cstr_map['_s1']
                flag_constr=True
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if w[-1][0] in ['==','<=','>=','>','<','!=','or','and']:
                rhs='If(('+rhs+')==0,0,1)'
            if list_var_str is not None and list_cstr_str is not None:
                if w[0] == 'i1':
                        return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+",("+lhs+') == ('+ rhs+")))"
                else:
                        if flag_constr==True:
                                return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+",("+lhs+') == ('+ rhs+"))"
                        else:
                                return 'ForAll(['+list_var_str+'],('+lhs+') == ('+ rhs+"))"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'd0': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
            lhs=expr2z3_update(w[1],var_cstr_map)
            rhs=expr2z3_update(w[2],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
                lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return 'ForAll(['+list_var_str+'],('+lhs+'=0) == ('+ rhs+"))"
            else:
                return lhs+'=0 == '+ rhs
        elif w[0] == 'd1': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
            lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            lhs=w[1]+'+1'
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
                lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return "ForAll(["+list_var_str+"],"+lhs+' == '+rhs+")"
            else:
                return lhs+' == '+rhs
        elif w[0]=='a' or w[0]=='s0':
            var_cstr_map={}
            expression=expr2z3_update(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
                expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    arg_list[1]='Or('+axms[1]+'==0,'+arg_list[1].replace(axms[0],'('+axms[1]+'-1)')+')'
                    if list_var_str is not None and list_cstr_str is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies('+str(list_cstr_str)+','+arg_list[1]+'))'
                    else:
                        return arg_list[1]
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
                    
            else:
                return expression
        elif w[0]=='s1':
            var_cstr_map={}
            equations=[]
            expression=expr2z3_update(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
                expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    var_cstr_map_mod={}
                    for x in var_cstr_map.keys():
                        if x!=axms[0]:
                            var_cstr_map_mod[x]=var_cstr_map[x]
                    list_var_str_new=qualifier_list(var_cstr_map_mod.keys())
                    list_cstr_str_new=cstr_list(var_cstr_map_mod.values())

                    new_w = copy.deepcopy(w)
                    for element in var_cstr_map.keys():
                    	fun=[]
                    	fun.append('_f')
                    	parameter=[]
                    	parameter.append(element)
                    	fun.append(parameter)
                    	sub=[]
                    	sub.append(element)
                    	new_w[1]=expr_replace(new_w[1],sub,fun) #expr_replace_const(new_w[1],element,fun)
                    new_expression=expr2z3_update(new_w[1],var_cstr_map)
                    new_arg_list=extract_args(new_expression)
                    
                    #old_arg_list=arg_list[1]
                    old_arg_list=new_arg_list[1]
                    arg_list[1]='Or('+axms[1]+'==0,'+simplify_expand_sympy(arg_list[1].replace(axms[0],'('+axms[1]+'-1)'))+')'
                    if list_var_str_new is not None and list_cstr_str_new is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                    else:
                    	return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'

        elif w[0]=='c1':
            var_cstr_map={}
            equations=[]
            expression=expr2z3_update(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            if list_var_str is not None and list_cstr_str is not None:
                         return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
            else:
                         return expression
        elif w[0]=='L1':
                var_cstr_map={}
                flag_constr=False
                lhs=expr2z3_update(w[-2],var_cstr_map)
                rhs=expr2z3_update(w[-1],var_cstr_map)           
                list_var_str=qualifier_list(var_cstr_map.keys())
                if isArrayFunction(w[-2][0])==True:
                        if '_x1' in var_cstr_map.keys():
                            del var_cstr_map['_x1']
                        flag_constr=True
                if '_s1' in var_cstr_map.keys():
                    del var_cstr_map['_s1']
                    flag_constr=True
                list_cstr_str=cstr_list(var_cstr_map.values())
                list_cstr_str2=cstr_list(var_cstr_map.values())
                #add by pritom 30/08/2017
                if list_cstr_str is not None:
                        constant=w[2].replace('n','L')
                        list_cstr_str='And(And('+list_cstr_str+','+w[2]+'<'+constant+'),'+constant+'>0'+')'
                        list_cstr_str2='And(And('+list_cstr_str2+','+w[2]+'<'+constant+'+1),'+constant+'>0'+')'
                if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
                        lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                if list_var_str is not None and list_cstr_str is not None:
                    if w[0] == 'i1':
                        return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+lhs+' == '+ rhs+"))"+")"
                    else:
                        if flag_constr==True:
                           return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+lhs+' == '+ rhs+"))"+")"
                        else:
                            return "Implies("+'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"+","+'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"+")"
                else:
                	return "Implies("+lhs+' == '+ rhs+","+lhs+' == '+ rhs+")"
        elif w[0]=='L2':
            var_cstr_map={}
            flag_constr=False
            hs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)           
            list_var_str=qualifier_list(var_cstr_map.keys())

            list_cstr_str=cstr_list(var_cstr_map.values())
            list_cstr_str2=cstr_list(var_cstr_map.values())

            if list_cstr_str is not None:
            		constant=w[1].replace('n','L')
            		list_cstr_str='And(And('+list_cstr_str+','+w[1]+'<'+constant+'),'+constant+'>0'+')'
            		list_cstr_str2='And(And('+list_cstr_str+','+w[1]+'<'+constant+'+1),'+constant+'>0'+')'
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            		lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            		rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
            		return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+rhs+"))"+")"
            else:
                	return "Implies("+lhs+","+rhs+")"
        elif w[0] == 'R':
            var_cstr_map={}
            lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            list_var_str=qualifier_list(w[1])
            if list_var_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'RE':
            var_cstr_map={}
            if len(w[2])==0:
                lhs=None
            else:
                lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            if len(w[1])==0:
                list_var_str=None
            else:
                list_var_str=qualifier_list(w[1])
            if list_var_str is not None:
                if lhs!='' and lhs is not None:
                    return 'ForAll(['+list_var_str+'],Implies('+lhs+','+rhs+"))"
                else:
                    return 'ForAll(['+list_var_str+'],'+rhs+")"
            elif lhs!='' and lhs is not None:
                return 'Implies('+lhs+','+rhs+")"
            else:
                return rhs
        else:
            return expression







#convert wff to z3 constraint
def wff2z3_update4(w,var_dim_map,const_var_map):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1':
            var_cstr_map={}
            flag_constr=False
            lhs=expr2z3_update(w[-2],var_cstr_map)
            rhs=expr2z3_update(w[-1],var_cstr_map) 
            list_var_str=qualifier_list(var_cstr_map.keys())
            #print '----------------------'
            #print list_var_str
            #print '----------------------'
            if isArrayFunction(w[-2][0])==True:
            	if '_x1' in var_cstr_map.keys():
            		del var_cstr_map['_x1']
            	flag_constr=True
            if '_s1' in var_cstr_map.keys():
                del var_cstr_map['_s1']
                flag_constr=True
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            if flag_constr==True:
                if  w[-2][1][0] in var_dim_map.keys():
                    list_cstr_str_temp=None
                    list_cstr_str_temp=cstr_list_additional1(list_cstr_str_temp,var_cstr_map.keys(),var_dim_map[w[-2][1][0]].getDimensions().keys(),var_dim_map[w[-2][1][0]].getDimensions())
                    if list_cstr_str_temp is not None:
                        if list_cstr_str is None:
                            list_cstr_str = list_cstr_str_temp
                        else:
                            list_cstr_str = "And("+list_cstr_str +','+ list_cstr_str_temp+")"
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
            	lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if w[-1][0] in ['==','<=','>=','>','<','!=','or','and']:
                rhs='If(('+rhs+')==0,0,1)'
            if list_var_str is not None and list_cstr_str is not None:
                if w[0] == 'i1':
                    return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"
                else:
                    if flag_constr==True:
                        return "ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"
                    else:
                        return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'd0': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
            lhs=expr2z3_update(w[1],var_cstr_map)
            rhs=expr2z3_update(w[2],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
               lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                          rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+'=0 == '+ rhs+")"
            else:
                return lhs+'=0 == '+ rhs
        elif w[0] == 'd1': # Bi-implications are represented using equality == in z3py
            var_cstr_map={}
            lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            lhs=w[1]+'+1'
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
                lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
            	rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return "ForAll(["+list_var_str+"],"+lhs+' == '+rhs+")"
            else:
                return lhs+' == '+rhs
        elif w[0]=='a' or w[0]=='s0':
            var_cstr_map={}
            expression=expr2z3_update(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            #print '----------------------'
            #print list_var_str
            #print '----------------------'
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
                expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    arg_list[1]='Or('+axms[1]+'==0,'+arg_list[1].replace(axms[0],'('+axms[1]+'-1)')+')'
                    if list_var_str is not None and list_cstr_str is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies('+str(list_cstr_str)+','+arg_list[1]+'))'
                    else:
                        return arg_list[1]
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
                    
            else:
                return expression
        elif w[0]=='s1':
            var_cstr_map={}
            equations=[]
            expression=expr2z3_update(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression:
                expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    axms=str(constr).split('<')
                    axms[0]=axms[0].strip()
                    axms[1]=axms[1].strip()
                    var_cstr_map_mod={}
                    for x in var_cstr_map.keys():
                        if x!=axms[0]:
                            var_cstr_map_mod[x]=var_cstr_map[x]
                    list_var_str_new=qualifier_list(var_cstr_map_mod.keys())
                    list_cstr_str_new=cstr_list(var_cstr_map_mod.values())

                    new_w = copy.deepcopy(w)
                    for element in var_cstr_map.keys():
                    	fun=[]
                    	fun.append('_f')
                    	parameter=[]
                    	parameter.append(element)
                    	fun.append(parameter)
                    	sub=[]
                    	sub.append(element)
                    	new_w[1]=expr_replace(new_w[1],sub,fun) #expr_replace_const(new_w[1],element,fun)
                    new_expression=expr2z3_update(new_w[1],var_cstr_map)
                    new_arg_list=extract_args(new_expression)
                    
                    #old_arg_list=arg_list[1]
                    old_arg_list=new_arg_list[1]
                    arg_list[1]='Or('+axms[1]+'==0,'+simplify_expand_sympy(arg_list[1].replace(axms[0],'('+axms[1]+'-1)'))+')'
                    if list_var_str_new is not None and list_cstr_str_new is not None:
                        return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                    else:
                    	return 'ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'

        elif w[0]=='c1':
            var_cstr_map={}
            equations=[]
            expression=expr2z3_update(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            list_cstr_str=cstr_list_additional(list_cstr_str,var_cstr_map.keys(),const_var_map)
            if list_var_str is not None and list_cstr_str is not None:
               return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
            else:
                return expression
        elif w[0]=='L1':
            var_cstr_map={}
            flag_constr=False
            lhs=expr2z3_update(w[-2],var_cstr_map)
            rhs=expr2z3_update(w[-1],var_cstr_map)           
            list_var_str=qualifier_list(var_cstr_map.keys())
            if isArrayFunction(w[-2][0])==True:
                if '_x1' in var_cstr_map.keys():
                    del var_cstr_map['_x1']
                flag_constr=True
            	
            list_cstr_str=cstr_list(var_cstr_map.values())
            list_cstr_str2=cstr_list(var_cstr_map.values())
            #add by pritom 30/08/2017
            if list_cstr_str is not None:
                constant=w[2].replace('n','L')
                list_cstr_str='And(And('+list_cstr_str+','+w[2]+'<'+constant+'),'+constant+'>0'+')'
                list_cstr_str2='And(And('+list_cstr_str2+','+w[2]+'<'+constant+'+1),'+constant+'>0'+')'
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
                lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                if w[0] == 'i1':
                    return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+lhs+' == '+ rhs+"))"+")"
                else:
                    if flag_constr==True:
                        return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+' == '+ rhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+lhs+' == '+ rhs+"))"+")"
                    else:
                        return "Implies("+'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"+","+'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"+")"
            else:
                return "Implies("+lhs+' == '+ rhs+","+lhs+' == '+ rhs+")"
        elif w[0]=='L2':
            var_cstr_map={}
            flag_constr=False
            lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)           
            list_var_str=qualifier_list(var_cstr_map.keys())

            list_cstr_str=cstr_list(var_cstr_map.values())
            list_cstr_str2=cstr_list(var_cstr_map.values())

            if list_cstr_str is not None:
                constant=w[1].replace('n','L')
                list_cstr_str='And(And('+list_cstr_str+','+w[1]+'<'+constant+'),'+constant+'>0'+')'
                list_cstr_str2='And(And('+list_cstr_str+','+w[1]+'<'+constant+'+1),'+constant+'>0'+')'
            if 'Or' not in lhs and 'And' not in lhs and 'If' not in lhs and '/' not in lhs:
                lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                return "Implies("+"ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+lhs+"))"+","+"ForAll(["+list_var_str+"],Implies("+list_cstr_str2+","+rhs+"))"+")"
            else:
                return "Implies("+lhs+","+rhs+")"
        elif w[0] == 'R':
            var_cstr_map={}
            lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            list_var_str=qualifier_list(w[1])
            if list_var_str is not None:
                return 'ForAll(['+list_var_str+'],'+lhs+' == '+ rhs+")"
            else:
                return lhs+' == '+ rhs
        elif w[0] == 'RE':
            var_cstr_map={}
            if len(w[2])==0:
                lhs=None
            else:
                lhs=expr2z3_update(w[2],var_cstr_map)
            rhs=expr2z3_update(w[3],var_cstr_map)
            if len(w[1])==0:
                list_var_str=None
            else:
                list_var_str=qualifier_list(w[1])
            if list_var_str is not None:
                if lhs!='' and lhs is not None:
                    return 'ForAll(['+list_var_str+'],Implies('+lhs+','+rhs+"))"
                else:
                    return 'ForAll(['+list_var_str+'],'+rhs+")"
            elif lhs!='' and lhs is not None:
                return 'Implies('+lhs+','+rhs+")"
            else:
                return rhs
        else:
            return expression



#convert wff to z3 constraint(Special Case N=0 V E(n/(N-1)))
def wff2z3SC_update(w):
	if w[0]=='s1':
            var_cstr_map={}
            equations=[]
            expression=expr2z3_update(w[1],var_cstr_map)
            list_var_str=qualifier_list(var_cstr_map.keys())
            list_cstr_str=cstr_list(var_cstr_map.values())
            #expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if 'Or' not in expression and 'And' not in expression and 'If' not in expression and '/' not in expression and 'Implies' not in expression:
                expression=convert_pow_op_fun(simplify_expand_sympy(expression))
            if list_var_str is not None and list_cstr_str is not None:
                if 'Implies' in expression:
                    arg_list=extract_args(expression)
                    constr=simplify(arg_list[0])
                    if '<' in str(constr):
                       axms=str(constr).split('<')
                       axms[0]=axms[0].strip()
                       axms[1]=axms[1].strip()
                    elif '>' in str(constr):
                       axms=str(constr).split('>')
                       axms[0]=axms[0].strip()
                       axms[1]=axms[1].strip()
                       temp = axms[0]
                       axms[0] = axms[1]
                       axms[1] = temp

                    var_cstr_map_mod={}
                    for x in var_cstr_map.keys():
                        if x!=axms[0]:
                            var_cstr_map_mod[x]=var_cstr_map[x]
                    list_var_str_new=qualifier_list(var_cstr_map_mod.keys())
                    list_cstr_str_new=cstr_list(var_cstr_map_mod.values())
                    old_arg_list=arg_list[1]
                    
                    arg_list[1]='Or('+axms[1]+'==0,'+simplify_expand_sympy(arg_list[1].replace(axms[0],'('+axms[1]+'-1)'))+')'
                    if list_var_str_new is not None and list_cstr_str_new is not None:
                        #equations.append('ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))'
                        return 'ForAll(['+str(list_var_str_new)+'],Implies('+str(list_cstr_str_new)+','+arg_list[1]+'))'
                        #return equations
                        #return 'ForAll(['+list_var_str+'],Implies('+arg_list[0]+','+arg_list[1]+'))'
                    else:
                        #equations.append('ForAll(['+str(list_var_str)+'],Implies(And('+arg_list[0]+','+str(list_cstr_str)+'),'+old_arg_list+'))')
                        return arg_list[1]
                        #return equations
                else:
                    return 'ForAll(['+list_var_str+'],Implies('+list_cstr_str+','+expression+'))'
                    #return 'ForAll(['+list_var_str+'],'+expression+')'
                    
                    
                    




#Function Collect Condition From All Recursive  Formulas

def getAllCondtion(w,condition_map):
	if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1':
            var_cstr_map={}
            lhs=expr2z3(w[-2],var_cstr_map)
            rhs=expr2z3(w[-1],var_cstr_map)
            if 'ite' not in str(rhs):
                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            extract_conditions(rhs,condition_map)
        

def extract_conditions(expression,condition_map):
	if 'If' in expression:
            axioms=extract_args(expression)
            condition_map[axioms[0]]=axioms[0]
            if 'If' in axioms[1]:
                extract_conditions(axioms[1],condition_map)
            if 'If' in axioms[2]:
                extract_conditions(axioms[2],condition_map)









#print in normal infix notation
def wff2subslist(w):
        if w[0] == 'e':
            return expr2string1(w[-2]),expr2string1(w[-1])
 


#construct constraints for qualified variables
        
def qualifier_list(list_var):
    list_var = list(list_var)
    if len(list_var)==0:
        return None;
    else:
        var=list_var[-1]
        del list_var[-1]
        list_var_str=qualifier_list(list_var)
        if list_var_str is None:
            return var
        else:
            return var+","+list_var_str


#construct map of all array functions

def array_element_list(e,array_map): #e,e1,e2: expr
    if isArrayFunction(e[:1][0])==True:
            array_map[e[:1][0]]=e[:1][0]
            for x in expr_args(e):
                array_element_list(x,array_map)
    else:
            for x in expr_args(e):
                array_element_list(x,array_map)

#construct constraints for qualified variables

def cstr_list(list_cstr):
    list_cstr = list(list_cstr)
    if len(list_cstr)==0:
        return None;
    else:
        var=list_cstr[-1]
        del list_cstr[-1]
        list_cstr_str=cstr_list(list_cstr)
        if list_cstr_str is None:
            return var
        else:
            return "And("+var+","+list_cstr_str+")"
        
        
        
#construct constraints for qualified variables

def cstr_list_additional(list_cstr_str,list_cstr,const_var_map):
    if len(list_cstr)==0:
        return list_cstr_str;
    else:
        var=list_cstr[-1]
        del list_cstr[-1]
        if list_cstr_str is None:
            list_cstr_str=cstr_list_additional(list_cstr_str,list_cstr,const_var_map)
        else:
            list_cstr_str = cstr_list_additional(list_cstr_str,list_cstr,const_var_map)
        if var in list(const_var_map.keys()):
            if list_cstr_str is None:
                return var+"<"+const_var_map[var]
            else:
                return "And("+var+"<"+const_var_map[var]+","+list_cstr_str+")"
        else:
            return list_cstr_str;


def cstr_list_additional1(list_cstr_str,variable_list,list_cstr,const_var_map):
    if len(list_cstr)==0:
        return list_cstr_str;
    else:
        var=list_cstr[-1]
        del list_cstr[-1]
        if list_cstr_str is None:
            list_cstr_str = cstr_list_additional1(list_cstr_str,variable_list,list_cstr,const_var_map)
        else:
            result = cstr_list_additional1(list_cstr_str,variable_list,list_cstr,const_var_map)
            if result is not None:
                list_cstr_str="And("+result+","+list_cstr_str+")"
        if var in list(const_var_map.keys()) and var in variable_list:
            if list_cstr_str is None:
                return var+"<"+const_var_map[var]
            else:
                return "And("+var+"<"+const_var_map[var]+","+list_cstr_str+")"
        else:
            return list_cstr_str;




#strip '(' at the beginning and matching ')' in the end of a string
def trim_p(s):
    if s.startswith('(') and s.endswith(')'):
        return trim_p(s[1:-1])
    else:
        return s



#for a formula w, compute w[n]
def wff_extend(w,n,excl,v): #w: wff, n: expr, excl: container of strings
    if w[0]=='e': #['e',e1,e2]
        return ['e',extend(w[1],n,excl,v),extend(w[2],n,excl,v)]
    elif w[0]=='i0': #['i0',k,e1,e2]
        return ['i0',w[1],extend(w[2],n,excl,v),extend(w[3],n,excl,v)]
    elif w[0]=='i1': #['i1',k,v,e1,e2]
        return ['i1',w[1],w[2],extend(w[3],n,excl,v),extend(w[4],n,excl,v)]
    elif w[0]=='d0': #['d0',e,c]
        return ['d0',extend(w[1],n,excl,v),extend(w[2],n,excl,v)]
    elif w[0]=='d1': #['d1',v,e,c]
        return ['d1',w[1],extend(w[2],n,excl,v),extend(w[3],n,excl,v)]
    elif w[0]=='a' or w[0]=='s0' or w[0]=='s1': 
        return [w[0], extend(w[1],n,excl,v)]
    else:
        print('Not a wff')
        return
        

#for a formula w, replace functor old by new
def wff_sub(w,old,new): #w - wff; old, new - string
    if w[0]=='e': #['e',e1,e2]
        return ['e',expr_sub(w[1],old,new),expr_sub(w[2],old,new)]
    elif w[0]=='i0': #['i0',k,e1,e2]
        return ['i0',w[1],expr_sub(w[2],old,new),expr_sub(w[3],old,new)]
    elif w[0]=='i1': #['i1',k,v,e1,e2]
        return ['i1',w[1],w[2],expr_sub(w[3],old,new),expr_sub(w[4],old,new)]
    elif w[0]=='d0': #['d0',e,c]
        return ['d0',expr_sub(w[1],old,new),expr_sub(w[2],old,new)]
    elif w[0]=='d1': #['d1',v,e,c]
        return ['d1',w[1],expr_sub(w[2],old,new),expr_sub(w[3],old,new)]
    elif w[0]=='a' or w[0]=='s0' or w[0]=='s1': #['a',e]
        return [w[0],expr_sub(w[1],old,new)]
    else:
        print('Not a wff')
        return
        

#for a formula w, replace functor x+old by x+new for those in v1 but not in v2
def wff_sub_set(w,old,new,v1,v2): #w - wff; old, new - string; v1,v2: sets
    if w[0]=='e': #['e',e1,e2]
        return ['e',expr_sub_set(w[1],old,new,v1,v2),expr_sub_set(w[2],old,new,v1,v2)]
    elif w[0]=='i0': #['i0',k,e1,e2]
        return ['i0',w[1],expr_sub_set(w[2],old,new,v1,v2),expr_sub_set(w[3],old,new,v1,v2)]
    elif w[0]=='i1': #['i1',k,v,e1,e2]
        return ['i1',w[1],w[2],expr_sub_set(w[3],old,new,v1,v2),expr_sub_set(w[4],old,new,v1,v2)]
    elif w[0]=='d0': #['d0',e,c]
        return ['d0',expr_sub_set(w[1],old,new,v1,v2),expr_sub_set(w[2],old,new,v1,v2)]
    elif w[0]=='d1': #['d1',v,e,c]
        return ['d1',w[1],expr_sub_set(w[2],old,new,v1,v2),expr_sub_set(w[3],old,new,v1,v2)]
    elif w[0]=='a' or w[0]=='s0' or w[0]=='s1': #['a',e]
        return [w[0],expr_sub_set(w[1],old,new,v1,v2)]
    else:
        print('Not a wff')
        return

#like expr_sub_dict(e,d) but on wffs

def wff_sub_dict(w,d): #w - wff; d - a dictionary as in expr_sub_dict(e,d)
    if w[0]=='e': #['e',e1,e2]
        return w[:2]+[expr_sub_dict(w[2],d)]
    elif w[0]=='i0': #['i0',k,e1,e2]
        return w[:3]+[expr_sub_dict(w[3],d)]
    elif w[0]=='i1': #['i1',k,v,e1,e2]
        return w[:4]+[expr_sub_dict(w[4],d)]
    elif w[0]=='d0': #['d0',e,c]
        return w[:2]+[expr_sub_dict(w[2],d)]
    elif w[0]=='d1': #['d1',v,e,c]
        return w[:3]+[expr_sub_dict(w[3],d)]
    elif w[0]=='a' or w[0]=='s0' or w[0]=='s1': #['a',e]
        return [w[0],expr_sub_dict(w[1],d)]
    else:
        print('Not a wff')
        return

#parameterize a set of axioms by making program functions as input variables
#para = { 'X':[1,['_y1']], 'X11':[0,['_y1','_y2'],['X','Y']],...} meaning 'X' is an input variable parameterized as '_y1' and 'X11' is a function taking two new parameters '_y1','_y2'
#X11(a,X)=X11(a+b,1) will become X11(a,_y1,_y1,_y2)=X11(a+b,1,_y1,_y2)
 
def parameterize_wff(ax,para):
    if not (ax[0] == 'a' or ax[0]=='s0' or ax[0]=='s1'):
        e1 = parameterize_expres(ax[-2],para)
        e2 = parameterize_expres(ax[-1],para)
        return ax[:-2]+[e1,e2]
    else:
        e2 = parameterize_expres(ax[-1],para)
        return [ax[0],e2]
        

#for all x in dep_set, add dep_set[x] as arguments, except when x is RET+OUT,
#replace it by foo()

def parameterize_axioms_fun(axioms,dep_set):
    for x in axioms:
        parameterize_wff_fun(x,dep_set)

def parameterize_wff_fun(ax,dep_set):
    if not (ax[0] == 'a' or ax[0]=='s0' or ax[0]=='s1'):
        e1 = parameterize_expres_fun(ax[-2],dep_set)
        e2 = parameterize_expres_fun(ax[-1],dep_set)
        return ax[:-2]+[e1,e2]
    else:
        e2 = parameterize_expres_fun(ax[-1],dep_set)
        return [ax[0],e2]

def parameterize_expres_fun(e,dep_set): 
    if e[0]==RET+OUT:
        if len(e) != 1:
            print('Something is wrong '+RET+OUT+' should not have arguments')
            return
        else:
            return dep_set[RET+OUT]
    elif e[0] in dep_set:
        return expres(e[0],list(parameterize_expres_fun(x,dep_set) for x in e[1:])+dep_set[e[0]])
    else:
        return expres(e[0],list(parameterize_expres_fun(x,dep_set) for x in e[1:]))
        
        
    

def eqset2string(d):
    for x in d:
        print(wff2string(d[x]))
def eqset2string1(d):
    for x in d:
        print(wff2string1(d[x]))

def eqset2string1String(d):
    OUTPUT=''
    for x in d:
        OUTPUT+=wff2string1(d[x])+"\n"
    return OUTPUT

 
def eqset2stringvfact(d,var_map):
    for x in d:
        wff2stringvfact(d[x],var_map)
        
def eqset2constraintlist(d):
    equation_list=[]
    for x in d:
        equation_list.append(wff2z3(d[x]))
    return equation_list
    

def eqset2constraintlist_update(d):
    equation_list=[]
    for x in d:
        equation_list.append(wff2z3_update(d[x]))
    return equation_list    
    


def eqset2constraintlist4_update(d,var_dim_map,const_var_map):
    equation_list=[]
    for x in d:
        equation_list.append(wff2z3_update4(d[x],var_dim_map,const_var_map))
    return equation_list 
    
    
    
    
def eqset2subs_list(d):
    subs_list={}
    for x in d:
        lhs,rhs=wff2subslist(d[x])
        if 'ite' not in rhs and 'E' not in str(lhs) and 'e' not in str(lhs):
        	subs_list[simplify(lhs)]=simplify_sympy(rhs)
        elif 'E' not in str(lhs) and 'e' not in str(lhs):
                subs_list[lhs]=rhs
    return subs_list
def eqset2subs_list_ind(d):
    subs_list={}
    for x in d:
        if x[0]=='i1':
            lhs=expr2string1(x[-2])
            rhs=expr2string1(x[-1])
            lhs=convert_pow_op_fun(simplify_expand_sympy(lhs))
            rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            subs_list[lhs]=rhs
    return subs_list
    
"""
 A program variable has the attributes: its name, its type, 
 and its corresponding logical variable when parameterized. 
 A set of program variables is represented by a dictionary 
 with variable names as keys.
 examples: { 'X':['_y1','init','int','char'], 'I':['_y2','int'] }
 This set contains two program variables: 
 constant I of int value and function X from int*int to char
 Notice that the arity of a variable x in a set d is len(d[x])-2
 We assume no local function definitions, so the p in 'if b then p else p'
 'while b do p', 'foo(x,...,y) {b}' is a normal body of program statements.

 Program representations:
1. an assignment (l is the label, l='-1' means no label)
 l: left = right
 by [l,'=',e1,e2], 
 where e1,e2 are expressions representing left and right, respectively
2. a sequence
 p1; p2
 by ['-1','seq',p1,p2]
 where p1 and p2 are programs
3. if-then:
 l: if C then P
by [l,'if1', c,p], where c is the expression for C and p a program for P
4. if-then-else
 l: if c then p1 else p2
by [l,'if2', c,p1,p2], 
where c is Expr, p1 and p2 are Prog
5. while loop
 l: while c {b} by
[l,'while', c,b], 
where c is Expr, b is Prog
6. function definition
 foo(x,...,y) { B }
['-1','fun',['foo','x',..,'y'], b]
where 'foo' is the name of the function, 'x',...,'y' parameters, and
b the Prog representing B. We assume that B has no local function, i.e.
a normal body of statements. 
We assume a unique string 'RET' representing return
value because we do not have a special return statement.
Instead, a return statement
 l: return E
is represented as a normal assignment
 l: RET = e
We expect this will be the last statement of the body b
7. sequence of functions
 foo1(...) {B1}, ..., fook(...) {Bk}
['-1', 'prog', [f1,...,fk]]
where fi is the program representation of fooi(...) {Bi}. For this, the list
of variables v needs to be a dictionary indexed by the function names 
'foo1',...,'fook' whose value v['foo'] is the list of variables used in the function

"""



# for testing flag=1 (original translation), flag=2 (inductive definition for smallest N)
def translate1(p,v,flag):
    global TC
    global LC
    TC=0
    LC=0
    if p[1]=='prog':

        f_map={}
        a_map={}
        o_map={}

        ff_map={}
        aa_map={}
        oo_map={}

        fff_map={}
        aaa_map={}
        ooo_map={}

        cm_map={}


        assert_list_map={}
        assume_list_map={}
        assert_key_map={}

        assert_list_map_mom_two={}
        assume_list_map_mom_two={}
        assert_key_map_mom_two={}


        assert_list_map_mom_three={}
        assume_list_map_mom_three={}
        assert_key_map_mom_three={}


        res = translate0(p,v,flag)
        for fn in res:
            x,f,o,a,l = res[fn]

            
            #print f
	    #print o
            #print('Output for '+fn+':')
            
            #f,o,a,cm = rec_solver(f,o,a)

            #cm=[]          
            #print f
            #print o
            #print a

            ff = copy.deepcopy(f)
            fff = copy.deepcopy(f)

            oo = copy.deepcopy(o)
            ooo = copy.deepcopy(o)

            aa = copy.deepcopy(a)
            aaa = copy.deepcopy(a)

            #print('===============##################')
            #print(a)
            #print('===============##################')
            #print(o)
            #print('===============##################')


            f,o,a,ff,oo,aa,fff,ooo,aaa,cm = rec_solver_moment(f,o,a,ff,oo,aa,fff,ooo,aaa)

            
            organizeFreeVariable(f,o,a,v)


            
            f,o,a,cm = getDummyFunction(f,o,a,cm)
            #f,o,a,cm = update__VERIFIER_nondet(f,o,a,cm)

            
            f,o,a,assert_list,assume_list,assert_key=getAssertAssume(f,o,a,cm)

            ff,oo,aa,assert_list_mom_two,assume_list_mom_two,assert_key_mom_two=getAssertAssume(ff,oo,aa,cm)

            fff,ooo,aaa,assert_list_mom_three,assume_list_mom_three,assert_key_mom_three=getAssertAssume(fff,ooo,aaa,cm)


            
            
            #assert_list=[]
            
            #assume_list=[]
            
            #assert_key=[]
            
            #assert_key_map={}
            
            
            f_map[fn]=f
            o_map[fn]=o
            a_map[fn]=a
            cm_map[fn]=cm
            
            assert_list_map[fn]=assert_list
            assume_list_map[fn]=assume_list
            assert_key_map[fn]=assert_key


            assert_list_map_mom_two[fn]=assert_list_mom_two
            assume_list_map_mom_two[fn]=assume_list_mom_two
            assert_key_map_mom_two[fn]=assert_key_mom_two


            assert_list_map_mom_three[fn]=assert_list_mom_three
            assume_list_map_mom_three[fn]=assume_list_mom_three
            assert_key_map_mom_three[fn]=assert_key_mom_three


            
            f,o,a=organizeOutput(f,o,a,v)
            
            
            f_map[fn]=f
            o_map[fn]=o
            a_map[fn]=a
            cm_map[fn]=cm
            
            ff_map[fn]=ff
            oo_map[fn]=oo
            aa_map[fn]=aa


            fff_map[fn]=fff
            ooo_map[fn]=ooo
            aaa_map[fn]=aaa


            display_map={}

            MOM_1_OUTPUT=''
            MOM_1_ASSERTION=''
            MOM_1_ASSUMPTION=''
            list_1_mom =[]

            MOM_2_OUTPUT=''
            MOM_2_ASSERTION=''
            MOM_2_ASSUMPTION=''
            list_2_mom =[]

            MOM_3_OUTPUT=''
            MOM_3_ASSERTION=''
            MOM_3_ASSUMPTION=''
            list_3_mom =[]

            MOM_1_OUTPUT+='\n Moment 1 :\n'
            MOM_1_OUTPUT+=output_axioms_fn_String(f,o,a)
            list_1_mom.append(MOM_1_OUTPUT)
            MOM_1_ASSUMPTION+='\n4. Assumption :\n'
            for x in assume_list:
                if x[0]=='i1':
                    MOM_1_ASSUMPTION+='ForAll '+x[2]+' ( '+ expr2string1(x[4])+' ) \n'
                else:
                    if x[0]!='i0':
                        MOM_1_ASSUMPTION+=wff2string1(x)+"\n"
            list_1_mom.append(MOM_1_ASSUMPTION)
            MOM_1_ASSERTION+='\n5. Assertion :\n'
            for x in assert_list:
                if x[0]=='i1':
                    MOM_1_ASSERTION+='ForAll '+x[2]+' ( '+ expr2string1(x[4])+' ) \n'
                else:
                	if x[0]!='i0':
                    		MOM_1_ASSERTION+=wff2string1(x)+'\n'

            list_1_mom.append(MOM_1_ASSERTION)

            display_map['1MOM']=list_1_mom


            MOM_2_OUTPUT+='\n Moment 2 :\n' 
            MOM_2_OUTPUT+=output_axioms_fn_String(ff,oo,aa)
            list_2_mom.append(MOM_2_OUTPUT)
            MOM_2_ASSUMPTION+='\n4. Assumption :\n'
            for x in assume_list_mom_two:
                if x[0]=='i1':
                    MOM_2_ASSUMPTION+='\nForAll '+x[2]+' ( '+ expr2string1(x[4])+' ) \n'
                else:
                    if x[0]!='i0':
                    		MOM_2_ASSUMPTION+='\n'+wff2string1(x)+'\n'
            list_2_mom.append(MOM_2_ASSUMPTION)
            MOM_2_ASSERTION+='\n5. Assertion :\n'
            for x in assert_list_mom_two:
                if x[0]=='i1':
                    MOM_2_ASSERTION+='\nForAll '+x[2]+' ( '+ expr2string1(x[4])+' ) \n'
                else:
                	if x[0]!='i0':
                    		MOM_2_ASSERTION+=wff2string1(x)+'\n'
            list_2_mom.append(MOM_2_ASSERTION)

            display_map['2MOM']=list_2_mom


            MOM_3_OUTPUT+='\n Moment 3 :\n' 
            MOM_3_OUTPUT+=output_axioms_fn_String(fff,ooo,aaa)
            list_3_mom.append(MOM_3_OUTPUT)
            MOM_3_ASSUMPTION+='\n Assumption :\n'
            for x in assume_list_mom_three:
                if x[0]=='i1':
                    MOM_3_ASSUMPTION+='ForAll '+x[2]+' ( '+ expr2string1(x[4])+' ) \n'
                else:
                    if x[0]!='i0':
                        MOM_3_ASSUMPTION+=wff2string1(x)+'\n'
            list_3_mom.append(MOM_3_ASSUMPTION)
            MOM_3_ASSERTION+='\n Assertion :\n'
            for x in assert_list_mom_three:
                if x[0]=='i1':
                    MOM_3_ASSERTION+='ForAll '+x[2]+' ( '+ expr2string1(x[4])+' ) \n'
                else:
                    if x[0]!='i0':
                        MOM_3_ASSERTION+=wff2string1(x)+"\n"
            list_3_mom.append(MOM_3_ASSERTION)

            display_map['3MOM']=list_3_mom

        return f_map,o_map,a_map,ff_map,oo_map,aa_map,fff_map,ooo_map,aaa_map,cm_map,assert_list_map,assume_list_map,assert_key_map, assert_list_map_mom_two, assume_list_map_mom_two, assert_key_map_mom_two, assert_list_map_mom_three, assume_list_map_mom_three, assert_key_map_mom_three,display_map
        
    elif p[1]=='fun':
        fn,f,o,a,l = translate0(p,v,flag)
        print('Output for ')
        print(fn)
        f,o,a,cm = rec_solver(f,o,a)
        f,o,a,cm = getDummyFunction(f,o,a,cm)
        f,o,a,assert_list,assume_list,assert_key=getAssertAssume(f,o,a,cm)
        f,o,a=organizeOutput(f,o,a,v)
        output_axioms_fn(f,o,a)
        print('\n4. Assumption :')
        for x in assume_list:
            if x[0]=='i1':
                print('ForAll '+x[2]+' ( '+ expr2string1(x[4])+' ) ')
            else:
                if x[0]!='i0':
                    print(wff2string1(x))
        print('\n5. Assertion :')
        for x in assert_list:
                if x[0]=='i1':
                    print('ForAll '+x[2]+' ( '+ expr2string1(x[4]) +' ) ')
                else:
                	if x[0]!='i0':
                    		print(wff2string1(x))
        return f,o,a,cm,assert_list,assume_list,assert_key
    else:
        f,o,a,l = translate0(p,v,flag)
        #Add by Pritom Rajkhowa 10 June 2016
        f,o,a,cm = rec_solver(f,o,a)
        f,o,a,cm = getDummyFunction(f,o,a,cm)
        f,o,a,assert_list,assume_list,assert_key=getAssertAssume(f,o,a,cm)
        f,o,a=organizeOutput(f,o,a,v)
        output_axioms_fn(f,o,a)
        print('\n4. Assumption :')
        for x in assume_list:
	         if x[0]=='i1':
	         	print('ForAll '+x[2]+' ( '+ expr2string1(x[4])+' ) ')
	         else:
	                if x[0]!='i0':
                    		print(wff2string1(x))
        print('\n5. Assertion :')
        for x in assert_list:
                if x[0]=='i1':
                    print('ForAll '+x[2]+' ( '+ expr2string1(x[4])+' ) ')
                else:
                	if x[0]!='i0':
                    		print(wff2string1(x))
    
        return f,o,a,cm,assert_list,assume_list,assert_key




def output_axioms_fn(f,o,a):
    #print('Output in prefix notation:')
    #print('1. Frame axioms:')
    #eqset2string(f)
    #print('\n2. Output equations:')
    #eqset2string(o)
    #print('\n3. Other axioms:')
    #for x in a: 
    #    print wff2string(x)
    print('\nOutput in normal notation:')
    print('1. Frame axioms:')
    eqset2string1(f)
    print('\n2. Output equations:')
    eqset2string1(o)
    print('\n3. Other axioms:')
    for x in a: 
        print(wff2string1(x))

def output_axioms_fn_String(f,o,a):
    #print('Output in prefix notation:')
    #print('1. Frame axioms:')
    #eqset2string(f)
    #print('\n2. Output equations:')
    #eqset2string(o)
    #print('\n3. Other axioms:')
    #for x in a: 
    #    print wff2string(x)
    OUT_PUT_RESULT=''
    OUT_PUT_RESULT+='\nOutput in normal notation:\n'
    OUT_PUT_RESULT+='1. Frame axioms:\n'
    OUT_PUT_RESULT+=eqset2string1String(f)
    OUT_PUT_RESULT+='\n2. Output equations:\n'
    OUT_PUT_RESULT+=eqset2string1String(o)
    OUT_PUT_RESULT+='\n3. Other axioms:\n'
    for x in a: 
        OUT_PUT_RESULT+=wff2string1(x)+"\n"
    return OUT_PUT_RESULT



def organizeOutput(f,o,a,vfacts):
    array_list=[]
    new_f={}
    duplicate_map={}
    new_f={}
    new_o={}
    new_a=[]
    for vfact in list(vfacts.keys()):
        info_list=vfacts[vfact]
        if type(info_list) is dict:
            for info in info_list:
                element_list=info_list[info]
                if type(element_list) is list:
                    if element_list[1]=='array' and '_PROVE' not in info and '_ASSUME' not in info and len(element_list)==2:
                        array_list.append(info)
        else:
            if info_list[1]=='array' and '_PROVE' not in vfact and '_ASSUME' not in vfact and len(element_list)==2:
                array_list.append(vfact)
    

    for e in f:
        if isArrayFunction(e)==True:
            if len(array_list)>0:
                new_f[e]=f[e]
        else:
            new_f[e]=f[e]
    for e in o:
        if isArrayFunction(e)==True:
            if len(array_list)>0:
                new_o[e]=o[e]
        else:
            new_o[e]=o[e]
    for e in a:
        if e[0]=='i1':
            if isArrayFunction(e[3][0])==True:
                if len(array_list)>0:
                    new_a.append(e)
            else:
                new_a.append(e)
        elif e[0]=='i0':
            if isArrayFunction(e[2][0])==True:
                if len(array_list)>0:
                    new_a.append(e)
            else:
                new_a.append(e)
        else:
            new_a.append(e)
    
    return new_f,new_o,new_a


def organizeFreeVariable(f,o,a,vfacts):
    struct_type_list=[]
    for vfact in list(vfacts.keys()):
        info_list=vfacts[vfact]
        for info in info_list:
            if info_list[info][1] not in ['int','short','unsigned','long','char','float','double','array']:
                struct_type_list.append(info)
    
    for x in o:
        e=o[x]
        if  e[0]=='e':
            if is_Stuct(e[-2][0],struct_type_list):
                e[-1] = expr_replace(e[-1],eval("['_x1']"),eval("['_s1']"))
                e[-2] = expr_replace(e[-2],eval("['_x1']"),eval("['_s1']"))
    
    for e in a:
        if e[0]=='i1' or e[0]=='i0':
            if is_Stuct(e[-2][0],struct_type_list):
                e[-1] = expr_replace(e[-1],eval("['_x1']"),eval("['_s1']"))
                e[-2] = expr_replace(e[-2],eval("['_x1']"),eval("['_s1']"))

            



def is_Stuct(var,struct_type_list):
    status=False
    for x in struct_type_list:
        temp=var.replace(x,'').strip()
        if is_number(temp)==True:
            status=True
    return status
        
        



# translate0(program,set of program variables) returns a dictionary of frame axioms, output equations, a list of other axioms and a label

def translate0(p,v,flag):
    if p[1]=='while':
        return translateWhile(p,v,flag)
    if p[1]=='seq':
        return translateSeq(p,v,flag)
    if p[1]=='if1':
        return translateIf1(p,v,flag)
    if p[1]=='if2':
        return translateIf2(p,v,flag)
    if p[1]=='=':
        return translateAssign(p,v,flag)
    if p[1]=='fun':
        return translateFun(p,v,flag)
    if p[1]=='prog':
        return translateProgram(p,v,flag)
     
     
# function definition
def translateFun(p,v,flag): #p=['-1','fun',['foo','x',..,'y'], b]
    #global TC
    #global LC
    #TC=0
    #LC=0
    f,o,a,l = translate0(p[-1],v,flag)
    axioms=a
    for x in f:
        axioms=axioms+[f[x]]
    for x in o:
        axioms=axioms+[o[x]]
    g = graph(axioms,v) #construct dependency graph
    param = list(expres(a) for a in p[-2][1:]) #parameters of the function
    dep_set = {} #dependency set for each variables in the axiom
    dep_set[RET+OUT]=expres(p[-2][0],param) #initialize it to the return function
    for (x,y) in g:
        if (not x in dep_set) and (not expres(x) in param):
            dep = []
            for x1 in reach_set([x],g):
                if (expres(x1) in param) and not (expres(x1) in dep):
                    dep.append(expres(x1))
            dep_set[x] = dep
    
    
    for x in f:
        f[x]=parameterize_wff_fun(f[x],dep_set)
    for x in o:
        o[x]=parameterize_wff_fun(o[x],dep_set)
    for i,ax in enumerate(a):
        a[i]=parameterize_wff_fun(ax,dep_set)
    return [dep_set[RET+OUT],f,o,a,l]
    
      
    
    
# program: a set of functions   
#p=['-1','prog',[f1,...,fk]] 
#for each fi, v[fi] is the list of variables used in the function fi
def translateProgram(p,v,flag): 
    result = {}
    for x in p[-1]:
        funcName = x[2][0]
        result[funcName] = translate0(x,v[funcName],flag)
    return result


# assignment translation: p a program and v a set of program variables

map___VERIFIER_nondet={}

def translateAssign(p,v,flag): #p=[l,'=',left,right]
    global map___VERIFIER_nondet
    if p[1] != '=':
        print('Not an assignment')
        return
    left = p[2] #left side of the assigment
    op = left[0] #the functor in left
    arity = len(left)-1 #arity of op
    right = p[3] #right side of the assignment
    right = update__VERIFIER_nondet_stmt(right,map___VERIFIER_nondet)
    out=OUT if p[0] == '-1' else LABEL+p[0]
    out_axioms = {}
    frame_axioms = {}
    for x in v:
        if x == op:
            args = list(expres('_x'+str(i+1)) for i in range(arity))
            cond = expres('=',[expres('_x1'),left[1]]) if arity==1 else \
                   expres('and', list(expres('=', [expres('_x'+str(i2+1)),y]) for \
                                    i2,y in zip(range(arity),left[1:])))
            if arity == 0:
                out_axioms[x]=wff_e(expres(op+out),right)
            else:
                out_axioms[x]=wff_e(expres(op+out,args), expres('ite',[cond,right,expres(op,args)]))
        else:
            args = list(expres('_x'+str(i+1)) for i in range(len(v[x])-2))
            frame_axioms[x]=wff_e(expres(x+out,args), expres(x,args))
    return frame_axioms, out_axioms, [], p[0]
    
    
    

def translateIf1(p,v,flag): # p=[l,'if1',c,e]
    global map___VERIFIER_nondet
    if p[1] != 'if1':
        print('Not an if-then')
        return
    global TC
    frame_axioms,out_axioms,axioms,llabel = translate0(p[3],v,flag)
    old_out = OUT if llabel=='-1' else LABEL+llabel
    out=OUT if p[0] == '-1' else LABEL+p[0]
    if llabel=='-1': # body has no final label
        TC += 1
    body_out = TEMP+str(TC) if llabel=='-1' else LABEL+llabel
    
    p[2] = update__VERIFIER_nondet_stmt(p[2],map___VERIFIER_nondet)
    
    for x in v:
        if x in frame_axioms: 
            ax = frame_axioms[x] #ax = ['e',e1,e2]
            if llabel != '-1': #body has label: keep axioms about it
                axioms.append(ax)
            #generate the new frame axiom
            frame_axioms[x] = wff_e(expr_sub(ax[1],x+old_out,x+out), ax[2])
        else:
            ax = out_axioms[x] #ax = ['e',e1,e2]
            if llabel != '-1': #body has label: keep axioms about it
                axioms.append(ax)
            out_axioms[x] = wff_e(expres(x+out, ax[1][1:]),
                                  expres('ite', [p[2], ax[2], expres(x,ax[1][1:])]))
    return frame_axioms, out_axioms, axioms, p[0]
    
            
def translateIf2(p,v,flag): # p=[l,'if2',c,e1,e2]
    global map___VERIFIER_nondet
    if p[1] != 'if2':
        print('Not an if-then-else')
        return
    global TC
    frame_axioms0,out_axioms0,axioms0,llabel0 = translate0(p[3],v,flag)
    frame_axioms1,out_axioms1,axioms1,llabel1 = translate0(p[4],v,flag)
    axioms = axioms0+axioms1
    old_out0 = OUT if llabel0=='-1' else LABEL+llabel0
    old_out1 = OUT if llabel1=='-1' else LABEL+llabel1
    out=OUT if p[0] == '-1' else LABEL+p[0]
    if llabel0=='-1': # if body has no final label
        TC += 1
    body_out0 = TEMP+str(TC) if llabel0=='-1' else LABEL+llabel0 # if body new out
    if llabel1=='-1': # else body has no final label
        TC += 1
    body_out1 = TEMP+str(TC) if llabel1=='-1' else LABEL+llabel1 # else body new out
    frame_axioms = {}
    out_axioms = {}
    
    p[2] = update__VERIFIER_nondet_stmt(p[2],map___VERIFIER_nondet)
    
    for x in v:
        if x in frame_axioms0 and x in frame_axioms1: 
            ax0 = frame_axioms0[x] #ax0 = ['e',e1,e2]
            ax1 = frame_axioms1[x] #ax1 = ['e',e1,e2]
            if llabel0 != '-1': #if body has label: keep axioms about it
                axioms.append(ax0)
            if llabel1 != '-1': #else body has label: keep axioms about it
                axioms.append(ax1)
            #generate the new frame axiom
            frame_axioms[x] = wff_e(expr_sub(ax0[1],x+old_out0,x+out), ax0[2])
        else:
            if x in frame_axioms0:
                ax0=frame_axioms0[x]
            else:
                ax0=out_axioms0[x]
            if x in frame_axioms1:
                ax1=frame_axioms1[x]
            else:
                ax1=out_axioms1[x]
            if llabel0 != '-1': #if body has label: keep axioms about it
                axioms.append(ax0)
            if llabel1 != '-1': #else body has label: keep axioms about it
                axioms.append(ax1)
            out_axioms[x] = wff_e(expres(x+out, ax0[1][1:]),
                                  expres('ite', [p[2], ax0[2], ax1[2]]))
    return frame_axioms, out_axioms, axioms, p[0]
    
            
def translateSeq(p,v,flag): # p=['-1','seq',p1,p2]
    if p[1] != 'seq':
        print('Not a sequence')
        return
    global TC
    frame_axioms0,out_axioms0,axioms0,llabel0 = translate0(p[2],v,flag)
    frame_axioms1,out_axioms1,axioms1,llabel1 = translate0(p[3],v,flag)
    old_out0 = OUT if llabel0=='-1' else LABEL+llabel0
    if llabel0=='-1': # if p1 has no final label
        TC += 1
    new_out0 = TEMP+str(TC) if llabel0=='-1' else LABEL+llabel0 # p1 new out
    frame_axioms = {}
    out_axioms = {}
    para = {} #a dictonary of substitution: para[x] is the expression to replace x(t) in p2's axioms
    for x in v:
        if x in frame_axioms0 and x in frame_axioms1:
            if llabel0 !='-1': #p1 has label, keep its axioms
                axioms0.append(frame_axioms0[x])
            frame_axioms[x]=frame_axioms1[x]
        else:
            if x in frame_axioms0:
                ax0=frame_axioms0[x] #ax0=['e',e1,e2]
            else:
                ax0=out_axioms0[x]
            if llabel0 != '-1': #p1 has label: keep equations about it
                axioms0.append(ax0)
            para[x]=ax0[2]
    for i,ax in enumerate(axioms1): #substituting p1's output into p2's input in p2's axioms
        axioms1[i] = wff_sub_dict(ax,para)
    for x in v: #do the same for the p2's output equations and frame axioms
        if not x in frame_axioms:
            if x in frame_axioms1:
                out_axioms[x] = frame_axioms1[x][:2]+[expr_sub_dict(frame_axioms1[x][2],para)]
            else:
                out_axioms[x] = out_axioms1[x][:2]+[expr_sub_dict(out_axioms1[x][2],para)]
    
    return frame_axioms, out_axioms, axioms0+axioms1, llabel1
    


def translateWhile(p,v,flag): #p=[l, 'while', c, b]
    global map___VERIFIER_nondet
    if p[1] != 'while':
        print('Not a while statement')
        return
    global LC
    global TC
    frame_axioms, out_axioms0, axioms,llabel = translate0(p[3],v,flag) # axioms and output labels for the body of the loop
    LC += 1
    if llabel=='-1': # if body has no final label
        TC += 1
    loop_var = expres('_n'+str(LC)) #a new natural number variable for the loop
    smallest = expres('_N'+str(LC)) #a new natural number variable for the loop
    init=TEMP+str(TC) if llabel=='-1' else LABEL+llabel #iterating functions
    old_out=OUT if llabel=='-1' else LABEL+llabel #original output functions in body
    out=OUT if p[0]=='-1' else LABEL+p[0] #new output functions for the loop
    for i0, ax0 in enumerate(axioms): #extend the axioms with [n]
        ax0 = wff_sub_set(ax0,'',init,v,frame_axioms)
        axioms[i0]=wff_extend(ax0, loop_var, frame_axioms,v)
    for x in frame_axioms:
        ax = frame_axioms[x] #ax = ['e',e1,e2]
        if llabel != '-1': #body has label: keep axioms about it
            axioms.append(ax)
        #generate the new frame axiom
        frame_axioms[x] = wff_e(expr_sub(ax[1],x+old_out,x+out), ax[2])
    out_axioms00={}
    for x in out_axioms0: 
        ax = out_axioms0[x] #ax = ['e',e1,e2]
        #change output and input variable names to loop and extend e2[loop_var]
        ax = wff_sub_set(ax,old_out,init,v,frame_axioms)
        ax = wff_sub_set(ax,'',init,v,frame_axioms)
        out_axioms00[x]=ax[:2]+[extend(ax[2],loop_var,frame_axioms,v)]
    # using Pritom's solve_rec() to try to get closed-form solution
    found_solution=True
    variable=None
    temp_out_axioms00 = copy.deepcopy(out_axioms00)
    while found_solution:
        found1=False
        for x in list(temp_out_axioms00.keys()):
            if x in list(out_axioms00.keys()):
                ax=out_axioms00[x]
                if expr_func(ax[2],v)==[]:
                    found1=True
                    e=extend(ax[1],loop_var,frame_axioms,v)
                    axioms.append(wff_e(e,ax[2]))
                    del out_axioms00[x]
                    for y in out_axioms00:
                        ax1= out_axioms00[y]
                        out_axioms00[y]=ax1[:2]+[expr_sub_dict(ax1[2],{expr_op(ax[1]):ax[2]})]
                else:
                    e1=wff_i1(0,expr_op(loop_var),extend(ax[1],expres('+',[loop_var,['1']]),frame_axioms,v),ax[2])
                    e2=wff_i0(0,extend(ax[1],expres('0'),frame_axioms,v),expres(x,expr_args(ax[1])))
                    res=solve_rec(e1,e2)
                    if res != None: #res = ['i2',k,n,e1,e2]
                        found1=True
                        variable=res[2] # Variable add by Pritom Rajkhowa
                        axioms.append(wff_e(res[3],res[4]))
                        del out_axioms00[x]
                        for y in out_axioms00:
                            ax1= out_axioms00[y]
                            out_axioms00[y]=ax1[:2]+[expr_sub_dict(ax1[2],{expr_op(res[3]):res[4]})]
        if not found1:
            found_solution=False
    for x in out_axioms00:
        ax = out_axioms00[x] #ax = ['e',e1,e2]
        e1=extend(ax[1],expres('+',[loop_var,['1']]),frame_axioms,v)
        e2=ax[2]
        axioms.append(wff_i1(len(expr_args(e1))-1,expr_op(loop_var),e1,e2))
    
    #base case
    for x in out_axioms00:
        arity = len(v[x])-2
        args = list(expres('_x'+str(i+1)) for i in range(arity))
        axioms.append(wff_i0(arity,expres(x+init,args+[expres('0')]), expres(x,args)))
    c=p[2] #loop condition
    c = update__VERIFIER_nondet_stmt(c,map___VERIFIER_nondet)
    c=expr_sub_set(c,'',init,v,frame_axioms)
    c = extend(c,loop_var,frame_axioms,v) #add the smallest macro
     #Add by pritom
    cc = copy.deepcopy(c)
    axioms.append(wff_s0(expr_sub(expr_complement(cc),expr_op(loop_var),expr_op(smallest))))  
    #axioms.append(wff_s0(expres('not',[expr_sub(c,expr_op(loop_var),expr_op(smallest))])))
    axioms.append(wff_s1(expres('implies',
                             [expres('<', [loop_var, smallest]),c])))
    out_axioms = {}
    for x in v: # generate out_axioms
        if not x in frame_axioms:
            args = list(expres('_x'+str(i+1)) for i in range(len(v[x])-2))
            e1=expres(x+out,args)
            args.append(smallest)
            e2=expres(x+init,args)
            out_axioms[x]=wff_e(e1,e2)
    #substitution of closed form solution by pritom rajkhowa
    constant='_N'+str(LC)
    variable='_n'+str(LC)
    update_axioms=[]
    equations=[]

    for ax in axioms:
    	if ax[0]=='e':
    		equations.append(ax)
    	else:
    		update_axioms.append(ax)
    
    for equation in equations:
    	equation1=copy.deepcopy(equation)
    	update_axioms=solnsubstitution(update_axioms,equation[1],equation[2])
    	equation1[1]=expr_replace_const(equation1[1],variable,constant)
    	equation1[2]=expr_replace_const(equation1[2],variable,constant)
    	update_axioms=solnsubstitution(update_axioms,equation1[1],equation1[2])
    	for x in out_axioms:
            stmt=out_axioms[x]
            stmt[2]=expr_replace(stmt[2],equation1[1],equation1[2])
    axioms=update_axioms
    updated_axioms=[]
    for ax in axioms:
    	if ax[0]=='s0':
            expression=expr2string1(ax[1])
            if '->' not in expression and constant in expression:
                   if '>=' in expression and 'and' not in expression and 'or' not in expression:
                                if '**' not in expression:
                                    expression=normal_form_constant(expression, constant) 
                                    #pp = getParser()
                                    #tree = pp.parse_expression(str(expression))
                                    if '**' not in str(expression):
                                        parser = c_parser.CParser()
                                        ast = parser.parse("void test(){"+str(expression)+";}")
                                        statement_temp=ast.ext[0].body.block_items[0]
                                        axupdate = construct_expression_normalC(eval(expressionCreator_C(statement_temp)))
                                        #axupdate=construct_expression_normal(tree)
                                        if axupdate is not None:
                                                updated_axioms.append(axupdate)
                                        else:
                                                updated_axioms.append(ax)
                                    else:
                                        updated_axioms.append(ax)
                                else:
                                    updated_axioms.append(ax)
                   elif '<=' in expression and 'and' not in expression and 'or' not in expression:
                                if '**' not in expression:
                                    expression=normal_form_constant(expression, constant)
                                    #pp = getParser()
                                    if '**' not in str(expression):
                                        parser = c_parser.CParser()
                                        ast = parser.parse("void test(){"+str(expression)+";}")
                                        statement_temp=ast.ext[0].body.block_items[0]
                                        #tree = pp.parse_expression(str(expression))		 
                                        #axupdate=construct_expression_normal(tree)
                                        axupdate = construct_expression_normalC(eval(expressionCreator_C(statement_temp)))
                                        if axupdate is not None:
                                                updated_axioms.append(axupdate)
                                        else:
                                                updated_axioms.append(ax)
                                    else:
                                        updated_axioms.append(ax)
                                else:
                                    updated_axioms.append(ax)
                   else:
                                updated_axioms.append(ax)
            else:
                    updated_axioms.append(ax)
    	else:
     	        updated_axioms.append(ax)
    axioms=[]
    for ax in updated_axioms:
    	axioms.append(ax)

    #substitution of closed form solution by pritom rajkhowa  
    if flag==2:
        g = graph(axioms,v) #construct dependency graph
        for x in expr_func(p[2],v):
            if not ['_N'+str(LC), x] in g:
                g.append(['_N'+str(LC), x])
                g.append(['_N'+str(LC), x+init])
        for x in out_axioms00:
            if not [x+init,x] in g:
                g.append([x+init,x])
            if not [x,x+init] in g:
                g.append([x,x+init])
            for y in expr_func(out_axioms00[x][2],v):
                if not [x,y] in g:
                    g.append([x,y])
        #build a dictionary para = { 'X':[1,['_y1']], 'X11':[0,['_y1','_y2'],['X','Y'],...} 
        #meaning 'X' is an input variable parameterized as '_y1' and 
        #'X11' is a function taking two new parameters '_y1' and '_y2' which correspond 
        # to 'X' and 'Y', respectively
        para={} 
        for [x,x1] in g: #compute the dependency sets
            if x in v and not x in frame_axioms:
                para[x] = [1,[v[x][0]]]
            else:
                if not x in para and not x in frame_axioms:
                    t=[]
                    t1=[]
                    for y in reach_set([x],g):
                        if y in v and (not expres(y) in t1) and (not y in frame_axioms):
                            t.append(expres(v[y][0]))
                            t1.append(expres(y))
                    if t != []:
                        para[x] = [0,t,t1]
        #parameterize input variables that N depends on and all associated functions
        for i,ax in enumerate(axioms):
            axioms[i] = parameterize_wff(ax,para)
        #construct inductive definition for N
        s_args = para['_N'+str(LC)][1]
        smallest1=expres('_N'+str(LC), s_args)
        next_args=[]
        for i,y in enumerate(s_args):
            x=expr_op(para['_N'+str(LC)][2][i])
            next_args.append(parameterize_expres(out_axioms0[x][2],para))
        axioms.append(['d0',smallest1, parameterize_expres(expres('not',[p[2]]),para)])
        axioms.append(['d1','_n'+str(LC), smallest1, 
                       expres('=',[loop_var,expres('_N'+str(LC),next_args)])])
        #parameterize output axioms
        for x in out_axioms:
            out_axioms[x]=out_axioms[x][:2]+[parameterize_expr_sub(out_axioms[x][2],para)]
        new_axioms = [] #for creating new inductive definitions
        for ax in axioms:
            if ax[0]=='i1':
                x=expr_op(ax[3])
                if x.endswith(init) and x[:len(x)-len(init)] in v:
                    next_args=[]
                    for k,arg in enumerate(expr_args(ax[3])):
                        if k==ax[1]:
                            next_args.append(expres(ax[2]))
                        else:
                            a=expr_op(arg)
                            if a.startswith('_y'):
                                for b in v:
                                    if v[b][0]==a:
                                        next_args.append(parameterize_expres(out_axioms0[b][2],para))
                            else:
                                next_args.append(arg)
                    new_axioms.append(ax[0:4]+[expres(x,next_args)])
        axioms=axioms+new_axioms
    return frame_axioms, out_axioms, axioms, p[0]






#construct a graph of dependency relation in a set of equations axioms 
def graph(axioms,v):
    ret = []
    for ax in axioms:
        if ax[0]=='e' or ax[0]=='i0' or ax[0]=='i1' or ax[0]=='d0' or ax[0]=='d1':
            op=expr_op(ax[-2])
            for x in expr_func(ax[-1],v):
                if not [op,x] in ret:
                    ret.append([op,x])
        elif ax[0]=='s1':
            op=expr_op(expr_args(expr_args(ax[1])[0])[1])
            for x in expr_func(expr_args(ax[1])[1],v):
                if not [op,x] in ret:
                    ret.append([op,x])
    return ret

#given a list s of nodes, return the list of nodes that are reachable from the nodes in s
def reach_set(s,g):
    s1=[]
    for [n1,n2] in g:
        if (n1 in s) and not (n2 in s):
            s1.append(n2)
    if s1==[]:
        return s
    else:
        return reach_set(s+s1,g)

                            
# testing examples. 
x=expres('x')
y=expres('y')
ex1 = ['-1','=',x, expres('+',[y,['1']])] #x=y+1
ex2 = ['-1','=',y, ['+',y,['1']]] #y=y+1
ex21 = ['1','=',y, ['+',y,['1']]] #1: y=y+1
ex22 = ['-1','if1',['>', y,['1']],ex2] # if y>1 then y=y+1
ex23 = ['-1','if1',['>', y,['1']],ex21] # if y>1 then l: y=y+1
ex24 = ['-1','if2',['>', y,['1']],ex21,ex1] # if y>1 then l: y=y+1 else x=y+1
ex3 = ['-1','seq',ex1,ex2]  #x=y+1; y=y+1
v1 = {'x':['_y1','int'], 'y':['_y2','int']}
ex4 = ['-1', '=', ['t',x], ['+', ['+', ['z', x, ['t', x]], ['1']], x]]
ex42 = ['-1', '=', ['z',x,y], ['+', ['+', ['z', x, ['t', x]], ['1']], x]]
v2 = {'x':['_y1','int'], 'y':['_y2','int'], 't':['_y3','int','int'], 'z':['_y4','int','int','int']}
ex41 = ['-1','if1',['>', y,['1']],ex4] # if y>1 then ex4

ex25 = ['-1','if2',['>', y,['1']],ex1,ex4] 

ex5 = ['-1','if2',expres('and', [expres('=', [expres('x'),expres('t',[expres('1')])]), expres('<', [expres('y'), expres('z',[expres('x'),expres('y')])])]), ex1, ex4]

ex6 = ['-1','while',expres('<',[expres('x'),expres('y')]),ex4]

#translate1(ex3,v1,1)
#translate1(ex4,v2,1)
#translate1(ex5,v2,1)

# factorial function
"""
i=1;
F=1;
while(i <= X) {
 F=F*i;
 i=i+1;
}
"""
i=expres('i')
F=expres('F')
X=expres('X')
fact0 = ['-1','seq',['-1','=',i,['1']],['-1','=',F,['1']]]
fact1 = ['-1','seq',['-1','=',F,['*',F,i]],['-1','=',i,['+',i,['1']]]]
fact2 = ['-1','while', ['<=',i,X], fact1]
fact = ['-1','seq',fact0,fact2]
vfact = {'i':['_y1','int'], 'X':['_y2','int'], 'F':['_y3','int'],RET:['_y0','int']}
#translate1(fact,vfact)

#factorial as a function: return F
fact3 = ['-1','=',expres(RET),F]
funfact = ['-1','fun',['factorial', 'X'],['-1','seq',fact,fact3]]
#a main() that uses factorial
# main1() { X=factorial(2) }
main1 = ['-1','fun',['main1'],['-1','=',X,expres('factorial',[expres('2')])]]
# variable list for main1()
man1v = {'X':['_y1','int']}
# variable lists for main1p, one for each function
main1pv = {'main1':man1v,'factorial':vfact}
main1p = ['-1','prog',[funfact,main1]]
# translate1(main1p, main1pv,1)

# in-place list reversing - see Lin and Yang 2015
"""
J = null;
while I != null do {
    K = next(I);
    next(I) = J;
    J=I;
    I=K;
}
I=J;
"""

lr6 = ['-1','=',['I'],['K']]
lr5 = ['-1','seq',['-1','=',['J'],['I']], lr6]
lr4 = ['-1','seq',['-1','=', ['next', ['I']],['J']], lr5]
lr3 = ['-1','seq',['-1','=',['K'],['next',['I']]], lr4]
lr2 = ['-1','while',['!=', ['I'], ['null']], lr3]
lr1 = ['-1','seq',lr2,['-1','=',['I'],['J']]]
lr = ['-1','seq',['-1','=',['J'],['null']], lr1]
vlr = {'J':['_y1','list'],'I':['_y2','list'],'K':['_y3','list'],'next':['_y4','list','list']}

#Cohen's division algorithm
"""
//XandYaretwoinputintegers;Y>0 
Q=0; // quotient
R=X; // remainder
while (R >= Y) do {
    A=1; // A and B are some that at any time for
    B=Y; // some n, A=2^n and B=2^n*Y
    while (R >= 2*B) do {
       A = 2*A;
       B = 2*B; }
    R = R-B;
    Q = Q+A }
//
return Q = X/Y;
"""

A=expres('A')
B=expres('B')
R=expres('R')
Q=expres('Q')
Y=expres('Y')
A2=expres('*',[expres('2'),A]) #2*A
B2=expres('*',[expres('2'),B]) #2*B
RB=expres('-',[R,B]) #R-B
QA=expres('+',[Q,A]) #Q+A
c1=expres('>=',[R,B2]) #R>=2*B
c2=expres('>=',[R,Y]) #R >= Y

cohen9=['-1','seq',['-1','=',A,A2],['-1','=',B,B2]]
cohen8=['-1','seq',['-1','=',R,RB],['-1','=',Q,QA]]
cohen7=['-1','while',c1, cohen9]
cohen6=['-1','seq',cohen7,cohen8]
cohen1=['-1','=',Q,['0']]
cohen5=['-1','seq',['-1','=',B,Y],cohen6]
cohen4=['-1','seq',['-1','=',A,['1']],cohen5]
cohen3=['-1','while',c2, cohen4]
cohen2=['-1','seq',['-1','=',R,X],cohen3]
cohen = ['-1', 'seq', cohen1,cohen2]
vcohen={'X':['_y1','int'],'Y':['_y2','int'],'Q':['_y3','int'],'R':['_y4','int'],'A':['_y5','int'],'B':['_y6','int']}

#product of two integers
"""
Z = 0;
while( Y!=0 ) {
 if ( Y % 2 ==1 ) {
     Z = Z+X;
     Y =(Y-1);
  }
  X = 2*X;
  Y = Y/2;
}
"""
Z=expres('Z')
prod1=['-1','seq',['-1','=',Z,expres('+',[Z,X])],['-1','=',Y,expres('-',[Y,['1']])]]
prod2=['-1','seq',['-1','=',X,expres('*',[['2'],X])],['-1','=',Y,expres('/',[Y,['2']])]]
prod3=['-1', 'if1', expres('=',[expres('%',[Y,['2']]), ['1']]), prod1]
prod4=['-1','seq',prod3,prod2]
prod5=['-1','while',expres('!=',[Y,['0']]),prod4]
prod = ['-1','seq',['-1','=',Z,['0']],prod5]
vprod = {'X':['_y1','int'],'Y':['_y2','int'],'Z':['_y3','int']}

#array sum array represented as a reference, and element represented by at predicate
"""
i=0;
sum=0;
while (i<size(A)) {
 sum=at(A,i)+sum
 i=i+1
}
"""
sum3=['-1','while',expres('<',[i,expres('size',[A])]),['-1','seq',['-1','=',['sum'],expres('+',[expres('at',[A,i]),['sum']])],['-1','=',i,expres('+',[i,['1']])]]]
sum2=['-1','seq',['-1','=',['sum'],['0']],sum3]
sum1=['-1','seq',['-1','=',i,['0']],sum2]
vsum = {'i':['_y1','int'],'sum':['_y2','int'],'size':['_y3','array','int'],'A':['_y4','array'],'at':['_y5','array','int','int']}

#Dijkstra's LCM algorithm
"""
X=A;  Y=B;  U=B;  V=A;
while (X!=Y) { 
  if (X>Y) {X=X-Y; V=V+U;} 
      else {Y=Y-X; U=U+V;}
}
"""

A=expres('A')
B=expres('B')
X=expres('X')
V=expres('V')
U=expres('U')
XY=expres('-',[X,Y])
YX=expres('-',[Y,X])
UV=expres('+',[U,V])
lcm1=['-1','seq',['-1','=',X,A],['-1','=',Y,B]]
lcm2=['-1','seq',lcm1,['-1','=',U,B]]
lcm3=['-1','seq',lcm2,['-1','=',V,A]]
lcm4=['-1','seq',['-1','=',X,XY],['-1','=',V,UV]]
lcm5=['-1','seq',['-1','=',Y,YX],['-1','=',U,UV]]
c1=expres('>',[X,Y])
lcm6=['-1', 'if2', c1, lcm4,lcm5]
c2=expres('!=',[X,Y])
lcm7=['-1','while',c2,lcm6]
lcm = ['-1','seq',lcm3,lcm7]
vlcm={'A':['_y1','int'],'B':['_y2','int'],'X':['_y3','int'],'Y':['_y4','int'],'U':['_y5','int'],'V':['_y6','int']}

"""
matrix multiplication from verifythis-2016 competition

int[][] matrixMultiply(int[][] A, int[][] B) {
	int n = A.length;

	// initialise C
	int[][] C = new int[n][n];

	for (int i = 0; i < n; i++) {
   		for (int k = 0; k < n; k++) {
       			for (int j = 0; j < n; j++) {
           			C[i][j] += A[i][k] * B[k][j];
       			}
   		}
	}
	return C;
 }
"""
def less(x,y):
    return expres('<',[x,y])
def passign(l,le,ri):
    return [l,'=',le,ri]
def initialize_array2(x,i,j,m,n):
    a=passign('-1',expres('d2array',[x,i,j]),expres('0')) #d2array(x,i,j)=0
    a1=passign('-1',i,expres('+',[i,expres('1')])) #i++
    a2=passign('-1',j,expres('+',[j,expres('1')])) #j++
    while1 = ['-1','while', less(j,n), ['-1','seq',a,a2]]
    body1 = ['-1','seq',while1,a1]
    body2 = ['-1','seq',passign('-1',j,expres('0')),body1]
    while2 = ['-1','while', less(i,m), body2]
    return ['-1','seq',passign('-1',i,expres('0')),while2]

mM1 = ['-1','seq',passign('-1',expres('n'),expres('length',[expres('a')])),
       initialize_array2(expres('c'),expres('i'),expres('j'),expres('n'),expres('n'))]
mM = ['-1','seq',mM1,passign('-1',expres(RET),expres('c'))]
# for now matrixMuliply only initializes C
matrixMultipy = ['-1','fun', ['matrixMultiply','a','b'],mM]
mMv = {'a':['_y1','array'],'b':['_y2','array'],'c':['_y3','array'],RET:['_y0','array'],'i':['_y4','int'],'j':['_y5','int'],'k':['_y6','int'],'n':['_y7','int'],'d2array':['_y7','array','int','int','int']}

# translate1(matrixMultipy,mMv,1)

"""

#Add by Pritom 

"""


#Function Get list of parameters 

def find_between( s, first, last ):
    try:
        start = s.index( first ) + len( first )
        end = s.index( last, start )
        return s[start:end]
    except ValueError:
        return ""
        
#Get the parameter 

def getParameter( parameterlist ):
    try:
        parameters=parameterlist.split(',')
        for index, parameter  in enumerate(parameters):
            if '+1' in parameter:
                return parameter.replace("\n","").strip()
    except ValueError:
        	return ""





"""
Function to Take care of the parentheses During 

#substitutor='(X2(_N1(B,A),A,B)'
#left=None
#right=None

"""
def parenthesesOrganizer( substitutor ,left ,right):
	if left is None:
		left=""
	if right is None:
		right=""
	if substitutor[0]=="(":
		left=left+"("
		substitutor=substitutor[1:len(substitutor)]
		if substitutor[len(substitutor)-1]==")":
			right=right+")"
			substitutor=substitutor[0:len(substitutor)-1]
			leftin=None
			rightin=None
			leftin,rightin,substitutor_update=parenthesesOrganizer(substitutor,leftin ,rightin)
			if leftin is not None and rightin is not None:
				substitutor=leftin+substitutor_update+rightin
		else:
			substitutor="("+substitutor
			left=left[0:len(left)-1]
	return left,right,substitutor


"""

#Get Function Name 
#This can be done using Regular expression ...Need to update
"""
def getFunctionName(function,parameters ):
	for parameter in parameters:
		function=function.replace(parameter,"")
	blanklist=find_between( function,'(',')')
	function=function.replace("("+str(blanklist)+")","")
	return function


"""

axiomes to Z3 statements

"""


"""
#Test Case 1
#variable="n1"

#Test Case 2
#variable="_n1"

"""


def isConstant( variable ):
	status=False
	find=regex.compile(r'[_]N\d')
	group = find.search(variable)
	if group is not None:
		status=True
	return status


#fun_name="ackermann_2"

#fun_list=['ackermann']

def isRecurrenceFun( fun_name, fun_list ):
    status=False
    for fun in fun_list:
        if fun_name.startswith(fun+'_')==True:
            digit=fun_name.replace(fun+'_', '')
            if is_number(digit)==True:
                return fun
    return None




"""
#Test Case 1
#variable="n1"

#Test Case 2
#variable="_n1"

"""


def isLoopvariable( variable ):
	status=False
	find=regex.compile(r'[_]n\d')
	group = find.search(variable)
	if group is not None:
		status=True
	return status


"""
#Test Case 1
#variable="C1"

#Test Case 2
#variable="C0"

"""


def isConstInResult( variable ):
	status=False
	find=regex.compile(r'C\d')
	group = find.search(variable)
	if group is not None:
		status=True
	return status


#Test Case 1
#variable="d1array4"

#Test Case 2
#variable="d1ar4"	
	
def isArrayFunction( variable ):
	status=False
	find=regex.compile(r'([d]\d[a][r][r][a][y]\d|[d]\d[a][r][r][a][y])')
	group = find.search(variable)
	if group is not None:
		status=True
	return status


#Is Boolean Variable

#Test Case 1
#variable="bool_go_error1"

#Test Case 2
#variable="bool_go_error2"	
	
def isBoolVariable( variable ):
	status=False
	find=regex.compile(r'([b][o][o][l][_][g][o][_])')
	group = find.search(variable)
	if group is not None:
		status=True
	return status




#expression='n+1'

def replaceAddOperator(expression):
	p = regex.compile(r'[A-Za-z|\d|\)|\]][+][A-Za-z|\d|\(|\]]')
	result=(p.sub(lambda m: m.group().replace("+", " + "), expression))
	result=replaceAddOperator1(result)
	return result

def replaceAddOperator1(expression):
	p = regex.compile(r'[A-Za-z|\d|\s][+][A-Za-z|\d]')
	result=(p.sub(lambda m: m.group().replace("+", "+ "), expression))
	return result
	



#Is Varible is Substitution Variable
# variable = 'f1_1_i'
def isSubsVar( variable ):
	status=False
	find=regex.compile(r'f\d[_]\d')
	group = find.search(variable)
	if group is not None:
		status=True
	return status



"""
#Extract arguments from smallest function

#Example 1: expr="smallest(n,_N1,su(n)>X(n))"
#extract_args(expr):

"""
def extract_args(expr):
    paren = 0
    start = 0
    ret = []
    for i, c in enumerate(expr):
        if c=='(':
            paren+=1
            if paren==1:
                start=i+1
        elif c==')':
            if paren==1 and start:
                ret.append(expr[start: i]) 
            paren-=1
        elif c==',' and paren==1:
            ret.append(expr[start:i])
            start=i+1
    return ret


# expr_replace(e,e1,e2): replace all subterm e1 in e by e2

#e=['a', ['implies', ['<', ['_n1'], ['_N1']], ['<', ['x2', ['_n1']], ['y2', ['_n1']]]]]

#e=['a', ['<', ['x2', ['_N1']], ['y2', ['_N1']]]]

def expr_complement(e): #e,e1,e2: expres
    if e[:1]==['<']:
    	e[:1]=['>=']
    	return e[:1]+list(expr_complement(x) for x in expr_args(e))
    elif e[:1]==['>']:
    	e[:1]=['<=']
    	return e[:1]+list(expr_complement(x) for x in expr_args(e))
    elif e[:1]==['>=']:
        e[:1]=['<']
        return e[:1]+list(expr_complement(x) for x in expr_args(e))
    elif e[:1]==['<=']:
        e[:1]=['>']
        return e[:1]+list(expr_complement(x) for x in expr_args(e))
    elif e[:1]==['==']:
        e[:1]=['!=']
        return e[:1]+list(expr_complement(x) for x in expr_args(e))
    elif e[:1]==['!=']:
        e[:1]=['==']
        return e[:1]+list(expr_complement(x) for x in expr_args(e))
    elif e[:1]==['&&']:
        e[:1]=['||']
        return e[:1]+list(expr_complement(x) for x in expr_args(e))
    elif e[:1]==['||']:
        e[:1]=['&&']
        return e[:1]+list(expr_complement(x) for x in expr_args(e))
    elif e[:1]==['and']:
        e[:1]=['or']
        return e[:1]+list(expr_complement(x) for x in expr_args(e))
    elif e[:1]==['or']:
        e[:1]=['and']
        return e[:1]+list(expr_complement(x) for x in expr_args(e))
    else:
        return e[:1]+list(expr_complement(x) for x in expr_args(e))



""" 
#Function to replace variable by constant
#Test Case
#e=['a', ['<', ['x2', ['_n1']], ['y2', ['_n1']]]]
#variable='_n1'
#constant='_N1'
#expr_replace_const(e,variable,constant)
"""

def expr_replace_const(e,variable,constant):
	if e[:1]==expres(variable):
		e[:1]=expres(constant)
	return e[:1]+list(expr_replace_const(x,variable,constant) for x in expr_args(e))


def get_All_Var(e,var_map):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
    	if is_number(op)==False and is_hex(op)==None and op not in _base:
        	var_map.append(op)
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                get_All_Var(args[0],var_map)
            else:
            	for x in args:
            		get_All_Var(x,var_map)
        elif op=='not' and len(args)==1:
            get_All_Var(args[0],var_map)
        elif op=='implies' and len(args)==2:
            get_All_Var(args[0],var_map)
            get_All_Var(args[1],var_map)
        elif op in _infix_op and len(args)==2:
            get_All_Var(args[0],var_map)
            get_All_Var(args[1],var_map)
        else:
        	if is_number(op)==False and is_hex(op)==None and op not in _base:
        		var_map.append(op)
        	for x in args:
        		get_All_Var(x,var_map)




#substituting close form solution in rest of the axiomes
def solnsubstitution(axioms,key,substituter):
    update_axioms=[]
    for axiom in axioms:
    		if axiom[0]!='i0' and axiom[0]!='i1':
               		update_axioms.append(expr_replace(axiom,key,substituter))
    		else:
                        if axiom[0]=='i1':
                            axiom[4]=expr_replace(axiom[4],key,substituter)
                            update_axioms.append(axiom)
                        elif axiom[0]=='i0':
                            axiom[3]=expr_replace(axiom[3],key,substituter)
                            update_axioms.append(axiom)
                        else:
                            update_axioms.append(axiom)
    return update_axioms



    
def solnsubstitution_Array(axioms,key,substituter):
    update_axioms=[]
    for axiom in axioms:
    		if axiom[0]!='i0' and axiom[0]!='i1':
               		update_axioms.append(expr_array_replace(axiom,key,substituter))
    		else:
                        if axiom[0]=='i1':
                            axiom[4]=expr_array_replace(axiom[4],key,substituter)
                            update_axioms.append(axiom)
                        elif axiom[0]=='i0':
                            axiom[3]=expr_array_replace(axiom[3],key,substituter)
                            update_axioms.append(axiom)
                        else:
                            update_axioms.append(axiom)
    return update_axioms






"""
Reading the contain of the file 
"""
def readingFile( filename ):
    content=None
    with open(currentdirectory+"/"+filename) as f:
        content = f.readlines()
    return content
 
"""
Wrtitting the contain on file 
"""
def writtingFile( filename , content ):
	file = open(currentdirectory+"/"+filename, "w")
	file.write(str(content))
	file.close()

"""
Appending the contain on file 
"""
def appendingFile( filename , content ):
	file = open(currentdirectory+"/"+filename, "a")
	file.write(str(content))
	file.close()

"""

write logs

"""

def writeLogFile(filename , content):
	if os.path.isfile(currentdirectory+"/"+filename):
    		appendingFile( filename , content )
	else:
    		writtingFile( filename , content )
                

"""
Wrtitting the contain on file 
"""
def writtingWittness( filename , content ):
	if os.path.isfile(filename):
    		writtingFile( filename , content )
	else:
    		writtingFile( filename , content )


"""
Convert Inequality to Normal Form

"""


def normal_form_constant(expression, constant):
    #print "*************"
    #print expression
    #print "*************"
    mult_by_minus_one_map = {
    	None: '==',
    	'>=': '<=',
    	'<=': '>=',
    	'>': '<',
    	'<': '>',
	}
    ineq=simplify(expression)
    l = ineq.lhs
    r = ineq.rhs
    op = ineq.rel_op
    all_on_left = l - r
    coeff_dict = all_on_left.as_coefficients_dict()
    var_types = coeff_dict.keys()
    new_rhs = sympify(0)
    for s in var_types:
    	if s != simplify(constant):
            factor=s.coeff(simplify(constant))
            if factor==0:
                    all_on_left = (all_on_left - (coeff_dict[s]*s))
                    new_rhs = (new_rhs - (coeff_dict[s]*s))
    all_on_left=all_on_left.expand(basic=True)
    coeff_dict = all_on_left.as_coefficients_dict()
    var_types = coeff_dict.keys()
    if len(var_types)==1:
    	for s in var_types:
            if coeff_dict[s]<0:
                all_on_left = all_on_left * -1
                new_rhs = new_rhs * -1
                op = mult_by_minus_one_map[op]	
    	factor=all_on_left.coeff(simplify(constant))
    	if factor!=0:
            all_on_left=all_on_left/factor
            new_rhs=new_rhs/factor
    else:
    	all_on_left=simplify(all_on_left)
    	new_rhs=simplify(new_rhs)
    	coeff_dict = all_on_left.as_coefficients_dict()
    	var_types = coeff_dict.keys()
    	if len(var_types)==1:
            for s in var_types:
                if coeff_dict[s]<0:
                    all_on_left = all_on_left * -1
                    new_rhs = new_rhs * -1
                    op = mult_by_minus_one_map[op]	
    
    #print "*************"
    #print all_on_left
    #print new_rhs
    #print "*************"
    return Relational(all_on_left,new_rhs,op)



def solve_for_constant(expression, constant):
    #print "*************"
    #print expression
    #print "*************"
    mult_by_minus_one_map = {
    	None: '==',
    	'>=': '<=',
    	'<=': '>=',
    	'>': '<',
    	'<': '>',
	}
    all_on_left=simplify(expression)
    coeff_dict = all_on_left.as_coefficients_dict()
    var_types = coeff_dict.keys()
    new_rhs = sympify(0)
    for s in var_types:
    	if s != simplify(constant):
            factor=s.coeff(simplify(constant))
            if factor==0:
               all_on_left = (all_on_left - (coeff_dict[s]*s))
               new_rhs = (new_rhs - (coeff_dict[s]*s))
    all_on_left=all_on_left.expand(basic=True)
    coeff_dict = all_on_left.as_coefficients_dict()
    var_types = coeff_dict.keys()
    if len(var_types)==1:
        for s in var_types:
            if coeff_dict[s]<0:
                all_on_left = all_on_left * -1
                new_rhs = new_rhs * -1
                op = mult_by_minus_one_map[op]	
        factor=all_on_left.coeff(simplify(constant))
        if factor!=0:
            if new_rhs is not None:
                if '**' not in str(new_rhs):
                    parser = c_parser.CParser()
                    ast = parser.parse("void test(){"+str(new_rhs)+";}")
                    statement_temp=ast.ext[0].body.block_items[0]
                    axupdate = construct_expression_normalC(eval(expressionCreator_C(statement_temp)))
                    new_rhs=eval("['/',"+str(axupdate[1])+",['"+str(factor)+"']]")
                    return new_rhs
                else:
                    return None
        else:
            if new_rhs is not None:
                if '**' not in str(new_rhs):
                    parser = c_parser.CParser()
                    ast = parser.parse("void test(){"+str(new_rhs)+";}")
                    statement_temp=ast.ext[0].body.block_items[0]
                    axupdate = construct_expression_normalC(eval(expressionCreator_C(statement_temp)))
                    return axupdate[1]
                else:
                    return None
    else:
    	all_on_left=simplify(all_on_left)
    	new_rhs=simplify(new_rhs)
    	coeff_dict = all_on_left.as_coefficients_dict()
    	var_types = coeff_dict.keys()
    	if len(var_types)==1:
            for s in var_types:
                if coeff_dict[s]<0:
                    all_on_left = all_on_left * -1
                    new_rhs = new_rhs * -1
                    op = mult_by_minus_one_map[op]	
    
    return None








#To construct vfact
def wff2fvact(w):
        if w[0] == 'e' or w[0] == 'i0' or w[0] == 'i1':
            return expr2string1(w[-2])
        elif w[0]=='a' or w[0]=='s0' or w[0]=='s1':
            return expr2string1(w[1])
            
"""
Construct vfact by analysis translated equation equation 
"""

def getVariFunDetails(f,o,a,variableMapIp,variableMapOp):
    constaints=[]
    loopvariablesMap={}
    functionMap={}
    vfacts=""
    for variable in variableMapIp:
            values=variableMapIp[variable]
            if values.getDimensions() is not None and len(values.getDimensions())>0:
            	vfact="['"+variable+"',0,['array']]"
            else:
                if values.getVariableType()=='int':	
                    vfact="['"+variable+"',0,['int']]"
                elif values.getVariableType()=='long':	
                    vfact="['"+variable+"',0,['int']]"
                elif values.getVariableType()=='unsigned':	
                    vfact="['"+variable+"',0,['int']]"
                elif values.getVariableType()=='float':
                    vfact="['"+variable+"',0,['float']]"
                elif values.getVariableType()=='double':
                    vfact="['"+variable+"',0,['double']]"
                elif values.getVariableType()=='_Bool':
                    vfact="['"+variable+"',0,['Bool']]"
                elif values.getVariableType()=='array':
                    vfact="['"+variable+"',0,['array']]"
            if vfacts=="":
            	#vfact=''
                vfacts=vfact
            else:
                if vfact!="":
                    vfacts+=","+vfact
                    
    for variable in variableMapOp:
        values=variableMapOp[variable]
        if values[1]=='int':	
            vfact="['"+variable+"',0,['int']]"
        elif values[1]=='unsigned':	
            vfact="['"+variable+"',0,['int']]"
        elif values[1]=='long':	
            vfact="['"+variable+"',0,['int']]"
        elif values[1]=='float':
            vfact="['"+variable+"',0,['float']]"
        elif values[1]=='double':
            vfact="['"+variable+"',0,['double']]"
        elif values[1]=='array':
            vfact="['"+variable+"',0,['array']]"
        elif values[1]=='unsigned':
            vfact="['"+variable+"',0,['int']]"
        elif values[1]=='_Bool':
            vfact="['"+variable+"',0,['Bool']]"
        elif values[1]=='array':
            vfact="['"+variable+"',0,['array']]"
        if vfacts=="":
            vfacts=vfact
        else:
            if vfact!="":
                vfacts+=","+vfact
	
    equations=[]
    for x in a: 
        equations.append(wff2fvact(x))
            
    for equation in equations:
        if equation is not None and '->' not in equation and '>' not in equation and '<' not in equation and '=' not in equation :
            loopvariables=extract_args(equation)
            equation=equation.strip()
            vfact=""
            if len(loopvariables)==0:	
                if equation not in variableMapOp.keys():
                    if equation in variableMapIp.keys():
                        values=variableMapIp[equation]
                        if values[1]=='int':	
                            vfact="['"+equation+"',0,['int']]"
                        elif values[1]=='unsigned':	
                            vfact="['"+equation+"',0,['int']]"
                        elif values[1]=='float':
                            vfact="['"+equation+"',0,['float']]"
                        elif values[1]=='double':
                            vfact="['"+equation+"',0,['double']]"
                        elif values[1]=='_Bool':
                            vfact="['"+equation+"',0,['Bool']]"
                    else:
                         vfact="['"+equation+"',0,['int']]"
				
            else:
                function_name=getFunctionName(str(equation),loopvariables )
                if function_name not in functionMap.keys() and isArrayFunction(function_name)==False:
                   functionMap[function_name]=function_name
                   fact="['int'"
                   for x in range(len(loopvariables)):
                       fact+=",'int'"
                   fact+="]"
                   vfact="['"+function_name+"',"+str(len(loopvariables))+","+fact+"]"	
            if vfacts=="":
               vfacts=vfact
        else:
            if vfact!="":
                        vfacts+=","+vfact
            elif equation is not None and '->' in equation:
                        axiomes=equation.split('->')
                        axiomes[0]=simplify(str(axiomes[0]))
                        if '<' in str(axiomes[0]):
                           variables=str(axiomes[0]).split('<')
                           variables[0]=variables[0].strip()
                           variables[1]=variables[1].strip()
                        elif '>' in str(axiomes[0]):
                           variables=str(axiomes[0]).split('>')
                           variables[0]=variables[0].strip()
                           variables[1]=variables[1].strip()

                        loopvariables=extract_args(variables[1])
                        loopvariablesMap[variables[0]]=variables[0]
                        parameter=""
                        for variable in  loopvariables:
                                variable=variable.strip()
                                if parameter=="":
                                        if '__VERIFIER_nondet' in variable:
                                            tem_var_list = extract_args(variable)
                                            for tem_var in tem_var_list:
                                                if parameter=="":
                                                    parameter="["+tem_var
                                                else:
                                                    parameter+=" ,"+tem_var
                                        else:
                                            parameter="["+variable
                                else:
                                        parameter+=" ,"+variable
                                        loopvariablesMap[variable]=variable
                        if parameter=="":
                                constaint=variables[1]+">=0"
                        else:
                                parameter+="]"
                                constaint="ForAll("+parameter+","+variables[1]+">=0)"
                        constaints.append(constaint)
                        vfact=""
                        if len(loopvariables)==0:	
                                vfact="['"+variables[1]+"',0,['int']]"			
                        else:
                                fact="['int'"
                                for x in range(len(loopvariables)):
                                    fact+=",'int'"
                                fact+="]"
                                function_name=getFunctionName(str(variables[1]),loopvariables )
                                if isArrayFunction(function_name)==False:
                                   vfact="['"+getFunctionName(str(variables[1]),loopvariables )+"',"+str(len(loopvariables))+","+fact+"]"	
                        if vfacts=="":
                                vfacts=vfact
                        else:
                                if vfact!="":
                                   vfacts+=","+vfact
	
    for loopvariable in loopvariablesMap:

        if vfacts=="":
           vfacts="['"+loopvariable+"',0,['int']]"
        else:
           vfacts+=","+"['"+loopvariable+"',0,['int']]"
    vfacts=eval("["+vfacts+"]")
    return vfacts,constaints


#Collect all Function and Variable defination for Translation 2

def getVariFunDetails2(f,o,a,allvariablelist,constraints,assert_list,assume_list):
        var_map={}
        for x in f:
            wff2stringvfact2(f[x],var_map,allvariablelist,constraints)
        for x in o:
            wff2stringvfact2(o[x],var_map,allvariablelist,constraints)
        for x in a:
            wff2stringvfact2(x,var_map,allvariablelist,constraints)
        for x in assert_list:
            wff2stringvfact2(x,var_map,allvariablelist,constraints)
        for x in assume_list:
            wff2stringvfact2(x,var_map,allvariablelist,constraints)
        return var_map



"""
Expanding algebraic powers
"""

def pow_to_mul(expression):
    """
    Convert integer powers in an expression to Muls, like a**2 => a*a(Only for Squre).
    """
    #expression=simplify(expression).expand(basic=True)
    #expression=simplify(expression)
    pows=list(expression.atoms(Pow))
    if any(not e.is_Integer for b, e in (i.as_base_exp() for i in pows)):
    	#A power contains a non-integer exponent
    	return expression
    repl=None
    for b,e in (i.as_base_exp() for i in pows):
    	if e==2:
    		repl = zip(pows,((Mul(*[b]*e,evaluate=False)) for b,e in (i.as_base_exp() for i in pows)))
    if repl is not None:
    	return expression.subs(repl)
    else:
    	return expression



"""
#Function to Simplify and Expand an expression using sympy
"""
def simplify_expand_sympy(expression):
    if 'If' in str(expression) or '%' in str(expression):
    	return expression
    if 'Implies' not in expression and 'ite' not in expression and '==' not in  expression and '!=' not in  expression and 'And' not in  expression and 'Or' not in  expression and 'Not' not in  expression and 'ForAll' and 'Exists' not in  expression and 'Implies' not in expression:
    	return str(simplify_sympy(expression))
    elif 'Implies' in expression :
        axioms=extract_args(expression)
        if len(axioms)==2:
            #return 'Implies('+simplify_expand_sympy(axioms[0])+','+simplify_expand_sympy(axioms[1])+')'
            return 'Implies('+axioms[0]+','+simplify_expand_sympy(axioms[1])+')'
        else:
            return expression
    elif 'ite' in expression and 'And' not in  expression and 'Or' not in  expression and 'Not' not in  expression and 'ForAll' and 'Exists' not in  expression and 'Implies' not in expression:
        axioms=extract_args(expression)
        if len(axioms)==3:
            return 'If('+simplify_expand_sympy(axioms[0])+','+simplify_expand_sympy(axioms[1])+','+simplify_expand_sympy(axioms[2])+')'
        else:
            return expression
    elif '==' in  expression and '!=' not in  expression and 'and' not in  expression and 'or' not in  expression and 'And' not in  expression and 'Or' not in  expression and 'Not' not in  expression and 'ForAll' and 'Exists' not in  expression and 'Implies' not in expression:
        left =None
        right =None
        left,right,expression=parenthesesOrganizer( expression ,left ,right)
        axioms=expression.split('==')
        if len(axioms)!=2:
            return expression
        if left is not None and right is not None:
                if '%' in axioms[0]:
                        leftin =None
                        rightin =None
                        leftin,rightin,axioms[0]=parenthesesOrganizer( axioms[0] ,left ,right)
                        axm=axioms[0].split('%')
                        if left is not None and right is not None:
                                expression="("+left+leftin+str(simplify_sympy(axm[0]))+'%'+str(simplify_sympy(axm[1]))+rightin+')==('+str(simplify_sympy(axioms[1]))+right+")"
                        else:
                                expression="("+left+str(simplify_sympy(axm[0]))+'%'+str(simplify_sympy(axm[1]))+')==('+str(simplify_sympy(axioms[1]))+right+")"
        	
                else:
                        expression="("+left+str(simplify_sympy(axioms[0]))+')==('+str(simplify_sympy(axioms[1]))+right+")"
        		#expression=left+str(pow_to_mul(powsimp(sympify(axioms[0])).expand(basic=True)))+'=='+str(powsimp(pow_to_mul(sympify(axioms[1])).expand(basic=True)))+right
        else:
        	if '%' in axioms[0]:
                        leftin =None
                        rightin =None
                        leftin,rightin,axioms[0]=parenthesesOrganizer( axioms[0] ,left ,right)
                        axm=axioms[0].split('%')
                        if left is not None and right is not None:
                                expression=left+leftin+str(simplify_sympy(axm[0]))+'%'+str(simplify_sympy(axm[1]))+rightin+'=='+str(simplify_sympy(axioms[1]))+right
                        else:
                                expression=left+str(simplify_sympy(axm[0]))+'%'+str(simplify_sympy(axm[1]))+'=='+str(simplify_sympy(axioms[1]))+right
		        	
        	else:
        		expression=str(simplify_sympy(axioms[0]))+'=='+str(simplify_sympy(axioms[1]))
        		#expression=str(pow_to_mul(powsimp(sympify(axioms[0])).expand(basic=True)))+'=='+str(pow_to_mul(powsimp(sympify(axioms[1])).expand(basic=True)))
        return expression
    elif '!=' in  expression and 'and' not in  expression and 'or' not in  expression and 'And' not in  expression and 'Or' not in  expression and 'Not' not in  expression and 'ForAll' and 'Exists' not in  expression and 'Implies' not in expression:
        left =None
        right =None
        left,right,expression=parenthesesOrganizer( expression ,left ,right)
        axioms=expression.split('!=')
        if len(axioms)!=2:
            return expression
        if left is not None and right is not None:
               if '%' in axioms[0]:
                        leftin =None
                        rightin =None
                        leftin,rightin,axioms[0]=parenthesesOrganizer( axioms[0] ,left ,right)
                        axm=axioms[0].split('%')
                        if leftin is not None and rightin is not None:
	                        expression=left+leftin+str(simplify_sympy(axm[0]))+'%'+str(simplify_sympy(axm[1]))+rightin+'=='+str(simplify_sympy(axioms[1]))+right
                        else:
                                expression=left+str(simplify_sympy(axm[0]))+'%'+str(simplify_sympy(axm[1]))+'=='+str(simplify_sympy(axioms[1]))+right
               else:
                        expression=left+str(simplify_sympy(axioms[0]))+'!='+str(simplify_sympy(axioms[1]))+right
        		#expression=left+str(powsimp(pow_to_mul(sympify(axioms[0])).expand(basic=True)))+'!='+str(pow_to_mul(powsimp(sympify(axioms[1])).expand(basic=True)))+right
        else:
                 if '%' in axioms[0]:
                        leftin =None
                        rightin =None
                        leftin,rightin,axioms[0]=parenthesesOrganizer( axioms[0] ,left ,right)
                        axm=axioms[0].split('%')
                        if leftin is not None and rightin is not None:
                                expression=left+leftin+str(simplify_sympy(axm[0]))+'%'+str(simplify_sympy(axm[1]))+rightin+'=='+str(simplify_sympy(axioms[1]))+right
                        else:
                                expression=left+str(simplify_sympy(axm[0]))+'%'+str(simplify_sympy(axm[1]))+'=='+str(simplify_sympy(axioms[1]))+right

                 else:
                        expression=str(simplify_sympy(axioms[0]))+'!='+str(simplify_sympy(axioms[1]))
        		#expression=str(pow_to_mul(powsimp(sympify(axioms[0])).expand(basic=True)))+'!='+str(pow_to_mul(powsimp(sympify(axioms[1])).expand(basic=True)))
        return expression
    else:
        return  expression

"""
#convert all power operator to power function
"""
def convert_pow_op_fun(expression):
    return expression


def convert_pow_op_fun1(expression):
    if 'Implies' not in expression and 'ite' not in expression and 'If' not in expression and '==' not in  expression and '!=' not in  expression and 'and' not in  expression and 'or' not in  expression:
        return  translatepowerToFun(expression)
    elif 'Implies' in expression:
        axioms=extract_args(expression)
        return 'Implies('+convert_pow_op_fun(axioms[0])+','+convert_pow_op_fun(axioms[1])+')'
    elif 'ite' in expression:
        axioms=extract_args(expression)
        return 'If('+convert_pow_op_fun(axioms[0])+','+convert_pow_op_fun(axioms[1])+','+convert_pow_op_fun(axioms[2])+')'
    elif 'If' in expression:
        axioms=extract_args(expression)
        return 'If('+convert_pow_op_fun(axioms[0])+','+convert_pow_op_fun(axioms[1])+','+convert_pow_op_fun(axioms[2])+')'
    elif '==' in  expression and '!=' not in  expression and 'and' not in  expression and 'or' not in  expression:
        expression=translatepowerToFun(expression)
        return expression
    elif '!=' in  expression and 'and' not in  expression and 'or' not in  expression:
        expression=translatepowerToFun(expression)
        return expression
    else:
        return  translatepowerToFun(expression)


def simplify_sympy(expression):
        #if '/' in str(expression) and '>' not in str(expression) and '<' not in str(expression) and '=' not in str(expression):  
        if '<<' in str(expression) or '>>' in str(expression):
                return expression 
        if sympify(expression)==True or sympify(expression)==False:
                return expression        
        if '/' in str(expression):
                expression,flag=expressionChecking(expression)
                if flag==True:
                        expression_mod=expression 
                else:
                        expression_mod=powsimp(expression)
        else:
            if 'array' not in str(expression):
                expression_mod=powsimp(expression)
            else:
                expression_mod=expression 
    
        if '/' not in str(expression_mod) and 'E' not in str(expression_mod) and 'e' not in str(expression_mod):
                expression=expression_mod
        if '/' in str(expression):
                no,deno=fraction(together(expression))
                no=sympify(no).expand(basic=True)
                deno=sympify(deno).expand(basic=True)
                if deno==1:
                        expression,flag=expressionChecking(expression)
                        if flag==True:
                                return expression
				#return pow_to_mul(powsimp(expression))
                        else:
                                return pow_to_mul(powsimp(expression))
			#return pow_to_mul(powsimp(no))
                else:
                      return Mul(pow_to_mul(powsimp(no)), Pow(pow_to_mul(powsimp(deno)), -1), evaluate=False)
	
        else:
                #return str(sympify(expression).expand(basic=True))
                if type(expression) is str:
                    return expression
                else:
                    expressiontemp=sympify(expression).expand(basic=True)
                    if '/' in str(expressiontemp):
                            return pow_to_mul(powsimp(sympify(expression)))
                    else:
                            return pow_to_mul(powsimp(sympify(expression).expand(basic=True)))
	

def substituteValue(expression,key,value):
    if '/' in str(expression):
		#no,deno=fraction(together(expression))
        no,deno=fraction(expression)
        no=sympify(no).expand(basic=True)
        no=no.subs(simplify(key),simplify(value))
        deno=deno.subs(simplify(key),simplify(value))
        if deno==1:
            return powsimp(no)
        else:
            return Mul(powsimp(no), Pow(powsimp(deno), -1), evaluate=False)
	
    else:
        return simplify(expression).subs(simplify(key),simplify(value))









"""
Recurrences Solving Module
#Add by Pritom Rajkhowa
#June 8

Test cases

Test Case 1

#e1=['i1', 2, '_n1', ['a3', ['+', ['_n1'], ['1']]], ['+', ['a3', ['_n1']], ['1']]]
#e2=['i0', 0, ['a3', ['0']], ['0']]

Test Case 2

#e1=['i1', 2, '_n1', ['a3', ['+', ['_n1'], ['1']]], ['*', ['a3', ['_n1']], ['+', ['_n1'], ['1']]]]
#e2=['i0', 0, ['a3', ['0']], ['1']]

Test Case 3

#e1=['i1', 2, '_n1', ['t3', ['+', ['_n1'], ['1']]], ['+', ['t3', ['_n1']], ['2']]]
#e2=['i0', 0, ['a3', ['0']], ['1']]

Test Case 4

#e1=['i1', 2, '_n1', ['a3', ['+', ['_n1'], ['1']]], ['*', ['a3', ['_n1']], ['2']]]
#e2=['i0', 0, ['a3', ['0']], ['1']]

"""
def solve_rec(e1,e2):
        global fun_call_map
        lefthandstmt=None
        righthandstmt=None
        righthandstmt_d=None
        lefthandstmt_base=None
        righthandstmt_base=None
        righthandstmt_base_d=None
        variable=None
        closed_form_soln=None
        non_rec=None
        if e1[0]=='i1':
                lefthandstmt=expr2string1(e1[3])
                righthandstmt=expr2string1(e1[4])
                lefthandstmt=lefthandstmt.strip()
                righthandstmt=righthandstmt.strip()
                variable=e1[2]
                if lefthandstmt.find('_PROVE')>0:
                       return None
                elif lefthandstmt.find('_ASSUME')>0:
                       return None
                if 'ite' not in righthandstmt and '>' not in righthandstmt and '<' not in righthandstmt and '==' not in righthandstmt and '|' not in righthandstmt and '&' not in righthandstmt: 

                        lefthandstmt=simplify(lefthandstmt)
                        righthandstmt=simplify(righthandstmt)
                        variable=simplify(variable)
                else:
                        if '|' not in righthandstmt and '&' not in righthandstmt and '<<' not in righthandstmt and '>>' not in righthandstmt:
                           righthandstmt=expr2stringSimplify(e1[4])
                        righthandstmt=righthandstmt.strip()
                        if 'ite' not in righthandstmt and '>' not in righthandstmt and '<' not in righthandstmt and '==' not in righthandstmt and '<' not in righthandstmt and '==' not in righthandstmt and '|' not in righthandstmt and '&' not in righthandstmt: 

                                lefthandstmt=simplify(lefthandstmt)
                                righthandstmt=simplify(righthandstmt)
                                variable=simplify(variable)
                        else:
                                lefthandstmt=None
                                righthandstmt=None
                                variable=None
        if e2[0]=='i0':
                lefthandstmt_base=expr2string1(e2[2])
                righthandstmt_base=expr2string1(e2[3])
                variable_list=[]
                expr2varlist(e2[3],variable_list)
                lefthandstmt_base=lefthandstmt_base.strip()
                righthandstmt_base=righthandstmt_base.strip()
                if 'ite' in righthandstmt_base or '|' in righthandstmt_base or '&' in righthandstmt_base or '<<' in righthandstmt_base or '>>' in righthandstmt_base: 
                     return None
                lefthandstmt_base=simplify(lefthandstmt_base)
                righthandstmt_base=simplify(righthandstmt_base)

        if variable is not None and lefthandstmt is not None and righthandstmt is not None and lefthandstmt_base is not None and righthandstmt_base is not None:
                righthandstmt_d=righthandstmt
                righthandstmt_base_d=righthandstmt_base
                term1=lefthandstmt.subs(simplify(str(variable)+"+1"),0)
                term2=lefthandstmt.subs(simplify(str(variable)+"+1"),simplify(variable))
                if term1==lefthandstmt_base and  str(term2) in str(righthandstmt):
                        righthandstmt=simplify(righthandstmt).subs({simplify(term2):simplify('T(n)'),simplify(variable):simplify('n')})
                        result=None
			    #Try to solve recurrences
                else:
                    result=None
                    non_rec= True
                try:
				
                                result = getSympyCache(righthandstmt,righthandstmt_base)
                                #result = None
                                
                                if result is None:
                                    #result=recurreSolver_wolframalpha(righthandstmt,righthandstmt_base,variable_list)
                                    result=recurreSolver_sympy(righthandstmt,righthandstmt_base)

                                    if result is None:
                                       if non_rec==True and isFunctionPresent_Sm(e1[4]) is None:
                                          result = simplify(righthandstmt).subs(simplify(variable),simplify(str(variable)+"+1"))
                                    
                                    #result = None
				#if result is None:
					#result=recurreSolver_sympy(righthandstmt,righthandstmt_base)
					#result=recurreSolver_wolframalpha(righthandstmt,righthandstmt_base,variable_list)
                except ValueError:
                    result=None
                if result is not None:
                    try:
                        simplify_sympy(result)
                    except Exception as e:
                        return None
                    result=substituteValue(simplify_sympy(result),simplify('n'),simplify(variable))
                    if "**" in str(result):
                       result=translatepowerToFun(str(result))
                    expression=str(str(term2)+"="+str(result))
                    fun_call_map={}
                    parser = c_parser.CParser()
                    ast = parser.parse("void test(){"+expression+";}")
                    statement_temp=ast.ext[0].body.block_items[0]  
                    closed_form_soln = construct_expressionC(e1[1],e1[2],expr_replace_power(eval(expressionCreator_C(statement_temp.lvalue))),expr_replace_power(eval(expressionCreator_C(statement_temp.rvalue))))
                    #tree = p.parse_expression(expression)
                    #closed_form_soln=construct_expression(tree,e1[1],e1[2])
        #return None
        return closed_form_soln



# expr_replace(e,e1,e2): replace all subterm e1 in e by e2


def expr_replace_power(e): #e,e1,e2: expr
    args=expr_args(e)
    op=expr_op(e)
    if len(args)>0:
        if op=='power' or 'power_' in op :
            return eval("['**']")+list(expr_replace_power(x) for x in expr_args(e))
        else:
            return e[:1]+list(expr_replace_power(x) for x in expr_args(e))
    else:
        return e





"""

Simplification Of Conditional Statements 

"""
def simplifyIteStatement(statement):
	print('############################')
	print(expr2stringSimplify(statement[4]))
	print('*************************')



"""
#Code Add by Pritom Rajkhowa
#Following Code will Translate Java Program to a Array of Statements 
"""

def expr2stringMom(e, key,equation_mom_map):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                return expr2stringMom(args[0], key, equation_mom_map)
            else:
                return '('+(' '+op+' ').join(list(expr2stringMom(x, key, equation_mom_map) for x in args))+')'
        elif op=='not' and len(args)==1:
            return 'not '+expr2stringMom(args[0], key, equation_mom_map)
        elif op=='implies' and len(args)==2:
            return expr2stringMom(args[0], key, equation_mom_map)+ ' -> '+expr2stringMom(args[1], key, equation_mom_map)
        elif op in _infix_op and len(args)==2:
            return '(' + expr2stringMom(args[0], key, equation_mom_map)+ op+expr2stringMom(args[1], key, equation_mom_map)+')'
        else:
            #return op
            if op in equation_mom_map.keys():

               return op

            if op =='W_':

               ret = isProbStmtPresent(e, key, equation_mom_map)

               if ret is not None:

                  return ret

               else:

                  return op +'('+ ','.join(list(expr2stringMom(x, key, equation_mom_map) for x in args))+ ')'

            else:

               return op +'('+ ','.join(list(expr2stringMom(x, key, equation_mom_map) for x in args))+ ')'



def isProbStmtPresent(e, key, equation_mom_map):
    for x in equation_mom_map:
        if  x!=key and equation_mom_map[x][4]==e:
           return x
    return None







"""
Recurrence Solver After Translation
"""
def rec_solver_moment(f,o,a,ff,oo,aa,fff,ooo,aaa):

    global fun_call_map

    #print('==============================')

    #output_axioms_fn(f,o,a)

    #print('==============================')


    constant_fun_map={}
    equation_map={}
    equation_mom_map={}
    equation_mom_sol_map={}
    equation_mom_sol_map_base={}
    list_momt_one = {}
    list_momt_two = {}
    list_momt_three = {}

    list_momt_one_N = {}
    list_momt_two_N = {}
    list_momt_three_N = {}

    list_of_closed_form = []

    fun_var_map={}
    base_map={}

    for axiom in a:
        if axiom[0]=='i1':
             equation_mom_map[axiom[3][0]]=axiom
             equation_map[axiom[3][0]] = axiom[2]
             equation = expr2string1(axiom[3])
             equation_key=str(simplify(equation).subs(simplify(str(axiom[2])+"+1"),simplify(str(axiom[2]))))
             fun_var_map[axiom[3][0]] = equation_key
        if axiom[0]=='s1':
            equ=expr2string1(axiom[1])
            if '->' in equ:
                axiomes=equ.split('->')
                axiomes[0]=simplify(str(axiomes[0]))
                if '<'  in str(axiomes[0]):
                   variables=str(axiomes[0]).split('<')
                   variables[0]=variables[0].strip()
                   variables[1]=variables[1].strip()
                   constant_fun_map[variables[0]]=variables[1]
                elif '>'  in str(axiomes[0]):
                   variables=str(axiomes[0]).split('>')
                   variables[0]=variables[0].strip()
                   variables[1]=variables[1].strip()
                   constant_fun_map[variables[1]]=variables[0]

               
    try:

      key_var = None
      
      closed_form_soln_map = {}

      for axiom in a:

          if axiom[0]=='i1':

             if key_var is not None and key_var!=axiom[2]:

                list_closed_soln =[]

                input_list = []

                parameter_list = []

                parameter_list.append(equation_mom_sol_map)

                parameter_list.append(equation_mom_sol_map_base)

                parameter_list.append(constant_fun_map)

                parameter_list.append(equation_map)

                parameter_list.append(fun_var_map)

                input_list.append(parameter_list)

                input_list.append(3)

                closed_form_soln_map[key_var] = input_list

                constant_fun_map={}

                equation_map={}

                equation_mom_map={}

                equation_mom_sol_map={}

                equation_mom_sol_map_base={}


             else:
                
                key_var = axiom[2]

             result = expr2stringMom(axiom[4], axiom[3][0],equation_mom_map)

             key = axiom[3][0]


             if result[0:3]=='W_(':
                
                if key in equation_mom_sol_map:

                   paras = result[3:-1].split(',')
                   prob1 = simplify(paras[0]) 
                   prob2 = simplify("1-"+paras[0])
                   temp_list = equation_mom_sol_map[key]
                   temp_list.append(paras[1]+' @ '+str(prob1))
                   temp_list.append(paras[2]+' @ '+str(prob2))
                   equation_mom_sol_map[key]= temp_list
                   

                else:

                   temp_list=[]
                   paras = result[3:-1].split(',')
                   prob1 = simplify(paras[0]) 
                   prob2 = simplify("1-"+paras[0])
                   temp_list.append(paras[1]+' @ '+str(prob1))
                   temp_list.append(paras[2]+' @ '+str(prob2))
                   equation_mom_sol_map[key]= temp_list
             else:
                if key in equation_mom_sol_map:
                   temp_list = equation_mom_sol_map[key]
                   temp_list.append(result+' @ 1')
                   equation_mom_sol_map[key]= temp_list
                else:
                   temp_list=[]
                   temp_list.append(result+' @ 1')
                   equation_mom_sol_map[key]= temp_list

          if axiom[0]=='i0':

             key = axiom[2][0]

             result = expr2stringMom(axiom[3], axiom[2][0],equation_mom_map)

             equation_mom_sol_map_base[key]= result

             base_map[key]=axiom


      if key_var not in closed_form_soln_map.keys():

         input_list = []

         parameter_list = []

         parameter_list.append(equation_mom_sol_map)

         parameter_list.append(equation_mom_sol_map_base)

         parameter_list.append(constant_fun_map)

         parameter_list.append(equation_map)

         parameter_list.append(fun_var_map)

         input_list.append(parameter_list)

         input_list.append(3)
         
         closed_form_soln_map[key_var] = input_list



      if len(closed_form_soln_map.keys())>0:

         for key_var in closed_form_soln_map:

             input_list = closed_form_soln_map[key_var]

             result = my_module.myCore_function(input_list[-2], input_list[-1])


             for soln in result:

                rest_val = result[soln]
         
                if "**" in str(rest_val):

                    rest_val = translatepowerToFun(str(rest_val))

                expression=str(str(soln)+"="+str(rest_val))

                fun_call_map={}

                parser = c_parser.CParser()

                ast = parser.parse("void test(){"+expression+";}")

                statement_temp=ast.ext[0].body.block_items[0]

                closed_form_soln = construct_expressionC('0', key_var,expr_replace_power(eval(expressionCreator_C(statement_temp.lvalue))),expr_replace_power(eval(expressionCreator_C(statement_temp.rvalue))))


                list_of_closed_form.append(closed_form_soln)

                if closed_form_soln[-2][0]=='**':

                    if closed_form_soln[-2][-1]==['2']:

                       list_momt_two[closed_form_soln[-2][1][0]] = closed_form_soln[-2]
                       #list_momt_two_N = {}
                    else:

                       list_momt_three[closed_form_soln[-2][1][0]] = closed_form_soln[-2]
                       #list_momt_three_N = {}
                else:

                     list_momt_one[closed_form_soln[-2][0]] = closed_form_soln[-2]
                     #list_momt_one_N = {}


                key_del = closed_form_soln[-2][0]
     

                if key_del in equation_mom_map:
                    e1=copy.deepcopy(closed_form_soln)
                    a.remove(equation_mom_map[key_del])
                    a.remove(base_map[key_del])
                    a=solnsubstitution(a,closed_form_soln[-2],closed_form_soln[-1])
                    constant=constant_fun_map[key_var]
                    fun_call_map={}
                    parser = c_parser.CParser()
                    ast = parser.parse("void test(){"+str(constant)+";}")
                    statement_temp=ast.ext[0].body.block_items[0]
                    constant=eval(expressionCreator_C(statement_temp))
                    variable_list=eval("expres('"+key_var+"')")
                    e1[3]=expr_replace(e1[3],variable_list,constant)
                    e1[4]=expr_replace(e1[4],variable_list,constant)
                    list_momt_one_N[e1[3][0]] = e1[3]
                    list_momt_two_N[e1[3][0]] = ['**',e1[3],['2']]
                    list_momt_three_N[e1[3][0]] = ['**',e1[3],['3']]
                    a=solnsubstitution(a,e1[3],e1[4])
                    for x in o:
                        stmt=o[x]
                        stmt[2]=expr_replace(stmt[2],e1[3],e1[4])


         for x in oo:

             if '_PROVE' not in x:

                 oo[x][-2]=['**',oo[x][-2],['2']]

             for y in list_momt_one_N:

                 oo[x][-1] = expr_replace(oo[x][-1],list_momt_one_N[y],list_momt_two_N[y])

         for x in ooo:


             if '_PROVE' not in x:

                 ooo[x][-2]=['**',ooo[x][-2],['3']]

             for y in list_momt_one_N:

                 ooo[x][-1] = expr_replace(ooo[x][-1],list_momt_one_N[y],list_momt_three_N[y])


         equation_mom_two_map={}

         equation_mom_three_map={}

         base_mom_two_map={}

         base_mom_three_map={}


         for x in aa:

             if x[0]=='i1':

                key = x[-2][0]

                equation_mom_two_map[key] = x


             elif x[0]=='i0':

                key = x[-2][0]

                base_mom_two_map[key] = x



                
             for y in list_momt_one_N:

                if x[0]=='i0' or x[0]=='i1':

                   x[-1] = expr_replace(x[-1],list_momt_one[y],list_momt_two[y])

                else:
             
                   if x[0]=='s0':

                      x[-1] = expr_replace(x[-1],list_momt_one_N[y],list_momt_two_N[y])

                   elif x[0]=='s1':
             
                      x[-1] = expr_replace(x[-1],list_momt_one[y],list_momt_two[y])


         for closed_form_soln in list_of_closed_form:

            key_var = closed_form_soln[-3]

            if closed_form_soln[-2][0]=="**" and closed_form_soln[-2][-1]==['2']:

                key_del=closed_form_soln[-2][1][0]
                e1=copy.deepcopy(closed_form_soln)
                aa.remove(equation_mom_two_map[key_del])
                aa.remove(base_mom_two_map[key_del])
                aa=solnsubstitution(aa,closed_form_soln[-2],closed_form_soln[-1])
                constant=constant_fun_map[key_var]
                fun_call_map={}
                parser = c_parser.CParser()
                ast = parser.parse("void test(){"+str(constant)+";}")
                statement_temp=ast.ext[0].body.block_items[0]
                constant=eval(expressionCreator_C(statement_temp))
                variable_list=eval("expres('"+key_var+"')")
                e1[3]=expr_replace(e1[3],variable_list,constant)
                e1[4]=expr_replace(e1[4],variable_list,constant)
                aa=solnsubstitution(aa,e1[3],e1[4])
                for x in oo:
                    stmt=oo[x]
                    stmt[2]=expr_replace(stmt[2],e1[3],e1[4])


         for x in aaa:

             if x[0]=='i1':

                key = x[-2][0]

                equation_mom_three_map[key] = x


             elif x[0]=='i0':

                key = x[-2][0]

                base_mom_three_map[key] = x



             for y in list_momt_one_N:

                if x[0]=='i0' or x[0]=='i1':

                   x[-1] = expr_replace(x[-1],list_momt_one[y],list_momt_three[y])

                else:

                   if x[0]=='s0':

                      x[-1] = expr_replace(x[-1],list_momt_one_N[y],list_momt_three_N[y])

                   elif x[0]=='s1':
             
                      x[-1] = expr_replace(x[-1],list_momt_one[y],list_momt_three[y])


         for closed_form_soln in list_of_closed_form:

            key_var = closed_form_soln[-3]

            if closed_form_soln[-2][0]=="**" and closed_form_soln[-2][-1]==['3']:

                key_del=closed_form_soln[-2][1][0]
                e1=copy.deepcopy(closed_form_soln)
                aaa.remove(equation_mom_three_map[key_del])
                aaa.remove(base_mom_three_map[key_del])
                aaa=solnsubstitution(aaa,closed_form_soln[-2],closed_form_soln[-1])
                constant=constant_fun_map[key_var]
                fun_call_map={}
                parser = c_parser.CParser()
                ast = parser.parse("void test(){"+str(constant)+";}")
                statement_temp=ast.ext[0].body.block_items[0]
                constant=eval(expressionCreator_C(statement_temp))
                variable_list=eval("expres('"+key_var+"')")
                e1[3]=expr_replace(e1[3],variable_list,constant)
                e1[4]=expr_replace(e1[4],variable_list,constant)
                aa=solnsubstitution(aa,e1[3],e1[4])
                for x in ooo:
                    stmt=ooo[x]
                    stmt[2]=expr_replace(stmt[2],e1[3],e1[4])

    except Exception as e:
         print(e)

    return f,o,a,ff,oo,aa,fff,ooo,aaa,constant_fun_map









"""
#Code Add by Pritom Rajkhowa
#Following Code will Translate Java Program to a Array of Statements 
"""
"""
Recurrence Solver After Translation
"""
"""
Recurrence Solver After Translation
"""
def rec_solver(f,o,a):
    global fun_call_map
    constant_fun_map={}
    equation_map={}
    base_map={}
    
    for axiom in a:
        if axiom[0]=='i1':
             lefthandstmt=expr2string1(axiom[3])
             lefthandstmt=lefthandstmt.strip()
             equation_map[str(simplify(lefthandstmt))]=axiom
        if axiom[0]=='i0':
             lefthandstmt=expr2string1(axiom[2])
             lefthandstmt=lefthandstmt.strip()
             base_map[str(simplify(lefthandstmt))]=axiom
        if axiom[0]=='s1':
             equ=expr2string1(axiom[1])
             if '->' in equ:
                 axiomes=equ.split('->')
                 axiomes[0]=simplify(str(axiomes[0]))
                 if '<'  in str(axiomes[0]):
                    variables=str(axiomes[0]).split('<')
                    variables[0]=variables[0].strip()
                    variables[1]=variables[1].strip()
                    constant_fun_map[variables[0]]=variables[1]
                 elif '>'  in str(axiomes[0]):
                    variables=str(axiomes[0]).split('>')
                    variables[0]=variables[0].strip()
                    variables[1]=variables[1].strip()
                    constant_fun_map[variables[1]]=variables[0]
                    
    while True:
        solution_map={} 
        for equation in equation_map:
            e1=equation_map[equation]
            equation_base=str(simplify(equation).subs(simplify(str(e1[2])+"+1"),0))
            if equation_base in base_map.keys():
                e2=base_map[equation_base]
                result=solve_rec(e1,e2)
                #result = None
                if result is not None:
                    a.remove(base_map[equation_base])
                    del base_map[equation_base]
                    solution_map[equation]=result
    
        for equation in solution_map:
            a.remove(equation_map[equation])
            del equation_map[equation]
            e=solution_map[equation]
            e1=copy.deepcopy(e)
            variable=e[2]
            a=solnsubstitution(a,e[3],e[4])
            constant=constant_fun_map[variable]

            #p = getParser()
            #tree = p.parse_expression(constant)
            #constant=eval(expressionCreator(tree))
            fun_call_map={}
            parser = c_parser.CParser()
            ast = parser.parse("void test(){"+str(constant)+";}")

            statement_temp=ast.ext[0].body.block_items[0]
            constant=eval(expressionCreator_C(statement_temp))
            variable_list=eval("expres('"+variable+"')")
            e1[3]=expr_replace(e1[3],variable_list,constant)
            e1[4]=expr_replace(e1[4],variable_list,constant)
            a=solnsubstitution(a,e1[3],e1[4])
            for x in o:
                stmt=o[x]
                stmt[2]=expr_replace(stmt[2],e1[3],e1[4])
        if len(equation_map)==0 or len(solution_map)==0:
           break
    return f,o,a,constant_fun_map



def rec_solver_tactic8(f,o,a,assertion):
    global fun_call_map
    constant_fun_map={}
    equation_map={}
    base_map={}
    for axiom in a:
        if axiom[0]=='i1':
             lefthandstmt=expr2string1(axiom[3])
             lefthandstmt=lefthandstmt.strip()
             if 'array' not in lefthandstmt:
                equation_map[str(simplify(lefthandstmt))]=axiom
        if axiom[0]=='i0':
             lefthandstmt=expr2string1(axiom[2])
             lefthandstmt=lefthandstmt.strip()
             base_map[str(simplify(lefthandstmt))]=axiom
        if axiom[0]=='s1':
             equ=expr2string1(axiom[1])
             if '->' in equ:
                axiomes=equ.split('->')
                axiomes[0]=simplify(str(axiomes[0]))
                if '>' in str(axiomes[0]):
                   variables=str(axiomes[0]).split('>')
                   variables[0]=variables[0].strip()
                   variables[1]=variables[1].strip()
                   constant_fun_map[variables[1]]=variables[0]
                if '<' in str(axiomes[0]):
                   variables=str(axiomes[0]).split('<')
                   variables[0]=variables[0].strip()
                   variables[1]=variables[1].strip()
                   constant_fun_map[variables[0]]=variables[1]

    while True:
        solution_map={} 
        for equation in equation_map:
            e1=equation_map[equation]
            equation_base=str(simplify(equation).subs(simplify(str(e1[2])+"+1"),0))
            if equation_base in base_map.keys():
                e2=base_map[equation_base]
                result=solve_rec(e1,e2)
                if result is not None:
                    a.remove(base_map[equation_base])
                    del base_map[equation_base]
                    solution_map[equation]=result
        for equation in solution_map:
            a.remove(equation_map[equation])
            del equation_map[equation]
            e=solution_map[equation]
            e1=copy.deepcopy(e)
            variable=e[2]
            a=solnsubstitution(a,e[3],e[4])
            constant=constant_fun_map[variable]
            #p = getParser()
            #tree = p.parse_expression(constant)
            #constant=eval(expressionCreator(tree))
            fun_call_map={}
            parser = c_parser.CParser()
            ast = parser.parse("void test(){"+str(constant)+";}")
            statement_temp=ast.ext[0].body.block_items[0]
            constant=eval(expressionCreator_C(statement_temp))
            variable_list=eval("expres('"+variable+"')")
            
            e1[3]=expr_replace(e1[3],variable_list,constant)
            e1[4]=expr_replace(e1[4],variable_list,constant)
            a=solnsubstitution(a,e1[3],e1[4])
            for w in o:
                conditional_list = getAssumptionCondition(o[w][-1],e1[3])
                if conditional_list is not None:
                    for condition in conditional_list:
                        a.append(wff_a(condition))
            
            if assertion[0]=='s0':
                assertion[-1]=expr_replace(assertion[-1],e1[3],e1[4])
            else:
                if assertion[0]=='c1':
                    assertion[-1]=expr_replace(assertion[-1],e[3],e[4])
                    assertion[-1]=expr_replace(assertion[-1],e1[3],e1[4])
                else:
                    if len(assertion)==1 and assertion[0][0]=='s0':
                        assertion[0][-1]=expr_replace(assertion[0][-1],e[3],e[4])
                        assertion[0][-1]=expr_replace(assertion[0][-1],e1[3],e1[4])
                    else:
                        assertion=expr_replace(assertion,e[3],e[4])
                        assertion=expr_replace(assertion,e1[3],e1[4])
            for x in o:
                stmt=o[x]
                stmt[2]=expr_replace(stmt[2],e1[3],e1[4])
        if len(equation_map)==0 or len(solution_map)==0:
            break
    return f,o,a,constant_fun_map,assertion







def rec_solver_controlflow(f,o,a):
    global fun_call_map
    constant_fun_map={}
    equation_map={}
    base_map={}
    closed_form = []

    
    for axiom in a:
        if axiom[0]=='i1':
             lefthandstmt=expr2string1(axiom[3])
             lefthandstmt=lefthandstmt.strip()
             equation_map[str(simplify(lefthandstmt))]=axiom
        if axiom[0]=='i0':
             lefthandstmt=expr2string1(axiom[2])
             lefthandstmt=lefthandstmt.strip()
             base_map[str(simplify(lefthandstmt))]=axiom
        if axiom[0]=='s1':
             equ=expr2string1(axiom[1])
             if '->' in equ:
                 axiomes=equ.split('->')
                 axiomes[0]=simplify(str(axiomes[0]))
                 if '<'  in str(axiomes[0]):
                    variables=str(axiomes[0]).split('<')
                    variables[0]=variables[0].strip()
                    variables[1]=variables[1].strip()
                    constant_fun_map[variables[0]]=variables[1]
                 elif '>'  in str(axiomes[0]):
                    variables=str(axiomes[0]).split('>')
                    variables[0]=variables[0].strip()
                    variables[1]=variables[1].strip()
                    constant_fun_map[variables[1]]=variables[0]
                    
    while True:
        solution_map={} 
        for equation in equation_map:
            e1=equation_map[equation]
            equation_base=str(simplify(equation).subs(simplify(str(e1[2])+"+1"),0))
            if equation_base in base_map.keys():
                e2=base_map[equation_base]
                result=solve_rec(e1,e2)
                #result = None
                if result is not None:
                    a.remove(base_map[equation_base])
                    del base_map[equation_base]
                    solution_map[equation]=result
    
        for equation in solution_map:
            a.remove(equation_map[equation])
            del equation_map[equation]
            e=solution_map[equation]
            e1=copy.deepcopy(e)
            closed_form.append(e1)
            variable=e[2]
            a=solnsubstitution(a,e[3],e[4])
            constant=constant_fun_map[variable]

            #p = getParser()
            #tree = p.parse_expression(constant)
            #constant=eval(expressionCreator(tree))
            fun_call_map={}
            parser = c_parser.CParser()
            ast = parser.parse("void test(){"+str(constant)+";}")

            statement_temp=ast.ext[0].body.block_items[0]
            constant=eval(expressionCreator_C(statement_temp))
            variable_list=eval("expres('"+variable+"')")
            e1[3]=expr_replace(e1[3],variable_list,constant)
            e1[4]=expr_replace(e1[4],variable_list,constant)
            a=solnsubstitution(a,e1[3],e1[4])
            for x in o:
                stmt=o[x]
                stmt[2]=expr_replace(stmt[2],e1[3],e1[4])
        if len(equation_map)==0 or len(solution_map)==0:
           break

    return f,o,a,constant_fun_map,closed_form

    
"""

#Solving Recurrences using wolframalpha

"""

def recurreSolver_wolframalpha(righthandstmt,righthandstmt_base,variable_list):
    var=None
    query1="T(n+1)="+str(righthandstmt)
    var_map={}
    count=1
    #print query1
    if Mathematica_id is None:
    	return None
    base_expression=None
    if is_number(str(righthandstmt_base))==False:
    	if len(str(righthandstmt_base))>1:
    		var=righthandstmt_base
    		query2="T(0)=N_1"
    		base_expression="N_1"
    	else:
    		for x in variable_list:
    			righthandstmt_base=righthandstmt_base.replace(x,'N_'+str(count))
    			var_map[x]='N_'+str(count)
    			count=count+1
    		query2="T(0)="+str(righthandstmt_base)
    		base_expression=str(righthandstmt_base)
    		
    else:
    	query2="T(0)="+str(righthandstmt_base)
    	base_expression=str(righthandstmt_base)
    query1=transferToFunctionSyntax(str(query1))
    query2=transferToFunctionSyntax(str(query2))
    query1=query1.replace('T[n+1]','T(n+1)')
    query1=query1.replace('T[n]','T(n)')
    query2=query2.replace('T[0]','T(0)')
    query=query2+","+query1
    if '[' in query1:
    	return None
    if query is not None:
        query=query.replace('_N','m_1')
    finalResult=None
    #app_id="YRL93R-5AYL87GHRY"
    #app_id="TQT2K7-5AK3PPJYVX"
    app_id=Mathematica_id
    
    result_cache=getWolframalphaCache(str(righthandstmt),base_expression)
    if result_cache is not None:
        result_cache=result_cache.replace('m_1','_N')
        if var is not None:
            result_cache=result_cache.replace('N_1',str(var))
        for x in var_map.keys():
            result_cache=result_cache.replace(var_map[x],x)
        try:
            temp=simplify(result_cache)
            result_cache=str(simplify_expand_sympy(result_cache))
            writeLogFile( "j2llogs.logs" , "\nEquation Pass to Wolfram Mathematica  \n"+str(query1)+"------Base Case---"+str(query2)+"\n" )
            writeLogFile( "j2llogs.logs" , "\nClosed form solution return by Wolfram Mathematica \n"+str(result_cache)+"\n" )
        except ValueError:
            result_cache=None
        return result_cache
    
    
    try:
        client = wolframalpha.Client(app_id)
        res = client.query(query)
    except ValueError:
    	return None
    for pod in res.pods:
        if 'Recurrence equation solution' in pod.title:
            result=pod.text
            flag=False
            flag=isConstInResult( result )
            if flag==False and ')_' not in result and 'Gamma' not in result and 'Pochhammer' not in result and 'Beta' not in result and 'zeta' not in result and 'alpha' not in result :
                results=result.split('=')
                results[1]=results[1].strip()
                results[1]=results[1].replace(' ','*')
                results[1]=results[1].replace('^','**')
                results[1]=results[1].replace('m_1','_N')
                try:
                    results[1]=replaceAddOperator(results[1])
                    filtered_program = SyntaxFilter.SLexer(results[1])
                    filtered_program.build()
                    results[1]=filtered_program.wolframalphaConstruct()
                except SyntaxFilter.SLexerError as e:
                    return None
                if var is not None:
                    results[1]=results[1].replace('N_1',str(var))
                for x in var_map.keys():
                    results[1]=results[1].replace(var_map[x],x)	
                try:
                    temp=simplify(results[1])
                    finalResult=str(simplify_expand_sympy(results[1]))

                    writeLogFile( "j2llogs.logs" , "\nEquation Pass to Wolfram Mathematica  \n"+str(query1)+"------Base Case---"+str(query2)+"\n" )
                    writeLogFile( "j2llogs.logs" , "\nClosed form solution return by Wolfram Mathematica \n"+str(finalResult)+"\n" )
                except ValueError:
                    finalResult=None
			#writeLogFile( "j2llogs.logs" , "\nFailed to find close form solution\n" )
            else:
                finalResult=None
                #writeLogFile( "j2llogs.logs" , "\nFailed to find close form solution\n" )
    
    return finalResult
 




def getWolframalphaCache(expression,base_expression):
	#cache_map={'(n + 1)**3 + T(n)':['0','(n**2*(n + 1)**2)/2'],'(i + n + 1)**3 + T(n)':['N_1','N_1 + (n*(n + (1 + 2*i) )*(- (2 - 2*i)  + n*(n + (1 + 2*i) )))/4']}
	cache_map={'(n + 1)**3 + T(n)':['0','(n**2*(n + 1)**2)/4'],'T(n) - 1':['N_1','N_1 - n']}
	for element in cache_map.keys():
		if simplify(element)==simplify(expression):
			if simplify(cache_map[element][0])==simplify(base_expression):
				return cache_map[element][1]
	return None






def getSympyCache(expression,base_expression):
	#cache_map={'(n + 1)**3 + T(n)':['0','(n**2*(n + 1)**2)/2'],'(i + n + 1)**3 + T(n)':['N_1','N_1 + (n*(n + (1 + 2*i) )*(- (2 - 2*i)  + n*(n + (1 + 2*i) )))/4']}
	cache_map={'(n + 1)**3 + T(n)':['0','(n**2*(n + 1)**2)/4'],'T(n) - 1':['N_1','N_1 - n']}
	for element in cache_map.keys():
		if simplify(element)==simplify(expression):
                        try:
                                     
                            return simplify(cache_map[element][1]).subs(simplify(cache_map[element][0]),simplify(base_expression))
                            
                        except ValueError:
                            return None
			
	return None





"""
 
#Solving Recurrences using sympy
 
"""
def recurreSolver_sympy(righthandstmt,righthandstmt_base):
    expression="T(n+1)-("+str(righthandstmt)+")"
	#print expression
    f=simplify(expression)
	#Register n as Symbol
    n=Symbol('n')
	#Register T as Function
    T=Function('T')
    result=None
	#Converting String to Sympy Expression
    terminationList={sympify("T(0)"):righthandstmt_base}
	#Try to solve recurrences
    try:
        result=rsolve(f, T(n), terminationList)
        flag=False
        flag=isConstInResult( str(result) )
        if flag==False and result is not None and 'RisingFactorial' not in str(result) and 'binomial' not in str(result) and 'gamma' not in str(result) and 'rgamma' not in str(result) and 'gammaprod' not in str(result) and 'loggamma' not in str(result) and 'beta' not in str(result) and 'superfac' not in str(result) and 'barnesg' not in str(result):
            result=simplify(result)
            writeLogFile( "j2llogs.logs" ,"\nEquation Pass to sympy\n"+str(expression)+"=0"+"------"+"Base Case--T(0)="+str(righthandstmt_base)+"\n" )
            writeLogFile( "j2llogs.logs" ,"\nClosed form solution return by sympy \n"+str(result)+"\n" )
        else:
                    result=None
                    #writeLogFile( "j2llogs.logs" , "\nFailed to find close form solution\n" )
    except ValueError:
        result=None
		#writeLogFile( "j2llogs.logs" , "\nFailed to find close form solution\n" )
    return result




"""
#Axiom Class
#Plain Python object to store Information about a Axiom
"""
class axiomclass(object):
    def __init__(self, frame_axioms , output_equations , other_axioms,  frame_axioms_2 , output_equations_2 , other_axioms_2, frame_axioms_3, output_equations_3 , other_axioms_3, inputvariable, vfact, constraints, const_var_map, asserts, assumes, asserts_2, assumes_2, asserts_3, assumes_3, variables):
            self.frame_axioms = frame_axioms
            self.output_equations = output_equations
            self.other_axioms = other_axioms

            self.frame_axioms_2 = frame_axioms_2
            self.output_equations_2 = output_equations_2
            self.other_axioms_2 = other_axioms_2

            self.frame_axioms_3 = frame_axioms_3
            self.output_equations_3 = output_equations_3
            self.other_axioms_3 = other_axioms_3


            self.inputvariable = inputvariable
            self.vfact = vfact
            self.constraints = constraints
            self.const_var_map = const_var_map
            self.asserts = asserts
            self.assumes = assumes

            self.asserts_2 = asserts_2
            self.assumes_2 = assumes_2


            self.asserts_3 = asserts_3
            self.assumes_3 = assumes_3

            self.variables = variables
            
    def getFrame_axioms(self):
        return self.frame_axioms
    def getOutput_equations(self):
        return self.output_equations
    def getOther_axioms(self):
        return self.other_axioms

    def getFrame_axioms_2(self):
        return self.frame_axioms_2
    def getOutput_equations_2(self):
        return self.output_equations_2
    def getOther_axioms_2(self):
        return self.other_axioms_2

    def getFrame_axioms_3(self):
        return self.frame_axioms_3
    def getOutput_equations_3(self):
        return self.output_equations_3
    def getOther_axioms_3(self):
        return self.other_axioms_3


    def getInputvariable(self):
        return self.inputvariable
    def getVfact(self):
        return self.vfact
    def getConstraints(self):
        return self.constraints
    def getConst_var_map(self):
        return self.const_var_map
    def getAsserts(self):
        return self.asserts
    def setAsserts(self,asserts):
        self.asserts=asserts
    def getAssumes(self):
        return self.assumes

    def getAsserts_2(self):
        return self.asserts_2
    def setAsserts_2(self,asserts_2):
        self.asserts_2=asserts_2
    def getAssumes_2(self):
        return self.assumes_2

    def getAsserts_3(self):
        return self.asserts_3
    def setAsserts_3(self,asserts_3):
        self.asserts_3=asserts_3
    def getAssumes_3(self):
        return self.assumes_3



    def getVariables(self):
        return self.variables
    def setFrame_axioms(self,frame_axioms):
        self.frame_axioms=frame_axioms
    def setOutput_equations(self,output_equations):
        self.output_equations=output_equations
    def setOther_axioms(self,other_axioms):
        self.other_axioms=other_axioms

    def setFrame_axioms_2(self,frame_axioms_2):
        self.frame_axioms_2=frame_axioms_2
    def setOutput_equations_2(self,output_equations_2):
        self.output_equations_2=output_equations_2
    def setOther_axioms_2(self,other_axioms_2):
        self.other_axioms_2=other_axioms_2


    def setFrame_axioms_3(self,frame_axioms_3):
        self.frame_axioms_3=frame_axioms_3
    def setOutput_equations_3(self,output_equations_3):
        self.output_equations_3=output_equations_3
    def setOther_axioms_3(self,other_axioms_3):
        self.other_axioms_3=other_axioms_3


    def setInputvariable(self,inputvariable):
        self.inputvariable=inputvariable
    def setVfact(self,vfact):
        self.vfact=vfact
    def setConstraints(self,constraints):
        self.constraints=constraints
    def setConst_var_map(self,const_var_map):
        self.const_var_map=const_var_map
    def setAsserts(self,asserts):
        self.asserts=asserts
    def setAssumes(self,assumes):
        self.assumes=assumes
    def setVariables(self,variables):
        self.variables=variables

"""
#Sort Class
#Plain Python object to store Information about a Java  Class 
"""
class sortclass(object):
    def __init__(self, sortname , varmap):
        self.sortname = sortname
        self.varmap = varmap
    def getSortname(self):
        return self.sortname
    def getVarmap(self):
        return self.varmap
        
        
"""

#Member Method Class
#Plain Python object to store Information about Member Method of a Java Class 
"""
class membermethodclass(object):
    def __init__(self, methodname, returnType , inputvar, localvar, body, usedCounter, serialNo,tempoary, analysis_module, fun_decl):
            self.methodname = methodname
            self.inputvar = inputvar
            self.returnType = returnType
            self.localvar = localvar
            self.body = body
            self.usedCounter = usedCounter
            self.serialNo = serialNo
            self.tempoary = tempoary
            self.analysis_module = analysis_module
            self.fun_decl = fun_decl
    def getMethodname(self):
        	return self.methodname
    def getreturnType(self):
        	return self.returnType
    def getInputvar(self):
        	return self.inputvar
    def getLocalvar(self):
        	return self.localvar
    def getBody(self):
        return self.body
    def getUsedCounter(self):
        return self.usedCounter
    def getSerialNo(self):
        return self.serialNo
    def getTempoary(self):
        return self.tempoary
    def getFun_decl(self):
        return self.fun_decl
    def getAnalysis_module(self):
        return self.analysis_module
    def setInputvar(self, inputvar):
	        self.inputvar=inputvar
    def setLocalvar(self, localvar):
	        self.localvar=localvar
    def setBody(self, body):
        self.body=body
    def setUsedCounter(self, usedCounter):
        self.usedCounter=usedCounter
    def setSerialNo(self, serialNo):
        self.serialNo=serialNo
    def setTempoary(self,tempoary):
        self.tempoary=tempoary
    def setAnalysis_module(self,analysis_module):
        self.analysis_module=analysis_module
    def setFun_decl(self,fun_decl):
        self.fun_decl=fun_decl
"""

#Variable Class 

#Plain Python Object to store information about variable

"""
class variableclass(object):
    def __init__(self, variablename, variableType, modifiers, dimensions, initialvalue, structType):
        	self.variablename = variablename
        	self.variableType = variableType
        	self.modifiers = modifiers
        	self.dimensions = dimensions
        	self.initialvalue = initialvalue
        	self.structType = structType
    def getVariablename(self):
        return self.variablename
    def getVariableType(self):
        return self.variableType
    def getModifiers(self):
        return self.modifiers
    def getDimensions(self):
        return self.dimensions
    def getInitialvalue(self):
        return self.initialvalue
    def setInitialvalue(self,initialvalue):
        self.initialvalue=initialvalue
    def getStructType(self):
        return self.structType
    def setStructType(self,initialvalue):
        self.structType=structType


"""

#Expression Class
#Plain Python object to store Information about Java Expression 
"""
class expressionclass(object):
    def __init__(self, expression, serialNo, isPrime, degree):
        	self.expression = expression
        	self.serialNo = serialNo
        	self.isPrime = isPrime
        	self.degree = degree
    def getExpression(self):
        	return self.expression
    def getSerialNo(self):
        	return self.serialNo
    def getIsPrime(self):
        	return self.isPrime
    def getDegree(self):
        	return self.degree
    def setExpression(self, expression):
            self.expression=expression
    def setSerialNo(self, serialNo):
            self.serialNo=serialNo
    def setIsPrime(self, isPrime):
            self.isPrime=isPrime
    def setDegree(self, degree):
            self.degree=degree


"""

#Block Class
#Plain Python object to store Information about Block of Java Expression 
"""
class blockclass(object):
    def __init__(self, expression, predicate, serialNo ,isPrime ,degree):
        	self.expression = expression
        	self.predicate = predicate
        	self.serialNo = serialNo
        	self.isPrime = isPrime
        	self.degree = degree
    def getExpression(self):
        	return self.expression
    def getPredicate(self):
        	return self.predicate
    def getSerialNo(self):
        	return self.serialNo
    def getIsPrime(self):
        	return self.isPrime
    def getDegree(self):
        	return self.degree
    def setExpression(self, expression):
        self.expression=expression
    def setPredicate(self, predicate):
        self.predicate=predicate
    def setSerialNo(self, serialNo):
        self.serialNo=serialNo
    def setIsPrime(self, isPrime):
        self.isPrime=isPrime
    def setDegree(self, degree):
        self.degree=degree


"""

#Block Class
#Plain Python object to store Information about if else Java Loop 
"""
class Ifclass(object):
    def __init__(self, predicate, expressionif, expressionelse, serialNo ,isPrime ,degree):
        	self.predicate = predicate
        	self.expressionif = expressionif
        	self.expressionelse = expressionelse
        	self.serialNo = serialNo
        	self.isPrime = isPrime
        	self.degree = degree
    def getExpressionif(self):
        	return self.expressionif
    def getExpressionelse(self):
        	return self.expressionelse
    def getPredicate(self):
        	return self.predicate
    def getSerialNo(self):
        	return self.serialNo
    def getIsPrime(self):
        	return self.isPrime
    def getDegree(self):
        	return self.degree
    def setExpressionif(self, expressionif):
        self.expressionif=expressionif
    def setExpressionelse(self, expressionelse):
        self.expressionelse=expressionelse
    def setPredicate(self, predicate):
        self.predicate=predicate
    def setSerialNo(self, serialNo):
        self.serialNo=serialNo
    def setIsPrime(self, isPrime):
        self.isPrime=isPrime
    def setDegree(self, degree):
        self.degree=degree


"""

#Struct Class
#Plain Python object to store Information about Struct (C Expression) 
"""
class structclass(object):
    def __init__(self, name, isTypeDef, variablemap , defName, isPointer):
        	self.name = name
        	self.isTypeDef = isTypeDef
        	self.variablemap = variablemap
        	self.defName = defName
        	self.isPointer = isPointer
    def getName(self):
        	return self.name
    def getIsTypeDef(self):
        	return self.isTypeDef
    def getVariablemap(self):
        	return self.variablemap
    def getDefName(self):
        	return self.defName
    def getIsPointer(self):
        	return self.isPointer
    def setName(self, name):
        self.name=name
    def setIsTypeDef(self, isTypeDef):
        self.isTypeDef=isTypeDef
    def setVariablemap(self, variablemap):
        self.variablemap=variablemap
    def setDefName(self, defName):
        self.defName=defName
    def setIsPointer(self, isPointer):
        self.isPointer=isPointer






"""

Organization of AST 

"""
               
def organizeStatementToObject(statements):
    count=0
    degree=0
    expressions=[]
    for statement in statements:
        if type(statement) is m.Assignment:
            count=count+1
            expression=expressionclass(statement, count, True,degree)
            expressions.append(expression)
        elif type(statement) is m.While:
            if type(statement.predicate) is m.Unary:
                if type(statement.predicate.expression) is m.ConditionalOr:
                    blockexpressions=[]
                    if statement.body is not None:
                        degree=degree+1
                        count,blockexpressions=blockToExpressions(statement.body, degree, count)
                        degree=degree-1
                    block=blockclass( blockexpressions, statement.predicate, count , True, degree)
                    expressions.append(block)
                elif type(statement.predicate.expression) is m.ConditionalAnd:
                    blockexpressions=[]
                    if statement.body is not None:
                        degree=degree+1
                        count,blockexpressions=blockToExpressions(statement.body, degree, count)
                        degree=degree-1
                    block=blockclass( blockexpressions, statement.predicate, count , True, degree)
                    expressions.append(block)
                elif type(statement.predicate.expression) is m.Relational:
                    blockexpressions=[]
                    if statement.body is not None:
                        degree=degree+1
                        count,blockexpressions=blockToExpressions(statement.body, degree, count)
                        degree=degree-1
                    block=blockclass( blockexpressions, statement.predicate, count , True, degree)
                    expressions.append(block)
                elif type(statement.predicate.expression) is m.Equality:
                    blockexpressions=[]
                    if statement.body is not None:
                        degree=degree+1
                        count,blockexpressions=blockToExpressions(statement.body, degree, count)
                        degree=degree-1
                    block=blockclass( blockexpressions, statement.predicate, count , True, degree)
                    expressions.append(block)
            elif type(statement.predicate) is m.ConditionalAnd:
                    blockexpressions=[]
                    if statement.body is not None:
                        degree=degree+1
                        count,blockexpressions=blockToExpressions(statement.body, degree, count)
                        degree=degree-1
                    block=blockclass( blockexpressions, statement.predicate, count , True, degree)
                    expressions.append(block)
            elif type(statement.predicate) is m.ConditionalOr:
                    blockexpressions=[]
                    if statement.body is not None:
                        degree=degree+1
                        count,blockexpressions=blockToExpressions(statement.body, degree, count)
                        degree=degree-1
                    block=blockclass( blockexpressions, statement.predicate, count , True, degree)
                    expressions.append(block)
            elif type(statement.predicate) is m.Relational:
                    blockexpressions=[]
                    if statement.body is not None:
                        degree=degree+1
                        count,blockexpressions=blockToExpressions(statement.body, degree, count)
                        degree=degree-1
                    block=blockclass( blockexpressions, statement.predicate, count , True, degree)
                    expressions.append(block)
            elif type(statement.predicate) is m.Equality:
                    blockexpressions=[]
                    if statement.body is not None:
                        degree=degree+1
                        count,blockexpressions=blockToExpressions(statement.body, degree, count)
                        degree=degree-1
                    block=blockclass( blockexpressions, statement.predicate, count , True, degree)
                    expressions.append(block)
        else:
            if type(statement) is m.IfThenElse:
                count,ifclass=ifclassCreator(statement, degree, count)
                expressions.append(ifclass)
					
    return expressions		

"""

#Finding last expression or block inside a block

"""

def primeStatement(expressions):
    previous=None
    if type(expressions) is Ifclass:
            primeStatement(expressions.getExpressionif())
            primeStatement(expressions.getExpressionelse())
            previous=expressions
    else:
            if expressions is not None:
                for expression in expressions:
                    if previous is not None:
                        previous.setIsPrime(False)
                    if type(expression) is blockclass:
                        primeStatement(expression.getExpression())
                    if type(expression) is Ifclass:
                        primeStatement(expression.getExpressionif())
                        if expression.getExpressionelse() is not None:
                            primeStatement(expression.getExpressionelse())
                    previous=expression

"""

Converting code block,while loop ,conditional expression and expression to corresponding Classes

"""

def blockToExpressions(body, degree, count):
	expressions=[]
	if body is not None:
		for statement in body:
			if type(statement) is m.Assignment:
				count=count+1
				expression=expressionclass(statement, count, True,degree)
				expressions.append(expression)
			elif type(statement) is m.While:
				if type(statement.predicate) is m.Relational:
					blockexpressions=[]
					if statement.body is not None:
						degree=degree+1
						count,blockexpressions=blockToExpressions(statement.body, degree, count)
						degree=degree-1
					block=blockclass( blockexpressions, statement.predicate, count , True, degree)
					expressions.append(block)
				elif type(statement.predicate) is m.Equality:
					blockexpressions=[]
					if statement.body is not None:
						degree=degree+1
						count,blockexpressions=blockToExpressions(statement.body, degree, count)
						degree=degree-1
					block=blockclass( blockexpressions, statement.predicate, count , True, degree)
					expressions.append(block)
			else:
				if type(statement) is m.IfThenElse:
					count,ifclass=ifclassCreator(statement, degree, count)
					expressions.append(ifclass)
	return count,expressions



"""

Block of Statement to Array of Statement Compatible to Translator Program 

"""
def programToinductiveDefination(expressions, allvariable):
	programsstart=""
	programsend=""
	statements=""
	for expression in expressions:
		if type(expression) is expressionclass:
			if type(expression.getExpression()) is m.Assignment:
				if type(expression.getExpression().lhs) is m.Name:
					var=expression.getExpression().lhs.value
					if expression.getIsPrime()==False:
						if programsstart=="":
							programsstart="['-1','seq',['-1','=',expres('"+str(var)+"'),"+str(expressionCreator(expression.getExpression().rhs))+"]"
							programsend="]"
						else:
							programsstart+=",['-1','seq',['-1','=',expres('"+str(var)+"'),"+str(expressionCreator(expression.getExpression().rhs))+"]"
							programsend+="]"
					else:
                                                if programsstart=="":
                                                     programsstart+="['-1','=',expres('"+str(var)+"'),"+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend
                                                else:
                                                    programsstart+=",['-1','=',expres('"+str(var)+"'),"+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend
				else:
					stmt=createArrayList(expression.getExpression().lhs)
                                	#var="'gt"+str(stmt.count(','))+"',["+stmt+"]"
					var="'gt"+"',["+stmt+"]"
					if expression.getIsPrime()==False:
						if programsstart=="":
							programsstart="['-1','seq',['-1','=',expres("+str(var)+"),"+str(expressionCreator(expression.getExpression().rhs))+"]"
							programsend="]"
						else:
							programsstart+=",['-1','seq',['-1','=',expres("+str(var)+"),"+str(expressionCreator(expression.getExpression().rhs))+"]"
							programsend+="]"
					else:
				                if programsstart=="":
				                        programsstart+="['-1','=',expres("+str(var)+"),"+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend
				                else:
				                        programsstart+=",['-1','=',expres("+str(var)+"),"+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend

		elif type(expression) is blockclass:
			predicatestmt="['-1','while',"+predicateCreator(expression.predicate)+","+programToinductiveDefination( expression.getExpression(), allvariable)+"]"
			if expression.getIsPrime()==False:
				if programsstart=="":
					programsstart="['-1','seq',"+predicatestmt
					programsend="]"
				else:
					programsstart+=",['-1','seq',"+predicatestmt
					programsend+="]"
			else:
				programsstart+=","+predicatestmt+programsend
		elif type(expression) is Ifclass:
			condition=predicateCreator(expression.predicate)
			expressionif=None
			expressionelse=None
			predicatestmt=""
			if expression.getExpressionif() is not None:
				expressionif=programToinductiveDefination( expression.getExpressionif(), allvariable)
			if expression.getExpressionelse() is not None:
				if type(expression.getExpressionelse()) is Ifclass:
					#expressionelse=programToinductiveDefination( expression.getExpressionelse().getExpressionif(), allvariable)
					expressionelse=programToinductiveDefinationIfElse( expression.getExpressionelse(), allvariable)
				else:
					expressionelse=programToinductiveDefination( expression.getExpressionelse(), allvariable)
			if expressionif is not None and expressionelse is not None:
                          	predicatestmt="['-1','if2',"+condition+","+expressionif+","+expressionelse+"]"
			elif expressionif is not None and expressionelse is None:
				predicatestmt="['-1','if1',"+condition+","+expressionif+"]"
			if expression.getIsPrime()==False:
				if programsstart=="":
					programsstart="['-1','seq',"+predicatestmt
					programsend="]"
				else:
					programsstart+=",['-1','seq',"+predicatestmt
					programsend+="]"
			else:
				if programsstart=="":
					programsstart=predicatestmt+programsend
				else:
					programsstart+=","+predicatestmt+programsend
	if programsstart[0]==',':
		programsstart=programsstart[1:]	
	return programsstart		


"""

IfElse Block Statement to Array of Statement Compatible to Translator Program 

"""
def programToinductiveDefinationIfElse(expression, allvariable):
	programsstart=""
	programsend=""
	statements=""
	if type(expression) is expressionclass:
		if type(expression.getExpression()) is m.Assignment:
			if type(expression.getExpression().lhs) is m.Name:
				var=expression.getExpression().lhs.value
				if expression.getIsPrime()==False:
					if programsstart=="":
						programsstart="['-1','seq',['-1','=',expres('"+str(var)+"'),"+str(expressionCreator(expression.getExpression().rhs))+"]"
						programsend="]"
					else:
						programsstart+=",['-1','seq',['-1','=',expres('"+str(var)+"'),"+str(expressionCreator(expression.getExpression().rhs))+"]"
						programsend+="]"
				else:
					if programsstart=="":
                                        	programsstart+="['-1','=',expres('"+str(var)+"'),"+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend
					else:
                                               	programsstart+=",['-1','=',expres('"+str(var)+"'),"+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend
			else:
				stmt=createArrayList(expression.getExpression().lhs)
			        #var="'gt"+str(stmt.count(','))+"',["+stmt+"]"
				var="'gt"+"',["+stmt+"]"
				if expression.getIsPrime()==False:
					if programsstart=="":
						programsstart="['-1','seq',['-1','=',expres("+str(var)+"),"+str(expressionCreator(expression.getExpression().rhs))+"]"
						programsend="]"
					else:
						programsstart+=",['-1','seq',['-1','=',expres("+str(var)+"),"+str(expressionCreator(expression.getExpression().rhs))+"]"
						programsend+="]"
				else:
					if programsstart=="":
						programsstart+="['-1','=',expres("+str(var)+"),"+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend
					else:
						programsstart+=",['-1','=',expres("+str(var)+"),"+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend

	elif type(expression) is blockclass:
		predicatestmt="['-1','while',"+predicateCreator(expression.predicate)+","+programToinductiveDefination( expression.getExpression(), allvariable)+"]"
		if expression.getIsPrime()==False:
			if programsstart=="":
				programsstart="['-1','seq',"+predicatestmt
				programsend="]"
			else:
				programsstart+=",['-1','seq',"+predicatestmt
				programsend+="]"
		else:
			if programsstart=="":
				programsstart+=","+predicatestmt+programsend
			
	elif type(expression) is Ifclass:
		condition=predicateCreator(expression.predicate)
		expressionif=None
		expressionelse=None
		predicatestmt=""
		if expression.getExpressionif() is not None:
			expressionif=programToinductiveDefination( expression.getExpressionif(), allvariable)
		if expression.getExpressionelse() is not None:
			if type(expression.getExpressionelse()) is Ifclass:
				#expressionelse=programToinductiveDefination( expression.getExpressionelse().getExpressionif(), allvariable)
				expressionelse=programToinductiveDefinationIfElse( expression.getExpressionelse(), allvariable)
			else:
				expressionelse=programToinductiveDefination( expression.getExpressionelse(), allvariable)
		if expressionif is not None and expressionelse is not None:
                	predicatestmt="['-1','if2',"+condition+","+expressionif+","+expressionelse+"]"
		elif expressionif is not None and expressionelse is None:
			predicatestmt="['-1','if1',"+condition+","+expressionif+"]"
		if expression.getIsPrime()==False:
			if programsstart=="":
				programsstart="['-1','seq',"+predicatestmt
				programsend="]"
			else:
				programsstart+=",['-1','seq',"+predicatestmt
				programsend+="]"
		else:
			if programsstart=="":
				programsstart=predicatestmt+programsend
			else:
				programsstart+=","+predicatestmt+programsend
	return programsstart
"""

Conditionl Expression of If Loop or While Loop to a Array of Statement Compatible to Translator Program 

"""
    
def predicateCreator(statement):
	expression=""
	if type(statement) is m.Unary:
		if type(statement.expression) is m.Relational:
			if type(statement.expression.lhs) is m.Name:
		    		expression+="['"+getOperatorCmpl(statement.expression.operator)+"',expres('"+statement.expression.lhs.value+"'),"+expressionCreator(statement.expression.rhs)+"]"
			elif type(statement.expression.lhs) is m.Literal:
    				expression+="['"+getOperatorCmpl(statement.expression.operator)+"',expres('"+statement.expression.lhs.value+"'),"+expressionCreator(statement.expression.rhs)+"]"
			elif type(statement.expression.lhs) is m.Additive:
				expression+="['"+getOperatorCmpl(statement.expression.operator)+"',"+expressionCreator(statement.expression.lhs)+","+expressionCreator(statement.expression.rhs)+"]"
			else:
				expression+="['"+getOperatorCmpl(statement.expression.operator)+"',"+expressionCreator(statement.expression.lhs)+","+expressionCreator(statement.expression.rhs)+"]"
		elif type(statement.expression) is m.Equality:
			if type(statement.expression.lhs) is m.Name:
				expression+="['"+getOperatorCmpl(statement.expression.operator)+"',expres('"+statement.expression.lhs.value+"'),"+expressionCreator(statement.expression.rhs)+"]"
			elif type(statement.expression.lhs) is m.Literal:
    				expression+="['"+getOperatorCmpl(statement.expression.operator)+"',expres('"+statement.expression.lhs.value+"'),"+expressionCreator(statement.expression.rhs)+"]"
			elif type(statement.expression.lhs) is m.Additive:
				expression+="['"+getOperatorCmpl(statement.expression.operator)+"',"+expressionCreator(statement.expression.lhs)+","+expressionCreator(statement.expression.rhs)+"]"
			else:
				expression+="['"+getOperatorCmpl(statement.expression.operator)+"',"+expressionCreator(statement.expression.lhs)+","+expressionCreator(statement.expression.rhs)+"]"
		elif type(statement.expression) is m.ConditionalOr:    
			expression+="['and',"+predicateCreatorCmpl(statement.expression.lhs)+","+predicateCreatorCmpl(statement.expression.rhs)+"]"
		elif type(statement.expression) is m.ConditionalAnd:    
	    		expression+="['or',"+predicateCreatorCmpl(statement.expression.lhs)+","+predicateCreatorCmpl(statement.expression.rhs)+"]"
	elif type(statement) is m.Relational:    
    		if type(statement.lhs) is m.Name:
    			expression+="['"+statement.operator+"',expres('"+statement.lhs.value+"'),"+expressionCreator(statement.rhs)+"]"
    		elif type(statement.lhs) is m.Literal:
    			expression+="['"+statement.operator+"',expres('"+statement.lhs.value+"'),"+expressionCreator(statement.rhs)+"]"
    		elif type(statement.lhs) is m.Additive:
    			expression+="['"+statement.operator+"',"+expressionCreator(statement.lhs)+","+expressionCreator(statement.rhs)+"]"
    		else:
    			expression+="['"+statement.operator+"',"+expressionCreator(statement.lhs)+","+expressionCreator(statement.rhs)+"]"
	elif type(statement) is m.Equality:    
		if type(statement.lhs) is m.Name:
    			expression+="['"+statement.operator+"',expres('"+statement.lhs.value+"'),"+expressionCreator(statement.rhs)+"]"
		elif type(statement.lhs) is m.Literal:
    			expression+="['"+statement.operator+"',expres('"+statement.lhs.value+"'),"+expressionCreator(statement.rhs)+"]"
		elif type(statement.lhs) is m.Additive:
		    	expression+="['"+statement.operator+"',"+expressionCreator(statement.lhs)+","+expressionCreator(statement.rhs)+"]"
		else:
    			expression+="['"+statement.operator+"',"+expressionCreator(statement.lhs)+","+expressionCreator(statement.rhs)+"]"
	elif type(statement) is m.ConditionalOr:    
	    	expression+="['or',"+predicateCreator(statement.lhs)+","+predicateCreator(statement.rhs)+"]"
	elif type(statement) is m.ConditionalAnd:    
	    	expression+="['and',"+predicateCreator(statement.lhs)+","+predicateCreator(statement.rhs)+"]"
	return expression
	


"""

Program Expression to a Array of Statement Compatible to Translator Program 

"""

def expressionCreator(statement):
    expression=""
    if type(statement) is m.Name:
    	if '.length' in statement.value:
    		axm=statement.value.split('.')
    		expression+="expres('length',["+axm[0]+"])"
    	else:
    		expression+="expres('"+statement.value+"')"
    elif type(statement) is m.Literal:
    	expression+="expres('"+statement.value+"')"
    elif type(statement) is m.MethodInvocation:
        function=""
        parameter=""
        for argument in statement.arguments:
                if parameter=="":
                        parameter=expressionCreator(argument)
                else:
                        parameter+=","+expressionCreator(argument)
        if "power"==statement.name:
                function="['**',"+parameter+"]"
        else:
                function="['"+statement.name+"',"+parameter+"]"
        expression+=function
    elif type(statement) is m.Unary:
    	expression+="['-',"+expressionCreator(statement.expression)+"]"
    elif type(statement) is m.ArrayAccess:
    	stmt=createArrayList(statement)
    	#expression+="expres('at"+str(stmt.count(','))+"',["+stmt+"])"
    	expression+="expres('at"+"',["+stmt+"])"
    else:
    	if type(statement.lhs) is m.Name:
    		if '.length' in statement.lhs.value:
                        axm=statement.lhs.value.split('.')
                        expression+="expres('length',["+axm[0]+"])"
    		else:
                        expression+="expres('"+statement.operator+"',[expres('"+statement.lhs.value+"')"
    	elif type(statement.lhs) is m.Literal:
    		expression+="expres('"+statement.operator+"',[expres('"+statement.lhs.value+"')"
    	else:
        	if type(statement.lhs) is m.Additive:
            		expression+="expres('"+statement.operator+"',["+expressionCreator(statement.lhs)
        	else :
            		expression+="expres('"+statement.operator+"',["+expressionCreator(statement.lhs)
    	if type(statement.rhs) is m.Name:
        	expression+=",expres('"+statement.rhs.value+"')])"
    	elif type(statement.rhs) is m.Literal:
        	expression+=",expres('"+statement.rhs.value+"')])"
    	elif type(statement.rhs) is m.ArrayAccess:
    		stmt=createArrayList(statement.rhs)
    		#expression+="expres('at"+str(stmt.count(','))+"',["+stmt+"])"
    		expression+="expres('at"+"',["+stmt+"])"
    	else:
        	if type(statement.rhs) is m.Additive:
        		expression+=","+expressionCreator(statement.rhs)+"])"
        	else :
        		expression+=","+expressionCreator(statement.rhs)+"])"
    return expression
    
"""

Construct Array List

"""
def createArrayList(statement):
	if type(statement) is m.ArrayAccess:
		stmt=''
		if type(statement) is m.ArrayAccess:
			stmt=createArrayList(statement.target)
		stmt+=",expres('"+statement.index.value+"')"
		return stmt
	else:
		return "expres('"+statement.value+"')"







"""
 
Program Expression to Collect literal parameters
 
"""
 
def expressionCollectConstant(statement,fun_parameter):
     expression=""
     if type(statement) is m.Name:
     	expression+=statement.value
     elif type(statement) is m.Literal:
     	expression+=statement.value
     elif type(statement) is m.MethodInvocation:
        function=""
        parameter=""
        key=None
        if "power"==statement.name:
                function="['**',"+parameter+"]"
        else:
                key=statement.name
                function="['"+statement.name+"',"+parameter+"]"
        parameterlist=[]
        for argument in statement.arguments:
                if parameter=="":
                        parameter=expressionCollectConstant(argument,fun_parameter)
                        if '_n' not in parameter:
                                parameterlist.append(parameter)     				
                else:
                        parameterstr=expressionCollectConstant(argument,fun_parameter)
                        parameter+=","+expressionCollectConstant(argument,fun_parameter)
                        if '_n' not in parameterstr:
                                parameterlist.append(parameterstr)
     				
        if key is not None:
               fun_parameter[key]=parameterlist
        expression+=function
     elif type(statement) is m.Unary:
     	expression+="['-',"+expressionCollectConstant(statement.expression,fun_parameter)+"]"
     else:
     	if type(statement.lhs) is m.Name:
         	expression+="expres('"+statement.operator+"',[expres('"+statement.lhs.value+"')"
     	elif type(statement.lhs) is m.Literal:
     		expression+="expres('"+statement.operator+"',[expres('"+statement.lhs.value+"')"
     	else:
         	if type(statement.lhs) is m.Additive:
             		expression+="expres('"+statement.operator+"',["+expressionCollectConstant(statement.lhs,fun_parameter)
         	else :
             		expression+="expres('"+statement.operator+"',["+expressionCollectConstant(statement.lhs,fun_parameter)
     	if type(statement.rhs) is m.Name:
         	expression+=",expres('"+statement.rhs.value+"')])"
     	elif type(statement.rhs) is m.Literal:
         	expression+=",expres('"+statement.rhs.value+"')])"
     	else:
         	if type(statement.rhs) is m.Additive:
         		expression+=","+expressionCollectConstant(statement.rhs,fun_parameter)+"])"
         	else :
         		expression+=","+expressionCollectConstant(statement.rhs,fun_parameter)+"])"
     return expression
   


	
"""

Complement of Conditionl Expression of If Loop or While Loop to a Array of Statement Compatible to Translator Program 

"""
    
def predicateCreatorCmpl(statement):
	expression=""
	if type(statement) is m.Unary:
		if type(statement.expression) is m.Relational:
			if type(statement.expression.lhs) is m.Name:
		    		expression+="['"+statement.expression.operator+"',expres('"+statement.expression.lhs.value+"'),"+expressionCreator(statement.expression.rhs)+"]"
			elif type(statement.expression.lhs) is m.Literal:
    				expression+="['"+statement.expression.operator+"',expres('"+statement.expression.lhs.value+"'),"+expressionCreator(statement.expression.rhs)+"]"
			elif type(statement.expression.lhs) is m.Additive:
				expression+="['"+statement.expression.operator+"',"+expressionCreator(statement.expression.lhs)+","+expressionCreator(statement.expression.rhs)+"]"
			else:
				expression+="['"+statement.expression.operator+"',"+expressionCreator(statement.expression.lhs)+","+expressionCreator(statement.expression.rhs)+"]"
		if type(statement.expression) is m.Equality:
			if type(statement.expression.lhs) is m.Name:
				expression+="['"+statement.expression.operator+"',expres('"+statement.expression.lhs.value+"'),"+expressionCreator(statement.expression.rhs)+"]"
			elif type(statement.expression.lhs) is m.Literal:
    				expression+="['"+statement.expression.operator+"',expres('"+statement.expression.lhs.value+"'),"+expressionCreator(statement.expression.rhs)+"]"
			elif type(statement.expression.lhs) is m.Additive:
				expression+="['"+statement.expression.operator+"',"+expressionCreator(statement.expression.lhs)+","+expressionCreator(statement.expression.rhs)+"]"
			else:
				expression+="['"+statement.expression.operator+"',"+expressionCreator(statement.expression.lhs)+","+expressionCreator(statement.expression.rhs)+"]"
		elif type(statement.expression) is m.ConditionalOr:    
			expression+="['and',"+predicateCreator(statement.expression.lhs)+","+predicateCreator(statement.expression.rhs)+"]"
		elif type(statement.expression) is m.ConditionalAnd:    
	    		expression+="['or',"+predicateCreator(statement.expression.lhs)+","+predicateCreator(statement.expression.rhs)+"]"
	elif type(statement) is m.Relational:    
		if type(statement.lhs) is m.Name:
    			expression+="['"+getOperatorCmpl(statement.operator)+"',expres('"+statement.lhs.value+"'),"+expressionCreator(statement.rhs)+"]"
		elif type(statement.lhs) is m.Literal:
    			expression+="['"+getOperatorCmpl(statement.operator)+"',expres('"+statement.lhs.value+"'),"+expressionCreator(statement.rhs)+"]"
		elif type(statement.lhs) is m.Additive:
		    	expression+="['"+getOperatorCmpl(statement.operator)+"',"+expressionCreator(statement.lhs)+","+expressionCreator(statement.rhs)+"]"
		else:
    			expression+="['"+getOperatorCmpl(statement.operator)+"',"+expressionCreator(statement.lhs)+","+expressionCreator(statement.rhs)+"]"
	elif type(statement) is m.Equality:    
		if type(statement.lhs) is m.Name:
    			expression+="['"+getOperatorCmpl(statement.operator)+"',expres('"+statement.lhs.value+"'),"+expressionCreator(statement.rhs)+"]"
		elif type(statement.lhs) is m.Literal:
    			expression+="['"+getOperatorCmpl(statement.operator)+"',expres('"+statement.lhs.value+"'),"+expressionCreator(statement.rhs)+"]"
		elif type(statement.lhs) is m.Additive:
			expression+="['"+getOperatorCmpl(statement.operator)+"',"+expressionCreator(statement.lhs)+","+expressionCreator(statement.rhs)+"]"
		else:
    			expression+="['"+getOperatorCmpl(statement.operator)+"',"+expressionCreator(statement.lhs)+","+expressionCreator(statement.rhs)+"]"
	elif type(statement) is m.ConditionalOr:    
		expression+="['and',"+predicateCreatorCmpl(statement.lhs)+","+predicateCreatorCmpl(statement.rhs)+"]"
	elif type(statement) is m.ConditionalAnd:    
		expression+="['or',"+predicateCreatorCmpl(statement.lhs)+","+predicateCreatorCmpl(statement.rhs)+"]"
	
	return expression



"""

Conditionl Loop to a Array of Statement Compatible to Translator Program 
IfClass Creator

"""

def ifclassCreator(statement, degree, count):
	if type(statement.predicate) is m.Relational:
		predicate=statement.predicate
		blockexpressions1=None
		blockexpressions2=None
		if type(statement.if_true) is m.Block:
			count,blockexpressions1=blockToExpressions(statement.if_true, degree, count)
		if type(statement.if_false) is m.Block:
			count,blockexpressions2=blockToExpressions(statement.if_false, degree, count)
		elif type(statement.if_false) is m.IfThenElse:
			count,blockexpressions2=ifclassCreator(statement.if_false, degree, count)
	elif type(statement.predicate) is m.Equality:
		predicate=statement.predicate
		blockexpressions1=None
		blockexpressions2=None
		if type(statement.if_true) is m.Block:
			count,blockexpressions1=blockToExpressions(statement.if_true, degree, count)
		if type(statement.if_false) is m.Block:
			count,blockexpressions2=blockToExpressions(statement.if_false, degree, count)
		elif type(statement.if_false) is m.IfThenElse:
			count,blockexpressions2=ifclassCreator(statement.if_false, degree, count)
	elif type(statement.predicate) is m.ConditionalOr:
		predicate=statement.predicate
		blockexpressions1=None
		blockexpressions2=None
		if type(statement.if_true) is m.Block:
			count,blockexpressions1=blockToExpressions(statement.if_true, degree, count)
		if type(statement.if_false) is m.Block:
			count,blockexpressions2=blockToExpressions(statement.if_false, degree, count)
		elif type(statement.if_false) is m.IfThenElse:
			count,blockexpressions2=ifclassCreator(statement.if_false, degree, count)
	elif type(statement.predicate) is m.ConditionalAnd:
		predicate=statement.predicate
		blockexpressions1=None
		blockexpressions2=None
		if type(statement.if_true) is m.Block:
			count,blockexpressions1=blockToExpressions(statement.if_true, degree, count)
		if type(statement.if_false) is m.Block:
			count,blockexpressions2=blockToExpressions(statement.if_false, degree, count)
		elif type(statement.if_false) is m.IfThenElse:
			count,blockexpressions2=ifclassCreator(statement.if_false, degree, count)
	elif type(statement.predicate) is m.Unary:
		predicate=statement.predicate
		blockexpressions1=None
		blockexpressions2=None
		if type(statement.if_true) is m.Block:
			count,blockexpressions1=blockToExpressions(statement.if_true, degree, count)
		if type(statement.if_false) is m.Block:
			count,blockexpressions2=blockToExpressions(statement.if_false, degree, count)
		elif type(statement.if_false) is m.IfThenElse:
			count,blockexpressions2=ifclassCreator(statement.if_false, degree, count)
	ifclass=Ifclass(predicate, blockexpressions1, blockexpressions2, count ,True ,degree)
	return count,ifclass

"""

Validation of Variables

"""

def validationOfInput(allvariable):
	for variable in allvariable.keys():
		if variable=='S' or variable=='Q' or variable=='N' or variable=='in' or variable=='is':
			return True
	return False












#Parsing Method Starts

# define some basic operand expressions
number = Regex(r'\d+(\.\d*)?([Ee][+-]?\d+)?')
ident = Word(alphas+'_', alphanums+'_')
#fn_call = ident + '(' + Optional(delimited_list(expr)) + ')'

# forward declare our overall expression, since a slice could 
# contain an arithmetic expression
expr = Forward()
#slice_ref = '[' + expr + ']'

slice_ref = '[' + expr + ZeroOrMore("," + expr) + ']'

# define our arithmetic operand
operand = number | Combine(ident + Optional(slice_ref))
#operand = number | fn_call | Combine(ident + Optional(slice_ref))
inequalities = oneOf("< > >= <= = == !=")

# parse actions to convert parsed items
def convert_to_pow(tokens):
    tmp = tokens[0][:]
    ret = tmp.pop(-1)
    tmp.pop(-1)
    while tmp:
        base = tmp.pop(-1)
        # hack to handle '**' precedence ahead of '-'
        if base.startswith('-'):
            ret = '-power(%s,%s)' % (base[1:], ret)
        else:
            ret = 'power(%s,%s)' % (base, ret)
        if tmp:
            tmp.pop(-1)
    return ret

def unary_as_is(tokens):
    return '(%s)' % ''.join(tokens[0])

def as_is(tokens):
    return '%s' % ''.join(tokens[0])


# simplest infixNotation - may need to add a few more operators, but start with this for now
arith_expr = infixNotation( operand,
    [
    ('-', 1, opAssoc.RIGHT, as_is),
    ('**', 2, opAssoc.LEFT, convert_to_pow),
    ('-', 1, opAssoc.RIGHT, unary_as_is),
    ((inequalities,inequalities), 3, opAssoc.LEFT, as_is),
    (inequalities, 2, opAssoc.LEFT, as_is),
    (oneOf("* /"), 2, opAssoc.LEFT, as_is),
    (oneOf("+ -"), 2, opAssoc.LEFT, as_is),
    (oneOf('and or'), 2, opAssoc.LEFT, as_is),
    ])
#('-', 1, opAssoc.RIGHT, as_is),
# now assign into forward-declared expr
expr <<= arith_expr.setParseAction(lambda t: '(%s)' % ''.join(t))

"""
#expression="2**3"
#expression="2**-3"
#expression="2**3**x5"
#expression="2**-3**x6[-1]"
#expression="2**-3**x5+1"
#expression="(a+1)**2"
#expression="((a+b)*c)**2"
#expression="B**2"
#expression="-B**2"
#expression"(-B)**2"
#expression="B**-2"
#expression="B**(-2)"
#expression="((Z**(_N1+1)-1)/(Z-1))*(Z-1))"
#expression="((_N1+1)**2)<=X"
#expression="_n2*_n3*_N1(_n2, _n3)**2/2"
#translatepowerToFun(expression)
#expression="_n2*_n3*_N1(_n2, X(_n3))**2/2"

#expression="(((2.00000000000000)+_n2*_n3*_N1(_n2, X(_n3))**2/2))"

"""

def translatepowerToFun(expression):
    if "**" in expression:
        try:
            backup_expression=expression
            if ("<" in  expression or ">" in  expression) and '/' not in expression :
                expression=simplify(expression)
            expression=transferToFunctionSyntax(str(expression))
            xform = expr.transformString(expression)[1:-1]
            #xform = expr.transformString(expression)
            xform=xform.replace('[','(')
            expression=xform.replace(']',')')
        except Exception as e:
            expression=backup_expression
   	#print expression
    return expression
 
 
 

"""
Example 1:
>>> expression="x(n)+(y(n)+1)*n"
>>> transferToMathematicaSyntax(expression)
'x[n]+(y[n]+1)*n'

Example 2:

>>> expression="x(n(a,b),a,b)+2^(y(_N1(a,b),a,b)+1)"
>>> transferToMathematicaSyntax(expression)
'x[n[a,b],a,b]+2^(y[_N1[a,b],a,b]+1)'

Example 3:

>>> expression="x(n)+(y(n)/(_N1(n)))"
>>> transferToMathematicaSyntax(expression)
'x[n]+(y[n]/(_N1(n)))'

"""

#Changing function of the formate f(n) to f[n]. It assist the pasring 

def transferToFunctionSyntax(expression):
	if "(" in expression and ")" in expression:
		p = regex.compile(r'\b[a-zA-Z_]\w*(\((?>[^()]|(?1))*\))')
		result=(p.sub(lambda m: m.group().replace("(", "[").replace(")", "]"), expression))
	else:
		result=expression
	return result


#Parsing Method Ends

def isConstInResult( variable ):
	status=False
	find=regex.compile(r'C\d')
	group = find.search(variable)
	if group is not None:
		status=True
	return status

"""

Construction Parser

"""
#p = plyj.parser.Parser()

#def getParser():
	#global p
	#return p




def construct_expressionC(postion,variable,e1,e2):
        expression=[]
        expression.append('i2')
        expression.append(postion)
        expression.append(variable)
        expression.append(e1)
        expression.append(e2)
        return expression

def construct_expression(tree,postion,variable):
	expression=""
	if type(tree) is m.Assignment:
		expression="['i2',"+str(postion)+",'"+variable+"',"+expressionCreator(tree.lhs)+","+expressionCreator(tree.rhs)+"]"
	return eval(expression)



def construct_expression_normalC(e):
	if e is not None:
                expression=[]
                expression.append('s0')
                expression.append(e)
                return expression
	else:
                return None


	
def construct_expression_normal(tree):
	if tree is not None:
		expression=""
		if type(tree) is m.Relational:
			expression="['s0',"+expressionCreator(tree)+"]"
		return eval(expression)
	else:
		return None




"""

#Simplify conclusion 

"""


def simplify_conclusion(conclusion,subs_list):
	if conclusion is not None and conclusion!='':
		term=isFunction(conclusion)
		if term is None:
			return None
		if 'ForAll' in conclusion and term=='ForAll':
			arg_list=extract_args(conclusion)
			result=simplify_conclusion(arg_list[1],subs_list)
			if result is not None:
				return 'ForAll('+arg_list[0]+','+result+')'
			else:
				return None
		elif 'Or' in conclusion and term=='Or':
			arg_list=extract_args(conclusion)
			result1=simplify_conclusion(arg_list[0],subs_list)
			result2=simplify_conclusion(arg_list[1],subs_list)
			if result1 is not None and result2 is not None:
				return 'Or('+result1+','+result2+')'
			else:
				return None
		elif 'And' in conclusion and term=='And':
			arg_list=extract_args(conclusion)
			result1=simplify_conclusion(arg_list[0],subs_list)
			result2=simplify_conclusion(arg_list[1],subs_list)
			if result1 is not None and result2 is not None:
				return 'And('+result1+','+result2+')'
			else:
				return None
		elif 'Exists' in conclusion and term=='Exists':
			arg_list=extract_args(conclusion)
			result=simplify_conclusion(arg_list[1],subs_list) 
			if result is not None:
				return 'Exists('+arg_list[0]+','+result+')'
			else:
				return None
		elif 'Not' in conclusion and term=='Not':
			arg_list=extract_args(conclusion)
			result=simplify_conclusion(arg_list[1],subs_list) 
			if result is not None:
				return 'Not('+result+')'
			else:
				return None
		elif 'Implies' in conclusion and term=='Implies':
			arg_list=extract_args(conclusion)
			result1=simplify_conclusion(arg_list[0],subs_list)
			result2=simplify_conclusion(arg_list[1],subs_list)
			if result1 is not None and result2 is not None:
				return 'Implies('+result1+','+result2+')'
			else:
				return None

		else:
			if '==' not in conclusion and '!=' not in conclusion:
				modified_conclusion=conclusion
				for element in subs_list.keys():
					modified_conclusion=str(modified_conclusion).replace(str(element),str(subs_list[element]))
				if '/' in modified_conclusion:
					conclusion=modified_conclusion
				else:
					conclusion=str(pow_to_mul(powsimp(simplify_sympy(conclusion).subs(subs_list))))
				return conclusion
			elif '!=' in conclusion:
				axm=conclusion.split('!=')
				left_side=None
				right_side=None
				conclusion=None
				if isinstance(simplify_sympy(axm[0]), (str, unicode)) or isinstance(simplify_sympy(axm[1]), (str, unicode)):
					left_side=str(simplify_sympy(axm[0]))
					for element in subs_list.keys():
						left_side=left_side.replace(str(element),str(subs_list[element]))
					right_side=str(simplify_sympy(axm[1]))
					for element in subs_list.keys():
						right_side=right_side.replace(str(element),str(subs_list[element]))
				else:
					left_side=str(simplify_sympy(axm[0]))
					for element in subs_list.keys():
						left_side=left_side.replace(str(element),str(subs_list[element]))
					right_side=str(simplify_sympy(axm[1]))
					for element in subs_list.keys():
						right_side=right_side.replace(str(element),str(subs_list[element]))
					#left_side=str(simplify_sympy(axm[0]).subs(subs_list))
					#right_side=str(simplify_sympy(axm[1]).subs(subs_list))
				if left_side is not None and right_side is not None:
					conclusion=left_side+'!='+right_side
				return conclusion
			
			else:
				axm=conclusion.split('==')
				left_side=None
				right_side=None
				conclusion=None
				leftin=None
				rightin=None
				leftin,rightin,axm[0]=parenthesesOrganizer( axm[0] ,leftin ,rightin)
				if leftin is not None and rightin is not None:
					axm[0]=leftin+axm[0]+rightin
				leftin=None
				rightin=None
				leftin,rightin,axm[1]=parenthesesOrganizer( axm[1] ,leftin ,rightin)
				if leftin is not None and rightin is not None:
					axm[1]=leftin+axm[1]+rightin
				if isinstance(simplify_sympy(axm[0]), (str, unicode)) or isinstance(simplify_sympy(axm[1]), (str, unicode)):
					left_side=str(simplify_sympy(axm[0]))
					for element in subs_list.keys():
						left_side=left_side.replace(str(element),str(subs_list[element]))
					right_side=str(simplify_sympy(axm[1]))
					for element in subs_list.keys():
						right_side=right_side.replace(str(element),str(subs_list[element]))
				else:
					left_side=str(simplify_sympy(axm[0]))
					for element in subs_list.keys():
						left_side=left_side.replace(str(element),str(subs_list[element]))
					right_side=str(simplify_sympy(axm[1]))
					for element in subs_list.keys():
						right_side=right_side.replace(str(element),str(subs_list[element]))
					#left_side=str(simplify_sympy(axm[0]).subs(subs_list))
					#right_side=str(simplify_sympy(axm[1]).subs(subs_list))
				if left_side is not None and right_side is not None:
					conclusion=left_side+'=='+right_side
				return conclusion




"""

Function Display Axioms

"""

def displayAxioms(axiom):
	if axiom is not None:
	    print('1. Frame axioms:')
	    eqset2string1(axiom.getFrame_axioms())
	    print('\n2. Output equations:')
	    eqset2string1(axiom.getOutput_equations())
	    print('\n3. Other axioms:')
	    for x in axiom.getOther_axioms(): 
            	print(wff2string1(x))
            

"""

Function Display Vfact

"""

def displayVfact(axiom):
	if axiom is not None:
	    print(axiom.getVfact())
	    
	   
"""

Function Display Input Variable

"""

def displayInputVariables(axiom):
	if axiom is not None:
	    print(axiom.getInputvariable())




	
	
		
            


def prove_auto_loop_bound(program,property,program_analysis,program_analysis_decl):
	start_time=current_milli_time()
	if program is None:
		print("Something is Wrong")
		return
	if program is not None:
		#print '\n----Proving Process----\n'
		for name in program.getAxiomeMap():
                    
                    axiom=program.getAxiomeMap()[name]
                    
                    witnessXml=program.getWitnessXmlMap()[name]
                    
                    smallest_result = update_bound_smallest(axiom,witnessXml)
                    
                    
                    for e in smallest_result:
                        #axiom.setFrame_axioms(solnsubstitution(axiom.getFrame_axioms(),e[0],e[1]))
                        #axiom.setOutput_equations(solnsubstitution(axiom.getOutput_equations(),e[0],e[1]))
                        axiom.setOther_axioms(solnsubstitution(axiom.getOther_axioms(),e[0],e[1]))
                        o = axiom.getOutput_equations()
                        for x in o:
                            o[x][2]=expr_replace(o[x][2],e[0],e[1])
                    f,o,a,cm = rec_solver(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms())
                    
                    axiom.setFrame_axioms(f)
                    
                    axiom.setOutput_equations(o)
                    
                    axiom.setOther_axioms(a)
                    
                    output_axioms_fn(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms())








def simplifyPostCondition(e):
        if e[:1]==['ite']:
        	count=0
        	condition=None
        	ifexpression=None
        	elseexpression=None
        	main_expression=None
        	for x in expr_args(e):
                        parameter=simplifyPostCondition(x)
                        if count==0:
                            condition=parameter
                        elif count==1:
                            ifexpression=parameter
                        elif count==2:
                            elseexpression=parameter
                            if '>' not in parameter and '<' not in parameter and '=' not in parameter:
                                temp_exp=[]
                                temp_exp.append('implies')
                                temp_exp.append(condition)
                                temp_exp.append(ifexpression)
                                main_expression=temp_exp
                            else:
                                main_expression=['ite']+condition+ifexpression+elseexpression
                        count=count+1
        	if main_expression is not None:
        		return main_expression
        	else:
        		return e
        elif e[:1]==['<='] or e[:1]==['<'] or e[:1]==['>='] or e[:1]==['>'] or e[:1]==['=='] or e[:1]==['!=']:
                return e[:1]+list(x for x in expr_args(e))
        else:
        	return e[:1]+list(simplifyPostCondition(x) for x in expr_args(e))





def tactic1_update(f,o,a,pre_condition,conclusions,vfact,inputmap,constaints,witnessXml):
    global defineDetaillist
    defineDetaillist=[]
    constraint_list=[]
    frame_axioms=eqset2constraintlist_update(f)
    for x in frame_axioms:
        constraint_list.append(x)
    out_axioms=eqset2constraintlist_update(o)
    subs_list=eqset2subs_list(o)
	
    for x in out_axioms:
        constraint_list.append(x)
    for x in a: 
            equations=wff2z3_update(x)                
            equations_sp=None
            if x[0]=='s0':
                    if 'Implies' not in equations and 'If' not in equations and 'And' not in  equations and 'Or' not in  equations and 'Not' not in  equations and 'ForAll' and 'Exists' not in  equations and 'Implies' not in equations:
                        status_value = query2z3_cond([],equations,vfact)
                        status_value = status_value.decode("utf-8")
                        if 'Successfully Proved' not in status_value:
                            constraint_list.append(equations)
                    else:
                        constraint_list.append(equations)
            else:
                    constraint_list.append(equations)
            if x[0]=='s1':
                equations_sp=wff2z3SC_update(x)
                if equations_sp is not None:
                    constraint_list.append(equations_sp)        		
    for x in constaints:
        constraint_list.append(x)
    for x in pre_condition:
        constraint_list.append(x)
    filter_map={}
    for element in defineDetaillist:
        	if element[0] not in filter_map.keys():
        		filter_map[element[0]]=element[0]
        		vfact.append(element)
    defineDetaillist=[]
    for conclusion in conclusions:
        writeLogFile( "j2llogs.logs" , "\nSystem try to prove \n"+str(conclusion)+"\n" )
        if conclusion is None:
            return "Failed to Prove"
        if "factorial" in conclusion:
            cfact=eval("['factorial',1,['int','int']]")
            vfact.append(cfact)
        status=query2z3(constraint_list,conclusion,vfact,inputmap,witnessXml)
        status = status.decode("utf-8")
        writeLogFile( "j2llogs.logs" ,"\nResult \n"+str(status)+"\n" )
        if "Successfully Proved" in status:
            return "Successfully Proved"			
        elif "Counter Example" in status:
            return 	status		
        else:
            return "Failed to Prove"




def prove_assert_tactic1(axiom,witnessXml):
	pre_condition=[]
	post_condition=[]
	
	str_value,word=axiom.getAsserts()

	#post_condition.append(str_value)
	post_condition.append(wff2z3_update1(word,axiom.getConst_var_map()))

			
	for w in axiom.getAssumes():
		if w[0]=='i1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'i1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		elif w[0]=='c1':
			var_cstr_map={}
			rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
			list_var_str=qualifier_list(var_cstr_map.keys())
			list_cstr_str=cstr_list(var_cstr_map.values())
			if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
				rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
			if list_var_str is not None and list_cstr_str is not None:
				if w[0] == 'c1':
					pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
				else:
					pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
			else:
                		pre_condition.append(rhs)
		else:
			if w[0]!='i0':
				var_cstr_map={}
				rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
				list_var_str=qualifier_list(var_cstr_map.keys())
				list_cstr_str=cstr_list(var_cstr_map.values())
				if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
					rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
				if list_var_str is not None and list_cstr_str is not None:
					if w[0] == 'i1':
						pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
					else:
					        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
				else:
                			pre_condition.append(rhs)
			
	for x in post_condition:
		#print('\nAssertion To Prove:'+x)
		temp_post_condition=[]
		temp_post_condition.append(x)
		if post_condition is not None:
			start_time=current_milli_time()
                        #print '----------------@@@@@@@@@'
                        #print axiom.getOther_axioms()
                        #print '----------------@@@@@@@@@'
			writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
			status=tactic1_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
			#status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
			if "Successfully Proved" in status:
				return "Successfully Proved"			
			elif "Counter Example" in status:
				return status
			else:
				return "Failed to Prove"
	return "Nothing To Prove"




def prove_assert_tactic1_2(axiom,witnessXml):
        pre_condition=[]
        post_condition=[]
        str_value,word=axiom.getAsserts_2()
        #post_condition.append(str_value)
        post_condition.append(wff2z3_update1(word,axiom.getConst_var_map()))

			
        for w in axiom.getAssumes_2():
                if w[0]=='i1':
                        var_cstr_map={}
                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                        list_var_str=qualifier_list(var_cstr_map.keys())
                        list_cstr_str=cstr_list(var_cstr_map.values())
                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                               rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                        if list_var_str is not None and list_cstr_str is not None:
                               if w[0] == 'i1':
                                    pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                               else:
                                    pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                        else:
                              pre_condition.append(rhs)
                elif w[0]=='c1':
                        var_cstr_map={}
                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                        list_var_str=qualifier_list(var_cstr_map.keys())
                        list_cstr_str=cstr_list(var_cstr_map.values())
                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                        if list_var_str is not None and list_cstr_str is not None:
                                if w[0] == 'c1':
                                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                else:
                                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                        else:
                                pre_condition.append(rhs)
                else:
                        if w[0]!='i0':
                                var_cstr_map={}
                                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                list_var_str=qualifier_list(var_cstr_map.keys())
                                list_cstr_str=cstr_list(var_cstr_map.values())
                                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                if list_var_str is not None and list_cstr_str is not None:
                                        if w[0] == 'i1':
                                                pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                        else:
                                                pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                else:

                                     pre_condition.append(rhs)
			
        for x in post_condition:
                #print('\nAssertion To Prove:'+x)
                temp_post_condition=[]
                temp_post_condition.append(x)
                if post_condition is not None:
                    start_time=current_milli_time()
                    #print '----------------@@@@@@@@@'
                    #print axiom.getOther_axioms()
                    #print '----------------@@@@@@@@@'
                    writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
                    status=tactic1_update(axiom.getFrame_axioms_2(),axiom.getOutput_equations_2(),axiom.getOther_axioms_2(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
			        #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
                    if "Successfully Proved" in status:
                        return "Successfully Proved"			
                    elif "Counter Example" in status:
                        return status
                    else:
                        return "Failed to Prove"
        return "Nothing To Prove"



def prove_assert_tactic1_3(axiom,witnessXml):
        pre_condition=[]
        post_condition=[]
        str_value,word=axiom.getAsserts_3()
        #post_condition.append(str_value)
        post_condition.append(wff2z3_update1(word,axiom.getConst_var_map()))

			
        for w in axiom.getAssumes_3():
                if w[0]=='i1':
                        var_cstr_map={}
                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                        list_var_str=qualifier_list(var_cstr_map.keys())
                        list_cstr_str=cstr_list(var_cstr_map.values())
                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                               rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                        if list_var_str is not None and list_cstr_str is not None:
                               if w[0] == 'i1':
                                    pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                               else:
                                    pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                        else:
                              pre_condition.append(rhs)
                elif w[0]=='c1':
                        var_cstr_map={}
                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                        list_var_str=qualifier_list(var_cstr_map.keys())
                        list_cstr_str=cstr_list(var_cstr_map.values())
                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                        if list_var_str is not None and list_cstr_str is not None:
                                if w[0] == 'c1':
                                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                else:
                                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                        else:
                                pre_condition.append(rhs)
                else:
                        if w[0]!='i0':
                                var_cstr_map={}
                                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                list_var_str=qualifier_list(var_cstr_map.keys())
                                list_cstr_str=cstr_list(var_cstr_map.values())
                                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                if list_var_str is not None and list_cstr_str is not None:
                                        if w[0] == 'i1':
                                                pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                        else:
                                                pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                else:

                                     pre_condition.append(rhs)
			
        for x in post_condition:
                #print('\nAssertion To Prove:'+x)
                temp_post_condition=[]
                temp_post_condition.append(x)
                if post_condition is not None:
                    start_time=current_milli_time()
                    #print '----------------@@@@@@@@@'
                    #print axiom.getOther_axioms()
                    #print '----------------@@@@@@@@@'
                    writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Post Condition--"+x+"\n Strategy--Direct")
                    status=tactic1_update(axiom.getFrame_axioms_3(),axiom.getOutput_equations_3(),axiom.getOther_axioms_3(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
			        #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
                    if "Successfully Proved" in status:
                        return "Successfully Proved"			
                    elif "Counter Example" in status:
                        return status
                    else:
                        return "Failed to Prove"
        return "Nothing To Prove"


    






def prove_assert_tactic1_termination(axiom,witnessXml):
        pre_condition=[]
        post_condition=[]
        for w in axiom.getAssumes():
               if w[0]=='i1':
                        var_cstr_map={}
                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                        list_var_str=qualifier_list(var_cstr_map.keys())
                        list_cstr_str=cstr_list(var_cstr_map.values())
                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                        if list_var_str is not None and list_cstr_str is not None:
                                if w[0] == 'i1':
                                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                else:
                                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                        else:
                             pre_condition.append(rhs)
               elif w[0]=='c1':
                        var_cstr_map={}
                        rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                        list_var_str=qualifier_list(var_cstr_map.keys())
                        list_cstr_str=cstr_list(var_cstr_map.values())
                        if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                        if list_var_str is not None and list_cstr_str is not None:
                                if w[0] == 'c1':
                                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                else:
                                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                        else:
                             pre_condition.append(rhs)
               else:
                        if w[0]!='i0':
                                var_cstr_map={}
                                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                                list_var_str=qualifier_list(var_cstr_map.keys())
                                list_cstr_str=cstr_list(var_cstr_map.values())
                                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                                        rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                                if list_var_str is not None and list_cstr_str is not None:
                                        if w[0] == 'i1':
                                                pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                                        else:
                                                pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                                else:
                                    pre_condition.append(rhs)
			
        start_time=current_milli_time()
        writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Prove \n"+"\nParameters--\n"+"\n Pre Condition--"+str(pre_condition)+"\n Strategy--Direct")
        status=tactic1_update_termination(copy.deepcopy(axiom.getFrame_axioms()),copy.deepcopy(axiom.getOutput_equations()),copy.deepcopy(axiom.getOther_axioms()),pre_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),witnessXml)
        #status=tactic2_update(axiom.getFrame_axioms(),axiom.getOutput_equations(),axiom.getOther_axioms(),pre_condition,temp_post_condition,axiom.getVfact(),axiom.getInputvariable(),axiom.getConstraints(),axiom.getConst_var_map())
        if "Successfully Proved" in status:
            return "Successfully Proved"			
        else:
            return "Failed to Prove"
    
    




        
                    
                


    












def simplifyAxioms(e):
    if e[0]=='ite':
        arg_list=expr_args(e)
        e1=None
        e2=None
        if arg_list[1][0]=='ite':
            e1=simplifyAxioms(arg_list[1])
        else:
            e1=arg_list[1]
        if arg_list[2][0]=='ite':
            e2=simplifyAxioms(arg_list[2])
        else:
            e2=arg_list[1]
        if  e1 is not None  and e2 is not None and e1==e2:
            return e1
        else:
            return e
    else:
        return e[:1]+list(simplifyAxioms(x) for x in expr_args(e))











































                                                






                    
                    






		








                    
        


























"""

1.Directly translate axoimes to z3 constraint 2.Change  exponential operator ** to power function

"""
def query2z3(constraint_list,conclusion,vfact,inputmap,witnessXml):
        pythonProgram="import sys\n"
       	pythonProgram+="import os\n"
        pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
        pythonProgram+="sys.path.append(currentdirectory+\"/packages/setuptools/\")\n"
        pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
        pythonProgram+="sys.path.append(currentdirectory+\"/packages/z3/python/\")\n"
        pythonProgram+="from z3 import *\n"
        #pythonProgram+="init(currentdirectory+\"/packages/z3\")\n"
        #pythonProgram+="set_param(proof=True)\n"
        pythonProgram+="\ntry:\n"
        pythonProgram+="\t_p1=Int('_p1')\n"
        pythonProgram+="\t_p2=Int('_p2')\n"
        pythonProgram+="\t_n=Int('_n')\n"
        pythonProgram+="\t_bool=Int('_bool')\n"
        pythonProgram+="\tarraySort = DeclareSort('arraySort')\n"
        pythonProgram+="\t_f=Function('_f',IntSort(),IntSort())\n"
        pythonProgram+="\t_ToReal=Function('_ToReal',RealSort(),IntSort())\n"
        pythonProgram+="\t_ToInt=Function('_ToInt',IntSort(),RealSort())\n"
    

        duplicate_map={}
        
        status=""
        for [x,k,l] in vfact:
               if k==0:
                    if ('_PROVE' not in x or '_ASSUME' not in x) and x not in duplicate_map.keys():
                        if l[0]=="int":
                            if '_N' in x:
                                pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
                            else:				
                                pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                        elif l[0]=="double":
                            pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
                        elif l[0]=="float":
                            pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
                        elif l[0]=="Bool":
                            pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                        elif l[0]=="constant":
                            pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
                        elif l[0]=="array":
                            if 'array(' not in x:
                                pythonProgram+='\t'+x+"=Const(\'"+x+"\',arraySort)\n"
                            else:
                                pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                            duplicate_map[x]=x
                                        
               else:
                    if x not in duplicate_map.keys():
                            if ('_PROVE' not in x or '_ASSUME' not in x):
                                    pythonProgram+='\t'+x+"=Function(\'"+x+"\'"
                                    duplicate_map[x]=x
                                    for e in l:
                                            if e=="int":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="unsigned":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="long":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="array":
                                                    pythonProgram+=",arraySort"
                                            else:
                                                    pythonProgram+=",RealSort()"
                                    pythonProgram+=")\n"
        power_flag=False
        for equation in constraint_list:
            if '**' in equation or 'power' in equation:
                power_flag=True
        if '**' in conclusion or 'power' in conclusion:
            power_flag=True
        if power_flag==True:		
            #pythonProgram+="\tpower=Function(\'power\',IntSort(),IntSort(),IntSort())\n"
            pythonProgram+="\tpower=Function(\'power\',RealSort(),RealSort(),RealSort())\n"
            pythonProgram+="\t_s=Solver()\n"
            #pythonProgram+="_s.add(ForAll(x,Implies(x>0,power(x, 0)==1)))\n"
            #pythonProgram+="_s.add(ForAll([x,y],Implies(And(x>0,y>0),power(x, y)==power(x, y-1)*x)))\n"
            #pythonProgram+="_s.set(mbqi=True)\n"
            pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>=0, power(0,_p1)==0)))\n"
            pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p2,_p1)==0,_p2==0)))\n"
            pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>0, power(_p1,0)==1)))\n"
            pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p1,_p2)==1,Or(_p1==1,_p2==0))))\n"
            pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(And(_p1>0,_p2>=0), power(_p1,_p2+1)==power(_p1,_p2)*_p1)))\n"  
        else:
        	pythonProgram+="\t_s=Solver()\n"

        pythonProgram+="\t_s.add(ForAll([_n],Implies(_n>=0, _f(_n)==_n)))\n"
        pythonProgram+="\t_s.set(\"timeout\","+str(TIMEOUT)+")\n"
        for equation in constraint_list:
                if 'main(argc, argv)' not in equation and 'argv1(argv)' not in equation and 'argc1(argc)' not in equation:
                    pythonProgram+="\t_s.add("+str(equation)+")\n"
        finalProgram=pythonProgram
        #finalProgram+="_s.add(Not("+str(transferToFunctionRec(conclusion))+"))\n"
        finalProgram+="\t_s.add(Not("+str(conclusion)+"))\n"
        finalProgram+="\nexcept Exception as e:\n"+"\tprint( \"Error(Z3Query)\")"+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"+"\n\tsys.exit(1)\n"
        finalProgram+="\ntry:\n"
        finalProgram+="\tresult=_s.check()\n\tif sat==result:\n"+"\t\tprint( \"Counter Example\")\n"+"\t\tprint (_s.model())\n"+"\telif unsat==result:\n"+"\t\tresult\n"+"\t\ttry:\n"+"\t\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\t\telse:\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\texcept Exception as e:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\tprint( \"Successfully Proved\")\n"+"\telse:\n"+"\t\tprint( \"Failed To Prove\")"
        finalProgram+="\nexcept Exception as e:\n"+"\tprint (\"Error(Z3Query)\")"+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"
        #finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)==witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\ttry:\n"+"\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\telse:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\texcept Exception as e:\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
        #finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)!=witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+str(element)[:-1]+'=='+str(_s.model()[element])+'</data>'\n"+"\t\telse:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\telse:\n"+"\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
        #finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
        print(finalProgram)
        writtingFile( "z3query.py" , finalProgram )
        #writeLogFile( "j2llogs.logs" , "\nQuery to z3 \n"+str(finalProgram)+"\n" )
        try :
            proc = subprocess.Popen('python '+currentdirectory+'/z3query.py', stdout=subprocess.PIPE,shell=True)
            output = proc.stdout.read()
            status=output
        except OSError  as err:
            print('dharilo1')
        return status






def query2z3_termination(constraint_list,vfact,inputmap,witnessXml):
    pythonProgram="import sys\n"
    pythonProgram+="import os\n"
    pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
    pythonProgram+="sys.path.append(currentdirectory+\"/packages/setuptools/\")\n"
    pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
    pythonProgram+="sys.path.append(currentdirectory+\"/packages/z3/python/\")\n"
    pythonProgram+="from z3 import *\n"
    pythonProgram+="init(currentdirectory+\"/packages/z3\")\n"
    pythonProgram+="set_param(proof=True)\n"
    pythonProgram+="\ntry:\n"
    pythonProgram+="\t_p1=Int('_p1')\n"
    pythonProgram+="\t_p2=Int('_p2')\n"
    pythonProgram+="\t_n=Int('_n')\n"
    pythonProgram+="\t_bool=Int('_bool')\n"
    pythonProgram+="\tarraySort = DeclareSort('arraySort')\n"
    pythonProgram+="\t_f=Function('_f',IntSort(),IntSort())\n"
    pythonProgram+="\t_ToReal=Function('_ToReal',RealSort(),IntSort())\n"
    pythonProgram+="\t_ToInt=Function('_ToInt',IntSort(),RealSort())\n"
    

    duplicate_map={}
        
    status=""
    for [x,k,l] in vfact:
        if k==0:
            if ('_PROVE' not in x or '_ASSUME' not in x) and x not in duplicate_map.keys():
                if l[0]=="int":
                    if '_N' in x:
                        pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
                    else:				
                        pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                elif l[0]=="double":
                    pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
                elif l[0]=="float":
                    pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
                elif l[0]=="Bool":
                    pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                elif l[0]=="constant":
                    pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
                elif l[0]=="array":
                    if 'array(' not in x:
                        pythonProgram+='\t'+x+"=Const(\'"+x+"\',arraySort)\n"
                else:
                    pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                duplicate_map[x]=x
                                        
        else:
            if x not in duplicate_map.keys():
                            if ('_PROVE' not in x or '_ASSUME' not in x):
                                    pythonProgram+='\t'+x+"=Function(\'"+x+"\'"
                                    duplicate_map[x]=x
                                    for e in l:
                                            if e=="int":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="unsigned":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="long":
                                                    pythonProgram+=",IntSort()"
                                            elif e=="array":
                                                    pythonProgram+=",arraySort"
                                            else:
                                                    pythonProgram+=",RealSort()"
                                    pythonProgram+=")\n"
    power_flag=False
    for equation in constraint_list:
        if '**' in equation or 'power' in equation:
            power_flag=True
        if power_flag==True:		
		    #pythonProgram+="\tpower=Function(\'power\',IntSort(),IntSort(),IntSort())\n"
            pythonProgram+="\tpower=Function(\'power\',RealSort(),RealSort(),RealSort())\n"
            pythonProgram+="\t_s=Solver()\n"
            #pythonProgram+="_s.add(ForAll(x,Implies(x>0,power(x, 0)==1)))\n"
            #pythonProgram+="_s.add(ForAll([x,y],Implies(And(x>0,y>0),power(x, y)==power(x, y-1)*x)))\n"
            #pythonProgram+="_s.set(mbqi=True)\n"
            pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>=0, power(0,_p1)==0)))\n"
            pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p2,_p1)==0,_p2==0)))\n"
            pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>0, power(_p1,0)==1)))\n"
            pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p1,_p2)==1,Or(_p1==1,_p2==0))))\n"
            pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(And(_p1>0,_p2>=0), power(_p1,_p2+1)==power(_p1,_p2)*_p1)))\n"  
        else:
        	pythonProgram+="\t_s=Solver()\n"

        pythonProgram+="\t_s.add(ForAll([_n],Implies(_n>=0, _f(_n)==_n)))\n"
        pythonProgram+="\t_s.set(\"timeout\","+str(500)+")\n"
        for equation in constraint_list:
                if 'main(argc, argv)' not in equation and 'argv1(argv)' not in equation and 'argc1(argc)' not in equation:
                    pythonProgram+="\t_s.add("+str(equation)+")\n"
        finalProgram=pythonProgram
        #finalProgram+="_s.add(Not("+str(transferToFunctionRec(conclusion))+"))\n"
        #finalProgram+="\t_s.add(Not("+str(conclusion)+"))\n"
        finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"+"\n\tsys.exit(1)\n"
        finalProgram+="\ntry:\n"
        finalProgram+="\tresult=_s.check()\n\tif sat==result:\n"+"\t\tprint \"Counter Example\"\n"+"\t\tprint _s.model()\n"+"\telif unsat==result:\n"+"\t\tresult\n"+"\t\ttry:\n"+"\t\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\t\telse:\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\texcept Exception as e:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\tprint \"Successfully Proved\"\n"+"\telse:\n"+"\t\tprint \"Failed To Prove\""
        finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"
        #finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)==witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\ttry:\n"+"\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\telse:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\texcept Exception as e:\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
        #finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)!=witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+str(element)[:-1]+'=='+str(_s.model()[element])+'</data>'\n"+"\t\telse:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\telse:\n"+"\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
        #finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
        #print finalProgram
        writtingFile( "z3query.py" , finalProgram )
        writeLogFile( "j2llogs.logs" , "\nQuery to z3 \n"+str(finalProgram)+"\n" )
        try :
            proc = subprocess.Popen('python '+currentdirectory+'/z3query.py', stdout=subprocess.PIPE,shell=True)
            output = proc.stdout.read()
            status=output
        except OSError  as err:
            print ('dharilo1')
        return status




























"""

1.Directly translate axoimes to z3 constraint 2.Change  exponential operator ** to power function

"""
def query2z3_update(constraint_list,conclusion,vfact,witnessXml):
    pythonProgram="import sys\n"
    pythonProgram+="import os\n"
    pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
    pythonProgram+="sys.path.append(currentdirectory+\"/packages/setuptools/\")\n"
    pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
    pythonProgram+="sys.path.append(currentdirectory+\"/packages/z3/python/\")\n"
    pythonProgram+="from z3 import *\n"
    pythonProgram+="init(currentdirectory+\"/packages/z3\")\n"
    pythonProgram+="set_param(proof=True)\n"
    pythonProgram+="\ntry:\n"
    pythonProgram+="\t_p1=Int('_p1')\n"
    pythonProgram+="\t_p2=Int('_p2')\n"
    pythonProgram+="\t_n=Int('_n')\n"
    pythonProgram+="\t_bool=Int('_bool')\n"
    pythonProgram+="\tarraySort = DeclareSort('arraySort')\n"
    pythonProgram+="\t_f=Function('_f',IntSort(),IntSort())\n"
    pythonProgram+="\t_ToReal=Function('_ToReal',RealSort(),IntSort())\n"
    pythonProgram+="\t_ToInt=Function('_ToInt',IntSort(),RealSort())\n"
    
    duplicate_map={}

    status=""

    for [x,k,l] in vfact:
        if k==0:
            if ('_PROVE' not in x or '_ASSUME' not in x) and x not in duplicate_map.keys():
                if l[0]=="int":
                    if '_N' in x:
                        pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
                    else:				
                        pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                elif l[0]=="double":
                    pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
                elif l[0]=="float":
                    pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
                elif l[0]=="Bool":
                    pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                elif l[0]=="constant":
                    pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
                elif l[0]=="array":
                    if 'array(' not in x:
                        pythonProgram+='\t'+x+"=Const(\'"+x+"\',arraySort)\n"
                else:
                        pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                duplicate_map[x]=x
        else:
            if ('_PROVE' not in x or '_ASSUME' not in x) and x not in duplicate_map.keys():
                pythonProgram+='\t'+x+"=Function(\'"+x+"\'"
                duplicate_map[x]=x
                for e in l:
                    if e=="int":
                        pythonProgram+=",IntSort()"
                    elif e=="unsigned":
                        pythonProgram+=",IntSort()"
                    elif e=="long":
                        pythonProgram+=",IntSort()"
                    elif e=="Bool":
                        pythonProgram+=",IntSort()"
                    elif e=="array":
                        pythonProgram+=",arraySort"
                    else:
                        pythonProgram+=",RealSort()"
                pythonProgram+=")\n"
    power_flag=False
    for equation in constraint_list:
        if '**' in equation or 'power' in equation:
            power_flag=True
    if conclusion is not None and ('**' in conclusion or 'power' in conclusion):
        power_flag=True
    if power_flag==True:		
		#pythonProgram+="\tpower=Function(\'power\',IntSort(),IntSort(),IntSort())\n"
        pythonProgram+="\tpower=Function(\'power\',RealSort(),RealSort(),RealSort())\n"
        pythonProgram+="\t_s=Solver()\n"
		#pythonProgram+="_s.add(ForAll(x,Implies(x>0,power(x, 0)==1)))\n"
		#pythonProgram+="_s.add(ForAll([x,y],Implies(And(x>0,y>0),power(x, y)==power(x, y-1)*x)))\n"
		#pythonProgram+="_s.set(mbqi=True)\n"
        pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>=0, power(0,_p1)==0)))\n"
        pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p2,_p1)==0,_p2==0)))\n"
        pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>0, power(_p1,0)==1)))\n"
        pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p1,_p2)==1,Or(_p1==1,_p2==0))))\n"
        pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(And(_p1>0,_p2>=0), power(_p1,_p2+1)==power(_p1,_p2)*_p1)))\n"  
    else:
        pythonProgram+="\t_s=Solver()\n"

    pythonProgram+="\t_s.add(ForAll([_n],Implies(_n>=0, _f(_n)==_n)))\n"
    pythonProgram+="\t_s.set(\"timeout\","+str(500)+")\n"
    for equation in constraint_list:
        pythonProgram+="\t_s.add("+str(equation)+")\n"
    finalProgram=pythonProgram
	#finalProgram+="_s.add(Not("+str(transferToFunctionRec(conclusion))+"))\n"
    if conclusion is not None:
        finalProgram+="\t_s.add(Not("+str(conclusion)+"))\n"
        finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"+"\n\tsys.exit(1)\n"
        finalProgram+="\ntry:\n"
        finalProgram+="\tresult=_s.check()\n\tif sat==result:\n"+"\t\tprint \"Counter Example\"\n"+"\t\tprint _s.model()\n"+"\telif unsat==result:\n"+"\t\tresult\n"+"\t\ttry:\n"+"\t\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\t\telse:\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\texcept Exception as e:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\tprint \"Successfully Proved\"\n"+"\telse:\n"+"\t\tprint \"Failed To Prove\""
        #finalProgram+="\tif sat==_s.check():\n"+"\t\tprint \"Counter Example\"\n"+"\t\tprint _s.model()\n"+"\t\twitnessXmlStr="+str(witnessXml)+"\n"+"\t\tmiddle=''\n"+"\t\tfor element in _s.model():\n"+"\t\t\tif str(element)==witnessXmlStr[2]:\n"+"\t\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\t\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\t\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\t\tfile.close()\n"+"\telif unsat==_s.check():\n"+"\t\t_s.check()\n"+"\t\ttry:\n"+"\t\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\t\telse:\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\texcept Exception as e:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\tprint \"Successfully Proved\"\n"+"\telse:\n"+"\t\tprint \"Failed To Prove\""
    finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)==witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\ttry:\n"+"\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\telse:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\texcept Exception as e:\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"\twitnessXmlStr="+str(witnessXml)+"\n"+"\tmiddle=''\n"+"\tfor element in _s.model():\n"+"\t\tif str(element)!=witnessXmlStr[2]:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+str(element)[:-1]+'=='+str(_s.model()[element])+'</data>'\n"+"\t\telse:\n"+"\t\t\tmiddle+='<data key=\"assumption\">'+'\\\\'+'result=='+str(_s.model()[element])+'</data>'\n"+"\tfile = open(witnessXmlStr[3]+'_witness.graphml', 'w')\n"+"\tfile.write(witnessXmlStr[0]+middle+witnessXmlStr[1])\n"+"\tfile.close()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\telse:\n"+"\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\tfile.close()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
	#finalProgram+="if sat==_s.check():\n"+"\tprint \"Counter Example\"\n"+"\tprint _s.model()\n"+"elif unsat==_s.check():\n"+"\t_s.check()\n"+"\tprint \"Successfully Proved\"\n"+"else:\n"+"\tprint \"Failed To Prove\""
    #print(finalProgram)
    writtingFile( "z3query.py" , finalProgram )
    writeLogFile( "j2llogs.logs" , "\nQuery to z3 \n"+str(finalProgram)+"\n" )
    try :
        proc = subprocess.Popen('python '+currentdirectory+'/z3query.py', stdout=subprocess.PIPE,shell=True)
        output = proc.stdout.read()
        status=output
    except OSError  as err:
        print('dharilo1')
    return status




"""

1.Directly translate axoimes to z3 constraint 2.Change  exponential operator ** to power function

"""
def query2z3_cond(constraint_list,conclusion,vfact):
    pythonProgram="import sys\n"
    pythonProgram+="import os\n"
    pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
    pythonProgram+="sys.path.append(currentdirectory+\"/packages/setuptools/\")\n"
    pythonProgram+="currentdirectory = os.path.dirname(os.path.realpath(__file__))\n"
    pythonProgram+="sys.path.append(currentdirectory+\"/packages/z3/python/\")\n"
    pythonProgram+="from z3 import *\n"
    pythonProgram+="init(currentdirectory+\"/packages/z3\")\n"
    pythonProgram+="set_param(proof=True)\n"
    pythonProgram+="\ntry:\n"
    pythonProgram+="\t_p1=Int('_p1')\n"
    pythonProgram+="\t_p2=Int('_p2')\n"
    pythonProgram+="\t_n=Int('_n')\n"
    pythonProgram+="\t_bool=Int('_bool')\n"
    pythonProgram+="\tarraySort = DeclareSort('arraySort')\n"
    pythonProgram+="\t_f=Function('_f',IntSort(),IntSort())\n"
    pythonProgram+="\t_ToReal=Function('_ToReal',RealSort(),IntSort())\n"
    pythonProgram+="\t_ToInt=Function('_ToInt',IntSort(),RealSort())\n"
    
    duplicate_map={}

    status=""
    for [x,k,l] in vfact:
        if k==0:
            if ('_PROVE' not in x or '_ASSUME' not in x) and x not in duplicate_map.keys():
                if l[0]=="int":
                    if '_N' in x:
                        pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
                    else:				
                        pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                elif l[0]=="double":
                    pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
                elif l[0]=="float":
                    pythonProgram+='\t'+x+"=Real(\'"+x+"\')\n"
                elif l[0]=="Bool":
                    pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                elif l[0]=="constant":
                    pythonProgram+='\t'+x+"=Const(\'"+x+"\',IntSort())\n"
                elif l[0]=="array":
                    if 'array(' not in x:
                        pythonProgram+='\t'+x+"=Const(\'"+x+"\',arraySort)\n"
                else:
                    pythonProgram+='\t'+x+"=Int(\'"+x+"\')\n"
                duplicate_map[x]=x
        else:
            if ('_PROVE' not in x or '_ASSUME' not in x) and x not in duplicate_map.keys():
                pythonProgram+='\t'+x+"=Function(\'"+x+"\'"
                duplicate_map[x]=x
                for e in l:
                    if e=="int":
                        pythonProgram+=",IntSort()"
                    elif e=="unsigned":
                        pythonProgram+=",IntSort()"
                    elif e=="long":
                        pythonProgram+=",IntSort()"
                    elif e=="Bool":
                        pythonProgram+=",IntSort()"
                    elif e=="array":
                        pythonProgram+=",arraySort"
                    else:
                        pythonProgram+=",RealSort()"
                    pythonProgram+=")\n"
    power_flag=False
    for equation in constraint_list:
        if '**' in equation or 'power' in equation:
            power_flag=True
    if '**' in conclusion or 'power' in conclusion:
        power_flag=True
    if power_flag==True:		
		#pythonProgram+="\tpower=Function(\'power\',IntSort(),IntSort(),IntSort())\n"
        pythonProgram+="\tpower=Function(\'power\',RealSort(),RealSort(),RealSort())\n"
        pythonProgram+="\t_s=Solver()\n"
		#pythonProgram+="_s.add(ForAll(x,Implies(x>0,power(x, 0)==1)))\n"
		#pythonProgram+="_s.add(ForAll([x,y],Implies(And(x>0,y>0),power(x, y)==power(x, y-1)*x)))\n"
		#pythonProgram+="_s.set(mbqi=True)\n"
        pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>=0, power(0,_p1)==0)))\n"
        pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p2,_p1)==0,_p2==0)))\n"
        pythonProgram+="\t_s.add(ForAll([_p1],Implies(_p1>0, power(_p1,0)==1)))\n"
        pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(power(_p1,_p2)==1,Or(_p1==1,_p2==0))))\n"
        pythonProgram+="\t_s.add(ForAll([_p1,_p2],Implies(And(_p1>0,_p2>=0), power(_p1,_p2+1)==power(_p1,_p2)*_p1)))\n"  
    else:
        	pythonProgram+="\t_s=Solver()\n"

    pythonProgram+="\t_s.add(ForAll([_n],Implies(_n>=0, _f(_n)==_n)))\n"
    pythonProgram+="\t_s.set(\"timeout\","+str(500)+")\n"
    for equation in constraint_list:
        pythonProgram+="\t_s.add("+str(equation)+")\n"
    finalProgram=pythonProgram
    finalProgram+="\t_s.add(Not("+str(conclusion)+"))\n"
    finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"+"\n\tsys.exit(1)\n"
    finalProgram+="\ntry:\n"
    #finalProgram+="\tif sat==_s.check():\n"+"\t\tprint \"Counter Example\"\n"+"\t\tprint _s.model()\n"+"\telif unsat==_s.check():\n"+"\t\t_s.check()\n"+"\t\ttry:\n"+"\t\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\t\telse:\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\texcept Exception as e:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\tprint \"Successfully Proved\"\n"+"\telse:\n"+"\t\tprint \"Failed To Prove\""
    finalProgram+="\tresult=_s.check()\n\tif sat==result:\n"+"\t\tprint \"Counter Example\"\n"+"\t\tprint _s.model()\n"+"\telif unsat==result:\n"+"\t\tresult\n"+"\t\ttry:\n"+"\t\t\tif os.path.isfile(\'j2llogs.logs\'):\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\t\telse:\n"+"\t\t\t\tfile = open(\'j2llogs.logs\', \'w\')\n"+"\t\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+str(_s.proof().children())+\"\\n\")\n"+"\t\t\t\tfile.close()\n"+"\t\texcept Exception as e:\n"+"\t\t\tfile = open(\'j2llogs.logs\', \'a\')\n"+"\t\t\tfile.write(\"\\n**************\\nProof Details\\n**************\\n\"+\"Error\"+\"\\n\")\n"+"\t\t\tfile.close()\n"+"\t\tprint \"Successfully Proved\"\n"+"\telse:\n"+"\t\tprint \"Failed To Prove\""
    finalProgram+="\nexcept Exception as e:\n"+"\tprint \"Error(Z3Query)\""+"\n\tfile = open('j2llogs.logs', 'a')\n"+"\n\tfile.write(str(e))\n"+"\n\tfile.close()\n"
    writtingFile( "z3query.py" , finalProgram )
    writeLogFile( "j2llogs.logs" , "\nQuery to z3 \n"+str(finalProgram)+"\n" )
    try :
        proc = subprocess.Popen('python '+currentdirectory+'/z3query.py', stdout=subprocess.PIPE,shell=True)
        output = proc.stdout.read()
        status=output
    except OSError  as err:
        print ('dharilo1')
    return status












		
		
#Stack Implementaion 

class Stack:
     def __init__(self):
         self.items = []

     def isEmpty(self):
         return self.items == []

     def push(self, item):
         self.items.append(item)

     def pop(self):
         return self.items.pop()

     def peek(self):
         return self.items[len(self.items)-1]

     def size(self):
         return len(self.items)


def translatepowerToFunCheck(expression):
    if "**" in expression:
    	expression=transferToFunctionSyntax(str(expression))
    	xform = expr.transformString(expression)[1:-1]
    	xform=xform.replace('[','(')
    	expression=xform.replace(']',')')
   	#print expression
    return expression

#expression="(A+B+((Z**(K)-1)/(Z-1))*(Z-1))"
expression="((Z**(K)-1)/(Z-1))*(Z-1)"
expression="(Z/2)*6<=Z"
expression="r6(_n2)>=(((2**-(_n2))*((2**_N1)*B))/2)"
#expressionChecking(expression)
def expressionChecking(expression):
    if '(((((((' not in str(expression):
        if "**" in str(expression):
            expression=translatepowerToFunCheck(str(expression))
		#p = getParser()
        parser = c_parser.CParser()
        #tree = p.parse_expression(expression)
        ast = parser.parse("void test(){"+str(expression)+";}")
        statement_temp=ast.ext[0].body.block_items[0]
        #expr_wff=eval(expressionCreator(tree)) 
        expr_wff = eval(expressionCreator_C(statement_temp))
        flag=False
        return expr2simplified(expr_wff,flag)
    else:
        return str(expression),False



#wff to Simplified Expression
def expr2simplified(e,flag):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        return op,flag
    else:
        if op in _infix_op and len(args)==2:
            expr1,flag=expr2simplified(args[0],flag)
            if flag==True:
                expr2,flag=expr2simplified(args[1],flag)
                flag=True
            else:
               expr2,flag=expr2simplified(args[1],flag)
            if op=='*' and expr_op(args[0])=='/':
                n,d=fraction(expr1)
                if gcd(d,expr2)!=1:
                   flag=True
            elif op=='/' and expr_op(args[0])=='*':
                n,d=fraction(expr2)
                if '*' not in str(expr1) and '/' not in str(expr1) and gcd(expr1,d)!=1:
                   flag=True
            if flag==True:
                expression= '(' + expr1+ op + expr2 +')' 
            else:
                expression= '((' + str(pow_to_mul(powsimp(expr1)))+ ')'+ op + '('+ str(pow_to_mul(powsimp(expr2)))+'))' 
            return expression,flag
        else:
            return op +'('+ ','.join(list(trim_p(expr2string1(x)) for x in args))+ ')',flag
        	

#Is Function and Return the name

#expression="(A+B+((Z**(K)-1)/(Z-1))*(Z-1))"
#expression="((((Z**(K)-1)/(Z-1))*(Z-1)))"

#expression="ForAll(Y+1,Exits(X==Y))"

#expression="(X<(Y+y))"
#expression="Rest(Z,Exists(K,((((Z**(K)-1)/(Z-1))*(Z-1)))))"
#expression="m1==((((Z**(K)-1)/(Z-1))*(Z-1)))"

def isFunction(expression):
	function=['ForAll','Or','And','Exists','Implies','Not']

	operators=['==','<=','>=','>','<','!=']
	if 'ForAll' in expression or 'Or' in expression or 'And' in expression or 'Exists' in  expression or 'Implies' in expression or 'Not' in expression:
		arg_list=extract_args(expression)
		arglist=""
		for arg in arg_list:
			if arglist=="":
				arglist='('+arg
			else:
				arglist+=','+arg
		arglist+=")"
		
		
		tem_expression=expression.replace(arglist,'')
		tem_expression=tem_expression.strip()
		
		if tem_expression in function:
			return tem_expression
		else:
			return None
	else:
		arg_list=extract_args(expression)
		arglist=""
		for arg in arg_list:
			if arglist=="":
				arglist='('+arg
			else:
				arglist+=','+arg
		arglist+=")"
		tem_expression=expression.replace(arglist,'')
		tem_expression=tem_expression.strip()
		if tem_expression=='':
			return expression
		else:
			status=False
			for operator in operators:
				if operator in tem_expression:
					status=True
			if status==True:
				return expression
			else:
				return None


#C parsing Function


"""

#C Function Class
#Plain Python object to store Information about Function
"""
class cFunctionclass(object):
    def __init__(self, functionname, returnType , inputvar, localvar):
            self.functionname = functionname
            self.inputvar = inputvar
            self.returnType = returnType
            self.localvar = localvar
    def getFunctionname(self):
        return self.methodname
    def getreturnType(self):
        return self.returnType
    def getInputvar(self):
        return self.inputvar
    def getLocalvar(self):
        return self.localvar



def programTransformation(function_body,functionMap,medthodname):

    generator = c_generator.CGenerator()   
   
    global break_count
    global continue_count
    global new_variable
    global dummyCount
    global count__VERIFIER_nondet
    
    new_variable={}
        
    #Handling Pointer
    
    #print('=========================1')
    
    #print '#######'
    #print(generator.visit(function_body))
    #print '#######'
    
    
    #statements= handlingPointer(function_body.block_items)
    
    #function_body.show()
    
    statements=function_body.block_items
        
    #Syntax translation of the function body
    
    #print ('#######1')
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print ('#######1')
        
    statements=syntaxTranslate(statements)
    
    #print('=========================2')

    #print('#######2')
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print('#######2')

    statements=arrangeEmptyStatement(statements)

    #print('#######3')
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print('#######3')
   
    #Convert Initiation to assignments   
    
    #print('=========================3')
    
    statements=construct_program(statements)
    
    #print('=========================4')
    
    #print('#######4')
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print('#######4')

    #print(generator.visit(c_ast.Compound(block_items=statements)))
    
    #Reconstruct Program by Removing assert,assume,error
    
    statements=reconstructPreDefinedFun(statements)
    
    #print('=========================5')
    
    pa_update_statements=copy.deepcopy(statements)
    
    #print('=========================6')
    
    pa_update_statements=removeEmptyIfLoop(pa_update_statements)
    
    #print('=========================7')
    
    pa_update_statements=change_var_name(pa_update_statements)
    
    #print('=========================8')
    #print '#######2'
    #print(generator.visit(c_ast.Compound(block_items=pa_update_statements)))
    #print '#######2' 
    
    
    #pa_update_statements = organizeDeclaration(pa_update_statements)
    
    #pa_update_statements = getVariablesInit(pa_update_statements)
    
    
    
    
    
    #print '#######3'
    #print(generator.visit(c_ast.Compound(block_items=pa_update_statements)))
    #print '#######3'
    
    #print '#######3'
    #print(generator.visit(c_ast.Compound(block_items=pa_update_statements)))
    #print '#######3'
        
    #Replace return by goto statement
    
    #print('=========================9')
        
    statements=remove_return(statements,functionMap[medthodname])
    
    #print('#######5')
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print('#######5')
    #print('=========================10')
        
    #Replace goto structured statement
        
    statements=gotoremoval(statements)
    
    #print('=========================11')
    
    #print('#######6')
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print('#######6')
        
    update_statements=[]
        
    #Add new variable
        
    for var in new_variable.keys():
    	if isBoolVariable( var )==True:
            #temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['_Bool'])), init=c_ast.Constant(type='_Bool', value=None), bitsize=None)
            temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
            update_statements.append(temp)
    	else:
    		temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
    		update_statements.append(temp)
        	
    for statement in statements:
    	update_statements.append(statement)
        	
    #print('#######7')
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print ('#######7')
      
      
    #Remove Empty If Loops  
    #print('=========================12')
    
    update_statements=removeEmptyIfLoop(update_statements)
    
    #print('=========================13')
        
    #Remove Dead Code
    
    #print('#######8')
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print('#######8')
    
    
    update_statements=removeDeadCode(update_statements)
    
    #print('=========================14')
    
    
    #print('#######9')
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print('#######9')
        
    #Simplify Conditions
        
    statements=simplifyProgram(update_statements)
    
    #print('=========================15')
    
    
    #print('#######10')
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print ('#######10')
    
    #Add Break Removal Modules
    
    
    break_map={}
    break_count=0
    continue_count=0
    
    statements=getBreakStmt(statements,break_map)
    
    #print('=========================16')
    
    #print('#######10')
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print('#######10')
    
    
    statements=changeConditionProgram(statements)
    
    #print('=========================17')
    
    
    #print('#######11')
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print('#######11')
    
        
    update_statements=[]
    
    for var in new_variable.keys():
    	if isBoolVariable( var )==True:
    	    	#temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['_Bool'])), init=c_ast.Constant(type='_Bool', value=None), bitsize=None)
            temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
            update_statements.append(temp)
    	else:
            temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
            update_statements.append(temp)
        	
    for statement in statements:
    	update_statements.append(statement)
    
    dummyCount=0
    
    #print('#######12')
    #print(generator.visit(c_ast.Compound(block_items=update_statements)))
    #print('#######12')
    #print('=========================18')
    
    statements=functionToAssignment(update_statements,functionMap)
    
    #print('=========================19')
    
    
    #print('#######13')
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print('#######13')
       
    update_statements=[]
    
    if dummyCount>0:
    	for x in range(0, dummyCount):
            temp=c_ast.Decl(name='_'+str(x+1)+'DUMMY', quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname='_'+str(x+1)+'DUMMY', quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
            update_statements.append(temp)
    for statement in statements:
    	update_statements.append(statement)
        
    #count__VERIFIER_nondet=0
    #print('#######14')
    #print(generator.visit(c_ast.Compound(block_items=update_statements)))
    #print('#######14')

    
    update_statements=getVariablesInit(update_statements)

    #print('#######15')
    #print(generator.visit(c_ast.Compound(block_items=update_statements)))
    #print('#######15')

    
    #print('=========================20')
    
    update_statements=change_var_name(update_statements)
    
    #print('=========================21')

    #print('#######16')
    #print(generator.visit(c_ast.Compound(block_items=update_statements)))
    #print('#######16')

    return update_statements,pa_update_statements


def isFunctionInExpression(statement):
    if type(statement) is c_ast.FuncCall:
        return True
    elif type(statement) is c_ast.BinaryOp:
        if isFunctionInExpression(statement.left) == True:
            return True
        elif isFunctionInExpression(statement.right) == True:
            return True
        else:
            return False
    return False






def organizeDeclaration(update_statements):
    statements=[]
    del_statements=[]
    other_statements=[]
    array_del_statements=[]
    other_del_statements=[]
    duplicate_map={}
    
    for statement in update_statements:
        if type(statement) is c_ast.Decl:
            if isFunctionInExpression(statement.init)==False:
                if type(statement.type) is not c_ast.ArrayDecl:
                    if statement.name not in duplicate_map.keys():
                        duplicate_map[statement.name]=statement.name
                        del_statements.append(statement)
                    else:
                        if statement.init is not None:
                            other_statements.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=statement.name), rvalue=statement.init))
                else:
                    
                    del_statements.append(statement)
            else:
                if statement.name=='MAX' and type(statement.init) is c_ast.FuncCall and statement.init.name.name=='__VERIFIER_nondet_uint':
                    other_del_statements.append(statement)
                else:
                    other_statements.append(statement)
        else:
            other_statements.append(statement)
    for statement in del_statements:
        if type(statement.type) is c_ast.ArrayDecl:
            array_del_statements.append(statement)
        else:
            other_del_statements.append(statement)
    for statement in other_del_statements:
        statements.append(statement)
    for statement in array_del_statements:
        statements.append(statement)
    for statement in other_statements:
        statements.append(statement)
    return statements
    

def organizeInnerDeclartionMain(statements):
    update_statements=[]
    update_statements1=[]
    dec_statements=[]
    for statement in statements:
        if type(statement) is c_ast.If:
            update_statements.append(organizeInnerDeclartionIf(statement,dec_statements))
        elif type(statement) is c_ast.While:
            update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=organizeInnerDeclartion(statement.stmt.block_items,dec_statements))))
        else:
            update_statements.append(statement)
    for statement in dec_statements:
        update_statements1.append(statement)
    for statement in update_statements:
        update_statements1.append(statement)
    return update_statements1
 
    
def organizeInnerDeclartion(statements,dec_statements):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Decl:
            dec_statements.append(statement)
        elif type(statement) is c_ast.If:
            update_statements.append(organizeInnerDeclartionIf(statement,dec_statements))
        elif type(statement) is c_ast.While:
            update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=organizeInnerDeclartion(statement.stmt.block_items,dec_statements))))
        else:
            update_statements.append(statement)  
    return update_statements
            
            
def organizeInnerDeclartionIf(statement,dec_statements):
    If_stmt=None
    Else_stmt=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            new_block_temp=organizeInnerDeclartion(statement.iftrue.block_items,dec_statements)
            If_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            If_stmt=statement.iftrue
    if type(statement.iffalse) is c_ast.Compound:
        if statement.iffalse.block_items is not None:
            new_block_temp=organizeInnerDeclartion(statement.iffalse.block_items,dec_statements)
            Else_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            Else_stmt=statement.iffalse
    else:
        if type(statement.iffalse) is c_ast.If:
            Else_stmt=organizeInnerDeclartionIf(statement.iffalse,dec_statements)
        else:
            Else_stmt=statement.iffalse
    return c_ast.If(cond=statement.cond, iftrue=If_stmt, iffalse=Else_stmt)



def blockConstructExtract(statements,list,seq_list):
    #print statements
    for statement in statements:
        if type(statement) is c_ast.UnaryOp:
            line_no,list = findInList(statement,list,seq_list)
            if line_no is not None:
                seq=[]
                seq.append(line_no)
                seq.append(programPrint(syntaxTranslateStmt(statement)))
                seq_list.append(seq)
        elif type(statement) is c_ast.For:
            if type(statement.init) is c_ast.DeclList:
                for stmt in statement.init.decls:
                    line_no,list = findInList(stmt,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(stmt))
                        seq_list.append(seq)
            else:
                line_no,list = findInList(statement.init,list,seq_list)
                if line_no is not None:
                    seq=[]
                    seq.append(line_no)
                    seq.append(programPrint(statement.init))
                    seq_list.append(seq)
            if type(statement.stmt) is c_ast.Compound:
                new_block_items=statement.stmt.block_items
                if new_block_items is None:
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(statement.cond))
                        seq_list.append(seq)
                    new_block_items=[]
                    new_block_items.append(statement.next)
                    blockConstructExtract(new_block_items,list,seq_list)
                else:
                    line_no,list = findInList(statement.cond,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(syntaxTranslateStmt(statement.cond)))
                        seq_list.append(seq)
                    new_block_items=[]
                    new_block_items.append(statement.stmt)
                    new_block_items.append(statement.next)
                    blockConstructExtract(new_block_items,list,seq_list)
            else:
                
                if type(statement.stmt) is not c_ast.EmptyStatement:
                    line_no,list = findInList(statement.cond,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(syntaxTranslateStmt(statement.cond)))
                        seq_list.append(seq)
                    new_block_items=[]
                    new_block_items.append(statement.stmt)
                    new_block_items.append(statement.next)
                    blockConstructExtract(new_block_items,list,seq_list)
        
        elif type(statement) is c_ast.If:

            blockConstructExtractIf(statement,list,seq_list)
        
        elif type(statement) is c_ast.DoWhile:
            if type(statement.stmt) is c_ast.Compound:
                new_block_items=statement.stmt.block_items
                if new_block_items is None:
                    new_block_items=[]
                line_no,list = findInList(statement.cond,list,seq_list)
                if line_no is not None:
                    seq=[]
                    seq.append(line_no)
                    seq.append(programPrint(syntaxTranslateStmt(statement.cond)))
                    seq_list.append(seq)
                blockConstructExtract(new_block_items,list,seq_list)
    
            else:
                new_block_items=[]
                new_block_items.append(statement.stmt)
                line_no,list = findInList(statement.cond,list,seq_list)
                if line_no is not None:
                    seq=[]
                    seq.append(line_no)
                    seq.append(programPrint(statement.cond))
                    seq_list.append(seq)
                blockConstructExtract(new_block_items,list,seq_list)
        elif type(statement) is c_ast.While:
            if type(statement.stmt) is c_ast.Compound:
                line_no,list = findInList(statement.cond,list,seq_list)
                if line_no is not None:
                    seq=[]
                    seq.append(line_no)
                    seq.append(programPrint(syntaxTranslateStmt(statement.cond)))
                    seq_list.append(seq)
                blockConstructExtract(statement.stmt.block_items,list,seq_list)
            else:
                line_no,list = findInList(statement.cond,list,seq_list)
                if line_no is not None:
                    seq=[]
                    seq.append(line_no)
                    seq.append(programPrint(syntaxTranslateStmt(statement.cond)))
                    seq_list.append(seq)
                new_block_items=[]
                new_block_items.append(statement.stmt)
                blockConstructExtract(new_block_items,list,seq_list)
        elif type(statement) is c_ast.Assignment:
            if statement.op=='+=':
                if type(statement.lvalue) is c_ast.ID:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='+', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue)))) 
                        seq_list.append(seq)            
                else:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='+', left=statement.lvalue, right=statement.rvalue))))
                        seq_list.append(seq)
            elif statement.op=='-=':
                if type(statement.lvalue) is c_ast.ID:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='-', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue))))
                        seq_list.append(seq)
                else:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='-', left=statement.lvalue.name, right=statement.rvalue))))
                        seq_list.append(seq)
            elif statement.op=='/=':
                if type(statement.lvalue) is c_ast.ID:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='/', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue))))
                        seq_list.append(seq)
                else:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='/', left=statement.lvalue, right=statement.rvalue))))
                        seq_list.append(seq)
            elif statement.op=='%=':
                if type(statement.lvalue) is c_ast.ID:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='%', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue))))
                        seq_list.append(seq)
                else:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='%', left=statement.lvalue, right=statement.rvalue))))
                        seq_list.append(seq)
            elif statement.op=='*=':
                if type(statement.lvalue) is c_ast.ID:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='*', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue))))
                        seq_list.append(seq)
                else:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='*', left=statement.lvalue, right=statement.rvalue))))
                        seq_list.append(seq)
                	
            else:
                if type(statement.rvalue) is c_ast.Assignment:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        stmts=[]
                        separateAllAssignment(statement,stmts)
                        for stmt in stmts:
                            seq=[]
                            seq.append(line_no)
                            seq.append(programPrint(syntaxTranslateStmt(stmt)))
                            seq_list.append(seq)
                else:
                    line_no,list = findInList(statement,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(c_ast.Assignment(op=statement.op, lvalue=statement.lvalue, rvalue=statement.rvalue)))
                        seq_list.append(seq)
                
        elif type(statement) is c_ast.ExprList:
                blockConstructExtract(statement.exprs,list,seq_list)
        elif type(statement) is c_ast.Label:
            if type(statement.stmt) is c_ast.Compound:
                blockConstructExtract(statement.block_items,list,seq_list)
            else:
                if statement.stmt is not None:
                    line_no,list = findInList(statement.stmt,list,seq_list)
                    if line_no is not None:
                        seq=[]
                        seq.append(line_no)
                        seq.append(programPrint(syntaxTranslateStmt(statement.stmt)))
                        seq_list.append(seq)
        elif type(statement) is c_ast.Compound:
            blockConstructExtract(statement.block_items,list,seq_list)
        else:
            line_no,list = findInList(statement,list,seq_list)
            if line_no is not None:
                seq=[]
                seq.append(line_no)
                seq.append(programPrint(syntaxTranslateStmt(statement)))
                seq_list.append(seq)
                




def blockConstructExtractIf(statement,list,seq_list):
	if type(statement) is c_ast.If:
                line_no,list = findInList(statement.cond,list,seq_list)
                if line_no is not None:
                    seq=[]
                    seq.append(line_no)
                    seq.append(programPrint(syntaxTranslateStmt(statement.cond)))
                    seq_list.append(seq)
                if type(statement.iftrue) is c_ast.Compound:
                    if statement.iftrue.block_items is not None:
                        blockConstructExtract(statement.iftrue.block_items,list,seq_list)
                else:
                        if type(statement.iftrue) is c_ast.UnaryOp:
                                line_no,list = findInList(statement.iftrue,list,seq_list)
                                if line_no is not None:
                                    seq=[]
                                    seq.append(line_no)
                                    seq.append(programPrint(syntaxTranslateStmt(syntaxTranslateStmt(statement.iftrue))))
                                    seq_list.append(seq)
                        elif type(statement.iftrue) is c_ast.BinaryOp:
                                line_no,list = findInList(statement.iftrue,list,seq_list)
                                if line_no is not None:
                                    seq=[]
                                    seq.append(line_no)
                                    seq.append(programPrint(syntaxTranslateStmt(syntaxTranslateStmt(statement.iftrue))))
                                    seq_list.append(seq)
                        else:
                                    new_blocks=[]
                                    new_blocks.append(statement.iftrue)
                                    blockConstructExtract(new_blocks,list,seq_list)
				
                if type(statement.iffalse) is c_ast.Compound:
                    if statement.iffalse.block_items is not None:
                        blockConstructExtract(statement.iffalse.block_items,list,seq_list)
                else:
                    if type(statement.iffalse) is c_ast.If:
                        blockConstructExtractIf(statement.iffalse,list,seq_list)
                    else:
                        if type(statement.iffalse) is c_ast.UnaryOp:
                                        line_no,list = findInList(statement.iffalse,list,seq_list)
                                        if line_no is not None:
                                            seq=[]
                                            seq.append(line_no)
                                            seq.append(programPrint(syntaxTranslateStmt(statement.iffalse)))
                                            seq_list.append(seq)
                        elif type(statement.iffalse) is c_ast.BinaryOp:
                                        line_no,list = findInList(statement.iffalse,list,seq_list)
                                        if line_no is not None:
                                            seq=[]
                                            seq.append(line_no)
                                            seq.append(programPrint(syntaxTranslateStmt(statement.iffalse)))
                                            seq_list.append(seq)
                        else:
                                        new_blocks=[]
                                        new_blocks.append(statement.iffalse)
                                        new_iffalse=c_ast.Compound(block_items=syntaxTranslate(new_blocks))
	


def findInList(x,list,seq_list):
    z=None
    line_no=None
    for y in list:
        if getSpaceRemoveStr(programPrint(x)) in getSpaceRemoveStr(y[1]) and 'extern void __VERIFIER_error()' not in y[1] :
            z=y
            break;
    if z is not None:
        z[1]=getSpaceRemoveStr(z[1]).replace(getSpaceRemoveStr(programPrint(x)),'',1)
        line_no = z[0]
    return line_no,list


def findInList1(x,list,seq_list):
    z=None
    line_no=None
    for y in list:
        if getSpaceRemoveStr(x) in getSpaceRemoveStr(y[1]):
            z=y
            break;
    if z is not None:
        z[1]=getSpaceRemoveStr(z[1]).replace(getSpaceRemoveStr(x),'',1)
        line_no = z[0]
    return line_no,list
    
            


			    


def constructLineStmtmap(original_program,program):
    lines_map={}
    lines_list=[]
    count=0
    parser = GnuCParser()
    ast = parser.parse(program)
    lines_stmt=original_program.split('\n')

    for x in lines_stmt:
        count=count+1
        each_line=[]
        each_line.append(count)
        each_line.append(x)
        lines_list.append(each_line)
    for e in ast.ext:
        if type(e) is c_ast.Decl:
            if type(e.type) is c_ast.TypeDecl:
                line_no,lines_list=findInList(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=e.type.declname), rvalue=e.init),lines_list,'_GLOBAL')
                if line_no is not None:
                   lines_map[programPrint(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=e.type.declname), rvalue=e.init))]=int(line_no)
            elif type(e.type) is c_ast.ArrayDecl:
                line_no,lines_list=findInList(e,lines_list,'_GLOBAL')
                if line_no is not None:
                   lines_map[programPrint(e)]=int(line_no)
            else:
                line_no,lines_list=findInList(e,lines_list,'_GLOBAL')
                if line_no is not None:
                    lines_map[programPrint(e)]=int(line_no)
        else:
            if type(e) is c_ast.FuncDef:
                function_body = e.body
                seq_list=[]
                if function_body.block_items is not None:
                     blockConstructExtract(function_body.block_items,lines_list,seq_list)
                     lines_map[e.decl.name]= seq_list

    line_no,lines_list = findInList1('__VERIFIER_error();',lines_list,seq_list)
    if line_no is not None:
        lines_map['__VERIFIER_error();']=int(line_no)

    line_no,lines_list = findInList1('if (!(cond)) {',lines_list,seq_list)
    if line_no is not None:
        lines_map['if (!(cond)) {']=int(line_no)
    return lines_map









def getTheFileName(filename):
    if filename is not None:
        if '/' in filename:
            filenames=filename.strip()
            names=filename.split('/')
            return names[-1]
        else:
            return filename





#Get All Struct Variables

def updatePointerStruct(statements,struct_map):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Decl:
            if type(statement.type.type) is c_ast.Struct:
                if statement.type.type.name in struct_map.keys():
                    structobject=struct_map[statement.type.type.name]
                    if structobject.getIsPointer()==True:
                        statement=c_ast.Decl(name=statement.name, quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.PtrDecl(quals=[], type=statement.type), init=statement.init, bitsize=statement.bitsize)
                        update_statements.append(statement)
                    else:
                        update_statements.append(statement)
                else:
                    update_statements.append(statement)
            else:
                update_statements.append(statement)
        elif type(statement) is c_ast.Assignment:
            if type(statement.rvalue) is c_ast.Cast:
                if type(statement.rvalue.to_type.type.type) is c_ast.Struct:
                    if statement.rvalue.to_type.type.type.name in struct_map.keys():
                        structobject=struct_map[statement.rvalue.to_type.type.type.name]
                        if structobject.getIsPointer()==True:
                            stmt=c_ast.Typename(name = statement.rvalue.to_type.name, quals = statement.rvalue.to_type.quals, type=c_ast.PtrDecl(quals=[], type=statement.rvalue.to_type.type))
                            update_statements.append(c_ast.Assignment(op=statement.op,lvalue=statement.lvalue,rvalue=c_ast.Cast(to_type=stmt, expr=statement.rvalue.expr)))
                        else:
                            update_statements.append(statement)
                    else:
                        update_statements.append(statement)
                else:
                    update_statements.append(statement)
            else:
                update_statements.append(statement)
        elif type(statement) is c_ast.While:
            stmts = updatePointerStruct(statement.stmt.block_items,struct_map)
            statement=c_ast.While(cond=statement.cond, stmt=c_ast.Compound(block_items=stmts))
            update_statements.append(statement)
        elif type(statement) is c_ast.If:
            update_statements.append(updatePointerStructIf(statement,struct_map))
        else:
            update_statements.append(statement)

    return update_statements
            
            

def declarationModifying(statement):
    if type(statement.type) is c_ast.PtrDecl:
        degree=0
        parser = c_parser.CParser()
        type_stmt,degree,structType=getArrayDetails(statement,degree)
        program_temp=type_stmt+' '+ statement.name
        for x in range(0,degree):
            program_temp+='[]'
        pointer=statement.name
        program_temp+=';'
        temp_ast = parser.parse(program_temp)
        return temp_ast.ext[0]
    else:
        return None









def updatePointerStructIf(statement,struct_map):
    If_stmt=None
    Else_stmt=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            new_block_temp=updatePointerStruct(statement.iftrue.block_items,struct_map)
            If_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            If_stmt=statement.iftrue
    if type(statement.iffalse) is c_ast.Compound:
        if statement.iffalse.block_items is not None:
            new_block_temp=updatePointerStruct(statement.iffalse.block_items,struct_map)
            Else_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            Else_stmt=statement.iffalse
    else:
        if type(statement.iffalse) is c_ast.If:
            Else_stmt=updatePointerStructIf(statement.iffalse,struct_map)
        else:
            Else_stmt=statement.iffalse
    return c_ast.If(cond=statement.cond, iftrue=If_stmt, iffalse=Else_stmt)






def translateStruct(statements,variable_map,struct_map):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Assignment:
            statement=c_ast.Assignment(op=statement.op,lvalue=translateStructStmt(statement.lvalue,variable_map,struct_map), rvalue=translateStructStmt(statement.rvalue,variable_map,struct_map))
            update_statements.append(statement)
        elif type(statement) is c_ast.While:
            cond=translateStructStmt(statement.cond,variable_map,struct_map)
            stmts=translateStruct(statement.stmt.block_items,variable_map,struct_map)
            statement=c_ast.While(cond=cond, stmt=c_ast.Compound(block_items=stmts))
            update_statements.append(statement)
        elif type(statement) is c_ast.If:
            update_statements.append(translateStructIf(statement,variable_map,struct_map))
        else:
             update_statements.append(statement)
    return update_statements
            

def translateStructIf(statement,variable_map,struct_map):
    If_stmt=None
    Else_stmt=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            new_block_temp=translateStruct(statement.iftrue.block_items,variable_map,struct_map)
            If_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            If_stmt=statement.iftrue
    if type(statement.iffalse) is c_ast.Compound:
        if statement.iffalse.block_items is not None:
            new_block_temp=translateStruct(statement.iffalse.block_items,variable_map,struct_map)
            Else_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            Else_stmt=statement.iffalse
    else:
        if type(statement.iffalse) is c_ast.If:
            Else_stmt=translateStructIf(statement.iffalse,variable_map,struct_map)
        else:
            Else_stmt=statement.iffalse
    return c_ast.If(cond=translateStructStmt(statement.cond,variable_map,struct_map), iftrue=If_stmt, iffalse=Else_stmt)





def translateStructStmt(statement,variable_map,struct_map):
    if type(statement) is c_ast.BinaryOp:
        return c_ast.BinaryOp(op=statement.op, left=translateStructStmt(statement.left,variable_map,struct_map), right=translateStructStmt(statement.right,variable_map,struct_map))
    elif type(statement) is c_ast.FuncCall:
        para_list=[]
        if statement.args is not None:
            for para_meter in statement.args.exprs:
                para_list.append(translateStructStmt(para_meter,variable_map,struct_map))
            return c_ast.FuncCall(name=statement.name, args=c_ast.ExprList(exprs=para_list))
        else:
            return statement
    elif type(statement) is c_ast.StructRef:
        if type(statement.name) is c_ast.ID and type(statement.field) is c_ast.ID:
            if statement.name.name in variable_map.keys():
                variable=variable_map[statement.name.name]
                struct_name=variable.getStructType()
                if struct_name is not None:
                    para_list=[]
                    para_list.append(statement.name)
                    return c_ast.FuncCall(name=c_ast.ID(name=struct_name+"_"+statement.field.name), args=c_ast.ExprList(exprs=para_list))
                    #return c_ast.FuncCall(name=c_ast.ID(name=struct_name+"_"+statement.field.name), args=c_ast.ParamList(params=ExprList(exprs=para_list)))
        elif type(statement.name) is c_ast.ArrayRef and type(statement.field) is c_ast.ID:
            s_array_name=getArrayName(statement.name)
            if s_array_name in variable_map.keys():
                variable=variable_map[s_array_name]
                struct_name=variable.getStructType()
                if struct_name is not None:
                    para_list=[]
                    para_list.append(statement.name)
                    return c_ast.FuncCall(name=c_ast.ID(name=struct_name+"_"+statement.field.name), args=c_ast.ExprList(exprs=para_list))
        else:
            return statement
    elif type(statement) is c_ast.Cast:
        if type(statement.to_type.type) is c_ast.PtrDecl:
            if type(statement.to_type.type.type.type) is c_ast.Struct:
                if type(statement.expr) is c_ast.FuncCall and statement.expr.name.name =='malloc':
                    if type(statement.expr.args.exprs[0]) is c_ast.UnaryOp and statement.expr.args.exprs[0].op == 'sizeof':
                        if statement.expr.args.exprs[0].expr.type.type.name in struct_map.keys():
                            structobject=struct_map[statement.expr.args.exprs[0].expr.type.type.name]
                            return c_ast.ID(name='_Address_Block_Type_'+statement.expr.args.exprs[0].expr.type.type.name)
                        else:
                            return c_ast.ID(name='_Address_Block_Type_'+statement.expr.args.exprs[0].expr.type.type.name)
                    else:
                        return statement
                else:
                    return statement
            else:
                return statement

        else:
            if type(statement.to_type.type.type) is c_ast.Struct:
                if type(statement.expr) is c_ast.FuncCall and statement.expr.name.name =='malloc':
                    if type(statement.expr.args.exprs[0]) is c_ast.UnaryOp and statement.expr.args.exprs[0].op == 'sizeof':
                        if statement.expr.args.exprs[0].expr.type.name in struct_map.keys():
                            if statement.expr.args.exprs[0].expr.type.name in struct_map.keys():
                                if statement.expr.args.exprs[0].expr.type.type.name in struct_map.keys():
                                    structobject=struct_map[statement.expr.args.exprs[0].expr.type.name]
                                    return c_ast.ID(name='_Address_Block_Type_'+statement.expr.args.exprs[0].expr.type.name)
                                else:
                                    return c_ast.ID(name='_Address_Block_Type_'+statement.expr.args.exprs[0].expr.type.name)
                            else:
                                return statement
                        else:
                            return statement
                    else:
                            return statement
                else:
                     return statement
            else:
                if type(statement.to_type.type.type) is c_ast.IdentifierType:
                    if 'char' in statement.to_type.type.type.names:
                        if type(statement.expr) is c_ast.Constant and statement.expr.type=='int':
                            return statement.expr
                        else:
                            #return statement
                            return statement.expr
                    elif 'int' in statement.to_type.type.type.names:
                        if type(statement.expr) is c_ast.Constant and statement.expr.type=='int':
                            return statement.expr
                        else:
                            #return statement
                            return statement.expr
                    elif 'short' in statement.to_type.type.type.names:
                        if type(statement.expr) is c_ast.Constant and statement.expr.type=='int':
                            return statement.expr
                        else:
                            #return statement
                            return statement.expr
                    elif 'long' in statement.to_type.type.type.names:
                        if type(statement.expr) is c_ast.Constant and statement.expr.type=='int':
                            return statement.expr
                        else:
                            #return statement
                            return statement.expr
                    else:
                        return statement
                else:
                    return statement
    else:
        return statement


#def substitution_process(programgraph_map):
    
def removeCycles(f_list,cycle_list):
    new_f_list=[]
    for vertex in f_list:
        if vertex not in cycle_list:
            new_f_list.append(vertex)
    return new_f_list

def getSinks(programgraph_map):
    sink_list=[]
    for vertex in programgraph_map:
        if len(programgraph_map[vertex])==0:
            sink_list.append(vertex)
    return sink_list


def function_substitution_test(methodname,programgraph_map,f_map,o_map,a_map,assert_map,assume_map,cycle_list):
    if methodname in programgraph_map.keys():
        list_of_dests=programgraph_map[methodname]
        if len(list_of_dests)>0:
            for dests in list_of_dests:
                if dests not in cycle_list:
                    #print '$$$$$$$$$$$$$$$$$@@@@@@@@@@@@@@'
                    #print dests
                    #print '$$$$$$$$$$$$$$$$$@@@@@@@@@@@@@@'
                    function_substitution_test(dests,programgraph_map,f_map,o_map,a_map,assert_map,assume_map,cycle_list)
            f,o,a,assert_list,assume_list=function_substitution_main(f_map[methodname],o_map[methodname],a_map[methodname],assert_map[methodname],assume_map[methodname],f_map,o_map,a_map,assert_map,assume_map,cycle_list)
            f_map[methodname]=f
            o_map[methodname]=o
            a_map[methodname]=a
            assert_map[methodname]=assert_list
            assume_map[methodname]=assume_list
            #print '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'
            #print assert_map
            #print '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'
            del programgraph_map[methodname]
            

        


fun_count=0

sub_vfact=[]

external_var_map={}

fun_substitution_map={}

def function_substitution_main(f,o,a,assert_list,assume_list,f_map,o_map,a_map,assert_map,assume_map,cycle_list):
    new_a=[]
    new_o={}
    for x in o:
        if o[x][0]=='e':
            new_stmts=[]
            ret_term=function_substitution(o[x][2],assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
            if len(new_stmts)>0:
                for y in new_stmts:
                    new_a.append(y)
            if ret_term is not None:
                o[x][2]=ret_term
        new_o[x]=o[x]
    for x in a:
        new_stmts=[]
        if x[0]=='i1':
            ret_term=function_substitution(x[4],assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
            if 'DUMMY' in x[3][0]:
                function_substitution_dummy_assert(x[4],assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
            else:
                if len(new_stmts)>0:
                    for y in new_stmts:
                        new_a.append(y)
                if ret_term is not None:
                    x[4]=function_substitution(x[4],assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
                    new_a.append(x)
        elif x[0]=='i0':
            ret_term=function_substitution(x[3],assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
            if len(new_stmts)>0:
                for y in new_stmts:
                    new_a.append(y)
            if ret_term is not None:
                x[3]=ret_term
                new_a.append(x)
        elif x[0]=='s0' or x[0]=='s1' :
            ret_term=function_substitution(x[1],assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
            if len(new_stmts)>0:
                for y in new_stmts:
                    new_a.append(y)
            if ret_term is not None:
                x[1]=ret_term
                new_a.append(x)
        else:
            new_a.append(x)
    return f,new_o,new_a,assert_list,assume_list



def function_substitution_main_Assert(assert_list,f_map,o_map,a_map,cycle_list):
    new_assert_list=[]
    for x in assert_list:
        if x[0]=='c1' or x[0]=='s0' or x[0]=='s1':
            ret_term=function_substitution_Assert(x[1],f_map,o_map,a_map,cycle_list)
            if ret_term is not None:
                x[1]=ret_term
                new_assert_list.append(x)
            else:
                new_assert_list.append(x)
        else:
            new_assert_list.append(x)
    return new_assert_list


def function_substitution(e,assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list):
    global fun_substitution_map
    global LC
    args=expr_args(e)
    op=expr_op(e)
    fun_name=fun_matching(op)
    if len(args)==0:
        #if op in f_map.keys():
        if fun_name in f_map.keys() and fun_name not in cycle_list:
            for x in  assert_map[fun_name]:
                assert_list.append(x)
            for x in  assume_map[fun_name]:
                assume_list.append(x)
            if 'RET' in o_map[fun_name].keys():
                ret_stmt = o_map[fun_name]['RET']
                if len(a_map[fun_name])>0 and op not in fun_substitution_map.keys():
                    new_a=copy.deepcopy(a_map[fun_name])
                    if op not in fun_substitution_map.keys():
                        LC+=1
                        fun_substitution_map[op]=op
                    for x in new_a:
                        x = replace_fun_substitute(x,op,fun_count,temp)
                        new_stmts.append(x)
                return ret_stmt[2]
            else:
                return e
        else:
            return e
    else:
         if e[:1]==['and'] or e[:1]==['or'] or e[:1]==['not'] or e[:1]==['ite'] or op in _infix_op or isArrayFunction(op)==True:
            temp=[]
            for x in expr_args(e):
                parameter=function_substitution(x,assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
                if parameter is None:
                    temp.append(x)
                else:
                    temp.append(parameter)
            return e[:1]+temp
         #elif op in f_map.keys():
         elif fun_name in f_map.keys() and fun_name not in cycle_list:
            temp_assert_list=[]
            temp_assume_list=[]
            for x in  assert_map[fun_name]:
                temp_assert_list.append(x)
            for x in  assume_map[fun_name]:
                temp_assume_list.append(x) 
            temp=[]
            temp2=[]
            sub_map={}
            if 'RET' in o_map[fun_name].keys():
                #print '----------######----------'
                #print o_map[fun_name]
                #print '---------------------'
                #print fun_name
                #print '----------######----------'
                ret_stmt = o_map[fun_name]['RET']
                for x in expr_args(e):
                    parameter=function_substitution(x,assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
                    temp.append(parameter)
                for x in expr_args(ret_stmt[1]):
                    parameter=function_substitution(x,assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
                    temp2.append(parameter)
                if len(a_map[fun_name])>0 and op not in fun_substitution_map.keys():
                    new_a=copy.deepcopy(a_map[fun_name])
                    if op not in fun_substitution_map.keys():
                        LC+=1
                        fun_substitution_map[op]=op
                    for x in range(0,len(temp2)):
                        new_a=construct_a(temp2[x],temp[x],new_a,temp,op)
                    for x in new_a:
                        new_stmts.append(x)
                new_stmt=copy.deepcopy(ret_stmt[2])
                for x in range(0,len(temp2)):
                    new_stmt=expr_replace(new_stmt,temp2[x],temp[x])
                    for y in  temp_assert_list:
                        y[-1]=expr_replace(y[-1],temp2[x],temp[x])
                    for y in  temp_assume_list:
                        y[-1]=expr_replace(y[-1],temp2[x],temp[x])
                new_stmt = replace_fun_substitute(new_stmt,op,fun_count,temp)
                for x in  temp_assert_list:
                    assert_list.append(x)
                for x in  temp_assume_list:
                    assume_list.append(x)
                return new_stmt
            else:
                
                for x in expr_args(e):
                    parameter=function_substitution(x,assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list)
                    temp.append(parameter)
                #for x in expr_args(ret_stmt[1]):
                #    parameter=function_substitution(x,f_map,o_map,a_map,new_stmts)
                #    temp2.append(parameter)
                if len(a_map[fun_name])>0 and op not in fun_substitution_map.keys():
                    new_a=copy.deepcopy(a_map[fun_name])
                    if op not in fun_substitution_map.keys():
                        LC+=1
                        fun_substitution_map[op]=op
                    for x in range(0,len(temp2)):
                        new_a=construct_a(temp2[x],temp[x],new_a,temp,op)
                        for y in  temp_assert_list:
                            y[-1]=expr_replace(y[-1],temp2[x],temp[x])
                        for y in  temp_assume_list:
                            y[-1]=expr_replace(y[-1],temp2[x],temp[x])
                    for x in new_a:
                        new_stmts.append(x)
                    for x in  temp_assert_list:
                        assert_list.append(x)
                    for x in  temp_assume_list:
                        assume_list.append(x)
                return None
                
         else:
            return e[:1]+list(function_substitution(x,assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list) for x in expr_args(e))




def function_substitution_dummy_assert(e,assert_list,assume_list,f_map,o_map,a_map,new_stmts,assert_map,assume_map,cycle_list):
    global fun_substitution_map
    global LC
    args=expr_args(e)
    op=expr_op(e)
    fun_name=fun_matching(op)
    if op is 'ite':
            if args[1][0] in f_map.keys() and args[1][0] not in cycle_list:
                temp=[]
                temp2=[]
                parameters=expr_args(args[1])
                for parameter in parameters:
                    temp.append(parameter)
                for parameter in f_map[args[1][0]]:
                    temp2.append(eval("['"+parameter+"']"))
                temp_assert_list=[]
                temp_assume_list=[]
                for x in  assert_map[args[1][0]]:
                    temp_assert_list.append(x)
                for x in  assume_map[args[1][0]]:
                    temp_assume_list.append(x)
                    
                for x in range(0,len(temp2)):
                    for y in  temp_assert_list:
                        y[-1]=expr_replace(y[-1],temp2[x],temp[x])
                    for y in  temp_assume_list:
                        y[-1]=expr_replace(y[-1],temp2[x],temp[x])
                        
                for x in temp_assert_list:
                    assert_temp=[]
                    assert_temp.append('implies')
                    assert_temp.append(args[0])
                    assert_temp.append(x[-1])
                    x[-1]=assert_temp
                    assert_list.append(x)
                for x in temp_assume_list:
                    assume_temp=[]
                    assume_temp.append('implies')
                    assume_temp.append(args[0])
                    assume_temp.append(x[-1])
                    x[-1]=assert_temp
                    assert_list.append(x)
                    
            elif args[2][0] in f_map.keys() and args[2][0] not in cycle_list:
                temp=[]
                temp2=[]
                parameters=expr_args(args[2])
                for parameter in parameters:
                    temp.append(parameter)
                for parameter in f_map[args[2][0]]:
                    temp2.append(eval("['"+parameter+"']"))
                temp_assert_list=[]
                temp_assume_list=[]
                for x in  assert_map[args[2][0]]:
                    temp_assert_list.append(x)
                for x in  assume_map[args[2][0]]:
                    temp_assume_list.append(x)
                    
                for x in range(0,len(temp2)):
                    for y in  temp_assert_list:
                        y[-1]=expr_replace(y[-1],temp2[x],temp[x])
                    for y in  temp_assume_list:
                        y[-1]=expr_replace(y[-1],temp2[x],temp[x])
                        
                for x in temp_assert_list:
                    assert_temp=[]
                    assert_temp.append('Implies')
                    assert_temp.append(expr_complement(args[0]))
                    assert_temp.append(x[-1])
                    x[-1]=assert_temp
                    assert_list.append(x)
                for x in temp_assume_list:
                    assume_temp=[]
                    assume_temp.append('Implies')
                    assume_temp.append(expr_complement(args[0]))
                    assume_temp.append(x[-1])
                    x[-1]=assert_temp
                    assert_list.append(x)

#fun_name='avg_1'

def fun_matching(fun_name):
    fun_term=fun_name.split("_")
    if len(fun_term)==2:
        if is_number(fun_term[1])==True:
            return fun_term[0]
        else:
            return fun_name
    else:
        return fun_name




def function_substitution_Assert(e,f_map,o_map,a_map,cycle_list):
    global fun_count
    args=expr_args(e)
    op=expr_op(e)
    fun_name=fun_matching(op)
    if len(args)==0:
        #if op in f_map.keys():
        if fun_name in f_map.keys() and fun_name not in cycle_list:
            if 'RET' in o_map[fun_name].keys():
                ret_stmt = o_map[fun_name]['RET']
                return ret_stmt[2]
            else:
                return e
        else:
            return e
    else:
         if e[:1]==['and'] or e[:1]==['or'] or e[:1]==['not'] or e[:1]==['ite'] or op in _infix_op or isArrayFunction(op)==True:
            temp=[]
            for x in expr_args(e):
                parameter=function_substitution_Assert(x,f_map,o_map,a_map,cycle_list)
                temp.append(parameter)
            return e[:1]+temp
         #elif op in f_map.keys():
         elif fun_name in f_map.keys() and fun_name not in cycle_list:
            temp=[]
            temp2=[]
            sub_map={}
            if 'RET' in o_map[fun_name].keys():
                ret_stmt = o_map[fun_name]['RET']
                for x in expr_args(e):
                    parameter=function_substitution_Assert(x,f_map,o_map,a_map,cycle_list)
                    temp.append(parameter)
                for x in expr_args(ret_stmt[1]):
                    parameter=function_substitution_Assert(x,f_map,o_map,a_map,cycle_list)
                    temp2.append(parameter)
                new_stmt=copy.deepcopy(ret_stmt[2])
                for x in range(0,len(temp2)):
                    new_stmt=expr_replace(new_stmt,temp2[x],temp[x])
                new_stmt = replace_fun_substitute(new_stmt,op,fun_count,temp)
                return new_stmt
            else:
                return e
                
         else:
            return e[:1]+list(function_substitution_Assert(x,f_map,o_map,a_map,cycle_list) for x in expr_args(e))





def construct_a(e1,e2,a,input_list,f_name):
    global fun_count
    fun_count=fun_count+1
    new_a=[]
    for x in a:
        if x[0]=='i1':
            x[3]=expr_replace(x[3],e1,e2)
            x[3] = replace_fun_substitute(x[3],f_name,fun_count,input_list)
            x[4]=expr_replace(x[4],e1,e2)
            x[4] = replace_fun_substitute(x[4],f_name,fun_count,input_list)
        elif x[0]=='i0':
            x[2]=expr_replace(x[2],e1,e2)
            x[2] = replace_fun_substitute(x[2],f_name,fun_count,input_list)
            x[3]=expr_replace(x[3],e1,e2)
            x[3] = replace_fun_substitute(x[3],f_name,fun_count,input_list)
        elif x[0]=='s0' or x[0]=='s1':
            x[1]=expr_replace(x[1],e1,e2)
            x[1] = replace_fun_substitute(x[1],f_name,fun_count,input_list)
        new_a.append(x)
    return new_a




def replace_fun_substitute(e,f_name,count,input_list):
    global sub_vfact
    global external_var_map
    global LC
    args=expr_args(e)
    op=expr_op(e)
    if e in input_list:
        return e
    elif len(args)==0:
        if isvariable(op)==False and is_number(op)==False and op.startswith('_N') == False and op not in external_var_map.keys():
            #sub_vfact.append(f_name+str(count)+'_'+op)
            sub_vfact.append(f_name+'_'+op)
            #return eval("['"+f_name+str(count)+'_'+op+"']")
            if f_name+'_' in op:
                return eval("['"+op+"']")
            else:
                return eval("['"+f_name+'_'+op+"']")
        else:
            if isConstant(op):
                return eval("['"+'_N'+str(LC)+"']")
            elif isLoopvariable(op):
                return eval("['"+'_n'+str(LC)+"']")
            return e
    else:
        if e[:1]==['and'] or e[:1]==['or'] or e[:1]==['not'] or e[:1]==['ite'] or op in _infix_op or isArrayFunction(op)==True or e[:1]==['implies']:
            temp=[]
            for x in expr_args(e):
                temp.append(replace_fun_substitute(x,f_name,count,input_list))
            return e[:1]+list(temp)
        else:
            if isvariable(op)==False and op.startswith('_N') == False and op not in external_var_map.keys():
                #e[0]=f_name+str(count)+'_'+op
                if f_name+'_' in op:
                    e[0]=op
                else:
                    e[0]=f_name+'_'+op
                #sub_vfact.append(f_name+str(count)+'_'+op)
                sub_vfact.append(f_name+'_'+op)
            else:
                if isConstant(op):
                    #e[:1]='_N'+str(LC)
                    return eval("['"+'_N'+str(LC)+"']")+list(replace_fun_substitute(x,f_name,count,input_list) for x in expr_args(e))
            return e[:1]+list(replace_fun_substitute(x,f_name,count,input_list) for x in expr_args(e))





    

def updateAxoimsRecurrences(f,o,a,f_list):    
    for x in o:
        if o[x][0]=='e':
            o[x][2] = updateAxoimsNameRec(o[x][2],f_list)
    for x in a:
        if x[0]=='e':
            x[2] = updateAxoimsNameRec(x[2],f_list)
    return f,o,a
        
        
def updateAxoimsNameRec(e,f_list):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        return e
    else:
         if e[:1]==['and'] or e[:1]==['or'] or e[:1]==['not'] or e[:1]==['ite'] or op in _infix_op or isArrayFunction(op)==True:
            temp=[]
            for x in expr_args(e):
                parameter=updateAxoimsNameRec(x,f_list)
                temp.append(parameter)
            return e[:1]+temp
         elif isRecurrenceFun( op, f_list ) is not None:
            temp=[]
            for x in expr_args(e):
                parameter=updateAxoimsNameRec(x,f_list)
                temp.append(parameter)
            return eval("['"+isRecurrenceFun( op, f_list )+"']")+temp
         else:
            return e[:1]+list(updateAxoimsNameRec(x,f_list) for x in expr_args(e))






def organizeAxioms(f,o,a,vfacts):
    new_vfacts=[]
    array_list=[]
    new_f={}
    duplicate_map={}
    new_f={}
    new_o={}
    new_a=[]
    for [x,k,l] in vfacts:
        if k==0 and l[0]=='array' and isArrayFinal(x)==False and not(x=='main') and '_PROVE' not in x and '_ASSUME' not in x :
            array_list.append(x)
    for vfact in vfacts:
        if vfact[0] not in duplicate_map.keys():
            if '_ASSUME' not in vfact[0] and '_PROVE' not in vfact[0] and '__VERIFIER_assert' not in vfact[0]  : #and '_FAILED' not in vfact[0]
                duplicate_map[vfact[0]]=vfact[0]
                if isArrayFunction(vfact[0])==True:
                    if len(array_list)>0:
                        new_vfacts.append(vfact)
                else:
                    new_vfacts.append(vfact)
    #for e in f:
    #    if isArrayFunction(e)==True:
    #        if len(array_list)>0:
    #            new_f[e]=f[e]
    #    else:
    #        new_f[e]=f[e]
    #for e in o:
    #    if isArrayFunction(e)==True:
    #        if len(array_list)>0:
    #            new_o[e]=o[e]
    #    else:
    #        new_o[e]=o[e]
    #for e in a:
    #    if e[0]=='i1':
    #        if isArrayFunction(e[3][0])==True:
    #            if len(array_list)>0:
    #                new_a.append(e)
    #        else:
    #            new_a.append(e)
    #    elif e[0]=='i0':
    #        if isArrayFunction(e[2][0])==True:
    #            if len(array_list)>0:
    #                new_a.append(e)
    #        else:
    #            new_a.append(e)

    return f,o,a,new_vfacts


#Construct Graph To detect Recurences

def construct_graph(f_map,o_map,a_map,f_list):
    graph_map={}
    for fname in f_list:
        fnode_list=[]
        for x in f_map[fname]:
            getFunctionNameGraph(f_map[fname][x][2],f_list,fnode_list)
        for x in o_map[fname]:
            getFunctionNameGraph(o_map[fname][x][2],f_list,fnode_list)
        for x in a_map[fname]:
            if x[0]=='i1':
                getFunctionNameGraph(x[4],f_list,fnode_list)
            elif x[0]=='i0':
                getFunctionNameGraph(x[3],f_list,fnode_list)
            elif x[0]=='s0' or x[0]=='s1':
                getFunctionNameGraph(x[1],f_list,fnode_list)
        graph_map[fname]=fnode_list
    return graph_map

def getFunctionNameGraph(e,f_list,fnode_list):
    args=expr_args(e)
    op=expr_op(e)
    fun_name=fun_matching(op)
    if len(args)>0:
         if e[:1]==['and'] or e[:1]==['or'] or e[:1]==['not'] or e[:1]==['ite'] or op in _infix_op or isArrayFunction(op)==True:
            for x in expr_args(e):
                getFunctionNameGraph(x,f_list,fnode_list)
         elif fun_name in f_list:
            if fun_name not in fnode_list:
                fnode_list.append(fun_name)
            for x in expr_args(e):
                getFunctionNameGraph(x,f_list,fnode_list)


def reconstructRecurences(e,f_list):
    op=expr_op(e)
    args=expr_args(e)
    fun_name=None
    if len(args)>0:
        if e[:1]==['and'] or e[:1]==['or'] or e[:1]==['not'] or e[:1]==['ite'] or op in _infix_op or isArrayFunction(op)==True:
            fun_name=None
        else:
            fun_name=fun_matching(op)
        if fun_name is not None and fun_name in f_list:
            return eval("['"+fun_name+"']")+list(reconstructRecurences(x,f_list) for x in expr_args(e))
        else:
            return e[:1]+list(reconstructRecurences(x,f_list) for x in expr_args(e))
    else:
        return e
    
    
def reconstructRecurences2(e,f_list,f_name):
    op=expr_op(e)
    args=expr_args(e)
    fun_name=None
    if len(args)>0:
        if e[:1]==['and'] or e[:1]==['or'] or e[:1]==['not'] or e[:1]==['ite'] or op in _infix_op or isArrayFunction(op)==True:
            fun_name=None
        else:
            fun_name=fun_matching(op)
        if fun_name is not None and fun_name in f_list and f_name==fun_name:
            return eval("['"+fun_name+"']")+list(reconstructRecurences2(x,f_list) for x in expr_args(e))
        else:
            return e[:1]+list(reconstructRecurences2(x,f_list) for x in expr_args(e))
    else:
        return e




        
def extractFileName(filename):
    if filename is not None:
        filename_list=filename.strip().split('/')
        return filename_list[-1]
    return None



def processOutput1(outputs_list):
    value__VERIFIER_nondet_list=[]
    if len(outputs_list)>0:
        for output_list in outputs_list:
            if ':' in output_list and output_list.strip()!='':
                if '_PROVE' not in output_list and '_FAILED' not in output_list:
                    value__VERIFIER_nondet_list.append(output_list)
                else:
                    if '_PROVE' in output_list:
                        outputs_values = output_list.split(':')
                        if outputs_values[1]=='1':
                            return process__VERIFIER_nondet_list(value__VERIFIER_nondet_list)
                    elif '_FAILED' in output_list:
                        outputs_values = output_list.split(':')
                        if outputs_values[1]=='1':
                            return process__VERIFIER_nondet_list(value__VERIFIER_nondet_list)

























def process__VERIFIER_nondet_list(values__VERIFIER_nondet_list):
    value__VERIFIER_nondet_map={}
    for value__VERIFIER_nondet_list in values__VERIFIER_nondet_list:
        outputs_values = value__VERIFIER_nondet_list.split(':')
        key=outputs_values[0]+outputs_values[1]
        if key not in value__VERIFIER_nondet_map.keys():
            value__VERIFIER_nondet_map[key]=outputs_values
    return value__VERIFIER_nondet_map
        
    


#def processOutput(outputs_list):
#    map_asserts={}
#    value_others=None
#    for output_list in outputs_list:
#        if len(output_list)>1:
#            elements = output_list.split('\n')
#            temp_value_others,eval_value = getOtherValues(elements)
#            #print '%%%%%%%%%%%%%%%%%%%%%%%%%%%'
#            #print temp_value_others
#            #print '--------------------------'
#            #print eval_value
#            #print '%%%%%%%%%%%%%%%%%%%%%%%%%%%'
#            if temp_value_others is not None:
#                value_others=temp_value_others
#            if eval_value is not None and value_others is not None:
#                if '_PROVE' in eval_value and ':' in eval_value:
#                    element = eval_value.split(':')
#                    if int(element[1])==0:
#                        map_asserts[eval_value]=value_others
#                elif '_FAILED' in eval_value and ':' in eval_value:
#                    element = eval_value.split(':')
#                    if int(element[1])==1:
#                        map_asserts[eval_value]=value_others
#    return map_asserts



def processOutput(outputs_list):
    map_asserts={}
    for output_list in outputs_list:
        if len(output_list)>1:
            elements = output_list.split('\n')
            if '_PROVE' in elements[0] and ':' in elements[0]:
                element = elements[0].split(':')
                if int(element[1])==0:
                    map_asserts[elements[0]]=elements[1:]
            elif '_FAILED' in elements[0] and ':' in elements[0]:
                element = elements[0].split(':')
                if int(element[1])==1:
                    map_asserts[elements[0]]=elements[1:]
    return map_asserts

def getOtherValues(elements):
    otherelements=None
    eval_value=None
    for element in elements:
        if '_FAILED' not in element and '_PROVE' not in element and element.strip() !='':
            if otherelements is None:
                otherelements=[]
                otherelements.append(element)
            else:
                otherelements.append(element)
        elif '_FAILED' in element:
            eval_value=element 
        elif '_PROVE' in element:
            eval_value=element
    return otherelements,eval_value

    
def processOutputAssume(outputs_list):
    for output_list in outputs_list:
        if len(output_list)>1:
            elements = output_list.split('\n')
            if '_ASSUME' in elements[0] and ':' in elements[0]:
                element = elements[0].split(':')
                if int(element[1])==0:
                    return elements[1:]
    return None    








        
    




defineDetaillist=[] 
defineMap={}

 
 

 
 
 
 

count_for__VERIFIER_nondet=0
count_for__insert_flag=0
count_for__function_flag=0
line_count_trace=0
new_program_trace_var={}
back_line_no_stmt_map={}
main_line_no_stmt_ast_map={}
count_ast_line_no=0





def getLineNumber(stmt,fun_name):
    global back_line_no_stmt_map
    find_list=[]
    find_list_ast=[]
    
    value=None
    value1=None
    if fun_name is not None:
        z=None
        list=back_line_no_stmt_map[fun_name]
        for x in list:
            if getSpaceRemoveStr(stmt) in getSpaceRemoveStr(x[1]):
                z=x
                break;
        
        if z is not None:
            list.remove(z)
            back_line_no_stmt_map[fun_name]=list
            value=z[0]
            value1=z[1]

    else:
        z=None
        list=back_line_no_stmt_map.keys()
        for x in list:
            if getSpaceRemoveStr(stmt) in getSpaceRemoveStr(x):
                z=x
                break;
        if z is not None:
            value=back_line_no_stmt_map[z]
            value1=z
            del back_line_no_stmt_map[z]
    
    return value,value1





def getLineNumberAssert(stmt):
    global back_line_no_stmt_map
    find_list=[]
    find_list_ast=[]
    
    value=None
    value1=None
    z=None
    for y in back_line_no_stmt_map.keys():
        TEMP_LIST= back_line_no_stmt_map[y]
        if isinstance(TEMP_LIST,list)==True:
            
            TEMP_LIST=back_line_no_stmt_map[y]
            for x in TEMP_LIST:
                if getSpaceRemoveStr(stmt) in getSpaceRemoveStr(x[1]):
                    z=x
                    break;
            if z!=None:
                break;

    if z is not None:
        value=z[0]
        value1=z[1]
    
    return value,value1


def getLineNumber_terminate(stmt,fun_name):
    global line_no_stmt_map
    find_list=[]
    find_list_ast=[]
    
    value=None
    value1=None
    if fun_name is not None:
        z=None
        list=line_no_stmt_map[fun_name]
        for x in list:
            if getSpaceRemoveStr(stmt) in getSpaceRemoveStr(x[1]):
                z=x
                break;
        
        if z is not None:
            list.remove(z)
            line_no_stmt_map[fun_name]=list
            value=z[0]
            value1=z[1]

    else:
        z=None
        list=line_no_stmt_map.keys()
        for x in list:
            if getSpaceRemoveStr(stmt) in getSpaceRemoveStr(x):
                z=x
                break;
        if z is not None:
            value=line_no_stmt_map[z]
            value1=z
            del line_no_stmt_map[z]
    
    return value,value1








def more2equality(expression):
    count=0
    if "&&" not in expression and "||" not in expression and "<" not in expression and ">" not in expression:
        for x in expression:
            if x is '=':
                count+=1
        if count>2:
            return count
        else:
            return None
    return None
    
            

def getSpaceRemoveStr(expression):
    
    new_expression=''
    for x in expression:
        if x!=' ' and x!='' and x!='(' and x!=')' and x!='\n':
            new_expression+=x
    return new_expression
        




def getVariablesExcutionTrace(statement,all_variable_map):
    if type(statement) is c_ast.BinaryOp:
        getVariablesExcutionTrace(statement.left,all_variable_map)
        getVariablesExcutionTrace(statement.right,all_variable_map)
    elif type(statement) is c_ast.Assignment:
        getVariablesExcutionTrace(statement.lvalue,all_variable_map)
        getVariablesExcutionTrace(statement.rvalue,all_variable_map)
    elif type(statement) is c_ast.FuncCall:
        if statement.args is not None:
            for x in statement.args.exprs:
                getVariablesExcutionTrace(x,all_variable_map)
    elif type(statement) is c_ast.ID:
        key = programPrint(statement)
        if '_FAILED' not in key and '_PROVE' not in key:
            all_variable_map[key]=key
    elif type(statement) is c_ast.ArrayRef:
        key = programPrint(statement)
        if '_FAILED' not in key and '_PROVE' not in key:
            all_variable_map[key]=key
            




def line_count_ast_Block(statements):
    global main_count_ast_line_no
    global main_line_no_stmt_ast_map
    for statement in statements:
        if type(statement) is c_ast.While:
            main_count_ast_line_no+=1
            main_line_no_stmt_ast_map[main_count_ast_line_no]=programPrint(statement.cond)
            line_count_ast_Block(statement.stmt.block_items)
        elif type(statement) is c_ast.If:
            line_count_ast_If(statement)
        elif type(statement) is c_ast.Return:
            main_count_ast_line_no+=1
            main_line_no_stmt_ast_map[main_count_ast_line_no]=programPrint(statement)
        else:
            main_count_ast_line_no+=1
            main_line_no_stmt_ast_map[main_count_ast_line_no]=programPrint(statement)
            

            
def line_count_ast_If(statement):
    global main_count_ast_line_no
    global main_line_no_stmt_ast_map
    if type(statement) is c_ast.If:
         if type(statement.iftrue) is c_ast.Compound:
             main_count_ast_line_no+=1
             main_line_no_stmt_ast_map[main_count_ast_line_no]=programPrint(statement.cond)
             line_count_ast_Block(statement.iftrue.block_items)
         if type(statement.iffalse) is c_ast.Compound:
             line_count_ast_Block(statement.iffalse.block_items)
         elif type(statement.iffalse) is c_ast.If:
             line_count_ast_If(statement.iffalse)


def getVariablesExcutionTraceBlock(statements,all_variable_map):
    for statement in statements:
        if type(statement) is c_ast.Assignment:
            getVariablesExcutionTrace(statement,all_variable_map)
        elif type(statement) is c_ast.While:
            getVariablesExcutionTrace(statement.cond,all_variable_map)
            getVariablesExcutionTraceBlock(statement.stmt.block_items,all_variable_map)
        elif type(statement) is c_ast.If:
            getVariablesExcutionTraceIf(statement,all_variable_map)
        elif type(statement) is c_ast.Return:
            getVariablesExcutionTrace(statement.expr,all_variable_map)
            
def getVariablesExcutionTraceIf(statement,all_variable_map):
    if type(statement) is c_ast.If:
         if type(statement.iftrue) is c_ast.Compound:
             getVariablesExcutionTraceBlock(statement.iftrue.block_items,all_variable_map)
         if type(statement.iffalse) is c_ast.Compound:
             getVariablesExcutionTraceBlock(statement.iffalse.block_items,all_variable_map)
         elif type(statement.iffalse) is c_ast.If:
             getVariablesExcutionTraceIf(statement.iffalse,all_variable_map)
    


def constructExcutionTraceBlock(statements,all_variable_map,methodname,new_statements):
    global count_for__insert_flag
    global back_line_no_stmt_map
    global count_ast_line_no
    global main_count_ast_line_no
    prev_line_no=None
    update_statements=[]
    prev_line_no=None
    prev_stmt=None
    for statement in statements:
        if type(statement) is c_ast.Assignment:
            count_ast_line_no+=1
            line_no,stmt = getLineNumber(programPrint(statement),methodname)
            function_assgmt={}
            
            new_statement=getFunctionCallAssigment(statement,function_assgmt)
            
            
            if len(function_assgmt)>0:
                for x in function_assgmt:
                    new_program_trace_var[x]=x
                    arg_list1=[]
                    arg_list1.append(c_ast.Constant(type="string", value="\"FunctionCall:"+programPrint(statement)+":"+function_assgmt[x].rvalue.name.name+":"+programPrint(function_assgmt[x].rvalue)+":"+str(line_no)+""+"\\n\""))
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list1)))
                    
                    update_statements.append(function_assgmt[x])
                    
                    arg_list2=[]
                    arg_list2.append(c_ast.Constant(type="string", value="\"RecahCallPoint:"+":"+programPrint(function_assgmt[x].rvalue)+":"+str(line_no)+""+"\\n\""))
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list2)))
                    
                    

                update_statements.append(new_statement)
            else:
                update_statements.append(statement)
            
            getVariablesExcutionTrace(statement,all_variable_map)
            
            
            str_printf_stmt=None
            arg_list1=[]
            temp_arg_list1=[]
            for x in all_variable_map:
                if str_printf_stmt is None:
                    str_printf_stmt="\"assumption:"+x+"==%d;"
                    temp_arg_list1.append(x)
                else:
                    str_printf_stmt+=x+"==%d;"
                    temp_arg_list1.append(x)
            if str_printf_stmt is not None:
                str_printf_stmt+="\\n\""
                arg_list1.append(c_ast.Constant(type="string", value=str_printf_stmt))
                for x in temp_arg_list1:
                    arg_list1.append(c_ast.ID(name=x))
                update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list1)))
            

            if line_no==0 and stmt is None:
                line_no=prev_line_no
                stmt=prev_stmt

            if line_no>0 and stmt is not None:
                status = more2equality(expression)
                if status is not None:
                    prev_line_no=line_no
                    prev_stmt=stmt
                else:
                    prev_line_no=0
                    prev_stmt=None
                arg_list=[]
                #arg_list.append(c_ast.Constant(type="string", value="\"Assignment:"+programPrint(statement)+":"+stmt+":"+str(line_no)+"\\n\""))
                arg_list.append(c_ast.Constant(type="string", value="\"Assignment:"+programPrint(statement)+":"+stmt+":"+str(line_no)+"\\n\""))
                update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
                
    
                
            else:
                if ('_FAILED' in programPrint(statement.lvalue) or '_PROVE' in programPrint(statement.lvalue)) and type(statement.rvalue) is c_ast.Constant and statement.rvalue.value=='1':
                    arg_list=[]
                    arg_list.append(c_ast.Constant(type="string", value="\""+programPrint(statement.lvalue)+":%d\\n\""))
                    arg_list.append(statement.lvalue)
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
                elif '_PROVE' in programPrint(statement.lvalue) and type(statement.rvalue) is not c_ast.Constant :
                    arg_list=[]
                    arg_list.append(c_ast.Constant(type="string", value="\"__VERIFIER_assert("+programPrint(statement.rvalue)+"):%d\\n\""))
                    arg_list.append(statement.lvalue)
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
        elif type(statement) is c_ast.While:
            count_ast_line_no+=1
            arg_list=[]
            count_for__insert_flag=count_for__insert_flag+1
            ID_name='_con_flag'+str(count_for__insert_flag)
            update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='_con_flag'+str(count_for__insert_flag)),rvalue=statement.cond))
            new_program_trace_var['_con_flag'+str(count_for__insert_flag)]='_con_flag'+str(count_for__insert_flag)
            line_no,stmt = getLineNumber(programPrint(statement.cond),methodname)
            
            if line_no>0:
                arg_list.append(c_ast.Constant(type="string", value="\"WhileCondition:"+programPrint(statement.cond)+":"+str(line_no)+":%d"+"\\n\""))
                arg_list.append(c_ast.ID(name='_con_flag'+str(count_for__insert_flag)))
                
                update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
            
            temp_block = constructExcutionTraceBlock(statement.stmt.block_items,all_variable_map,methodname,new_statements)
            temp_block.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name=ID_name),rvalue=statement.cond))
            temp_block.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
            update_statements.append(c_ast.While(cond=c_ast.ID(name=ID_name), stmt=c_ast.Compound(block_items=temp_block)))
        elif type(statement) is c_ast.If:
            temp_stmt,list_of_con_ex_trace,list_of_con_ex_trace1 = constructExcutionTraceIf(statement,all_variable_map,None,methodname,new_statements)
            for x in list_of_con_ex_trace:
                update_statements.append(x)
                new_program_trace_var[x.lvalue.name]=x.lvalue.name
                #line_no,stmt = getLineNumber(programPrint(x.rvalue))
            for x in list_of_con_ex_trace1:
                update_statements.append(x)
            update_statements.append(temp_stmt)
        elif type(statement) is c_ast.Return:
            count_ast_line_no+=1
            line_no,stmt = getLineNumber(programPrint(statement),methodname)

            function_assgmt={}
            new_statement=getFunctionCallAssigment(statement.expr,function_assgmt)
            
            
            if len(function_assgmt)>0:
                
                t_all_variable_map={}
            
                if methodname=='main':
                    getVariablesExcutionTrace(statement,t_all_variable_map)
                else:
                    getVariablesExcutionTraceBlock(new_statements,t_all_variable_map)
                
                t_str_printf_stmt=None
                
                
                t_temp_arg_list1=[]
                    
                for x in t_all_variable_map:
                    if t_str_printf_stmt is None:
                        t_str_printf_stmt="\"essumption:"+x+"==%d;"
                        t_temp_arg_list1.append(x)
                    else:
                        t_str_printf_stmt+=x+"==%d;"
                        t_temp_arg_list1.append(x)
                
                for x in function_assgmt:
                    new_program_trace_var[x]=x
                    arg_list1=[]
                    arg_list1.append(c_ast.Constant(type="string", value="\"FunctionCall:#:"+function_assgmt[x].rvalue.name.name+":"+programPrint(function_assgmt[x].rvalue)+":"+str(line_no)+""+"\\n\""))
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list1)))
                    update_statements.append(function_assgmt[x])
                    
                    if t_str_printf_stmt is None:
                            t_str_printf_stmt="\"essumption:"+programPrint(function_assgmt[x].rvalue)+"==%d;"
                            t_temp_arg_list1.append(x)
                    else:
                            t_str_printf_stmt+=programPrint(function_assgmt[x].rvalue)+"==%d;"
                            t_temp_arg_list1.append(x)
                    
                    if t_str_printf_stmt is not None:
                        t_arg_list1=[]
                        t_arg_list1.append(c_ast.Constant(type="string", value=t_str_printf_stmt+"@"+programPrint(function_assgmt[x].rvalue)+"\\n\""))
                        for x in t_temp_arg_list1:
                            t_arg_list1.append(c_ast.ID(name=x))
                        update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=t_arg_list1)))
                
                
                
                
                if methodname=='main':
                    getVariablesExcutionTrace(statement,all_variable_map)
                else:
                    getVariablesExcutionTraceBlock(new_statements,all_variable_map)
                str_printf_stmt=None
                arg_list1=[]
                temp_arg_list1=[]
                for x in all_variable_map:
                    if str_printf_stmt is None and x!='':
                        str_printf_stmt="\"assumption:"+x+"==%d;"
                        temp_arg_list1.append(x)
                    else:
                        str_printf_stmt+=x+"==%d;"
                        temp_arg_list1.append(x)
                if str_printf_stmt is not None:
                    str_printf_stmt+="\\n\""
                    arg_list1.append(c_ast.Constant(type="string", value=str_printf_stmt))
                    for x in temp_arg_list1:
                        arg_list1.append(c_ast.ID(name=x))
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list1)))
                
                
                arg_list=[]
                

                #arg_list.append(c_ast.Constant(type="string", value="\"Return:"+methodname+":"+programPrint(statement.expr)+":"+str(line_no)+""+"\\n\""))
                if statement.expr is not None:
                    arg_list.append(c_ast.Constant(type="string", value="\"Return:"+programPrint(statement.expr)+":"+programPrint(statement.expr)+":"+methodname+":%d"+":"+str(line_no)+"\\n\""))
                    arg_list.append(new_statement)
                else:
                    arg_list.append(c_ast.Constant(type="string", value="\"Return:None:None:"+methodname+":None"+":"+str(line_no)+""+"\\n\""))
                update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
                update_statements.append(c_ast.Return(expr=new_statement))
            else:
                
                
                if methodname=='main':
                    getVariablesExcutionTrace(statement,all_variable_map)
                else:
                    getVariablesExcutionTraceBlock(new_statements,all_variable_map)
                str_printf_stmt=None
                arg_list1=[]
                temp_arg_list1=[]
                for x in all_variable_map:
                    if str_printf_stmt is None:
                        str_printf_stmt="\"assumption:"+x+"==%d;"
                        temp_arg_list1.append(x)
                    else:
                        str_printf_stmt+=x+"==%d;"
                        temp_arg_list1.append(x)
                if str_printf_stmt is not None:
                    str_printf_stmt+="\\n\""
                    arg_list1.append(c_ast.Constant(type="string", value=str_printf_stmt))
                    for x in temp_arg_list1:
                        arg_list1.append(c_ast.ID(name=x))
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list1)))
                    
                
                arg_list=[]
                
                #arg_list.append(c_ast.Constant(type="string", value="\"Return:"+methodname+":"+programPrint(statement.expr)+":"+str(line_no)+""+"\\n\""))
                if statement.expr is not None:
                    arg_list.append(c_ast.Constant(type="string", value="\"Return:"+programPrint(statement.expr)+":"+methodname+":%d"+":"+str(line_no)+""+"\\n\""))
                    arg_list.append(statement.expr)
                else:
                    arg_list.append(c_ast.Constant(type="string", value="\"Return:None:"+methodname+":None"+":"+str(line_no)+""+"\\n\""))
                update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
                update_statements.append(statement)
        else:
            count_ast_line_no+=1
            update_statements.append(statement)

    return update_statements


def constructExcutionTraceIf(statement,all_variable_map,isElse,methodname,new_statements):
    global count_for__insert_flag
    global count_ast_line_no
    global main_count_ast_line_no
    If_stmt=None
    Else_stmt=None
    list_of_con_ex_trace=[]
    list_of_con_ex_trace1=[]
    if type(statement) is c_ast.If:
        count_ast_line_no+=1
        count_for__insert_flag=count_for__insert_flag+1
        list_of_con_ex_trace.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='_con_flag'+str(count_for__insert_flag)),rvalue=statement.cond))
        cond_stmt=c_ast.ID(name='_con_flag'+str(count_for__insert_flag))
        if type(statement.iftrue) is c_ast.Compound:
            
            update_new_block_temp=[]
            
            line_no,stmt = getLineNumber(programPrint(statement.cond),methodname)
            
            new_block_temp=constructExcutionTraceBlock(statement.iftrue.block_items,all_variable_map,methodname,new_statements)
            
            
            #print '-------------------'
            #print programPrint(statement.cond)
            #print line_no
            #print stmt
            #print count_ast_line_no
            #print main_count_ast_line_no
            #print '-------------------'
            
            if line_no>0:
                arg_list=[]
                arg_list.append(c_ast.Constant(type="string", value="\"IfCondition2:"+programPrint(statement.cond)+":"+str(line_no)+":%d"+"\\n\""))
                arg_list.append(c_ast.ID(name='_con_flag'+str(count_for__insert_flag)))
                update_new_block_temp.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
                arg_list1=[]
                if isElse is not None:
                    arg_list1.append(c_ast.Constant(type="string", value="\"Else-IfCondition1:"+programPrint(statement.cond)+":"+str(line_no)+":%d"+"\\n\""))
                else:
                    arg_list1.append(c_ast.Constant(type="string", value="\"IfCondition1:"+programPrint(statement.cond)+":"+str(line_no)+":%d"+"\\n\""))
                arg_list1.append(c_ast.ID(name='_con_flag'+str(count_for__insert_flag)))
                list_of_con_ex_trace1.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list1)))
            
            
            If_stmt=c_ast.Compound(block_items=update_new_block_temp+new_block_temp)
            
        else:
            If_stmt=statement.iftrue
            
        if type(statement.iffalse) is c_ast.Compound:
            if statement.iffalse.block_items is not None:
                update_new_block_temp=[]
                
                line_no,stmt = getLineNumber(programPrint(statement.cond),methodname)
                
                new_block_temp=constructExcutionTraceBlock(statement.iffalse.block_items,all_variable_map,methodname,new_statements)
                
                #if line_no>0:
                    #arg_list=[]
                    #arg_list.append(c_ast.Constant(type="string", value="\"IfCondition2:"+programPrint(c_ast.UnaryOp(op='!',expr=statement.cond))+":"+str(line_no)+":%d"+"\\n\""))
                    #arg_list.append(c_ast.UnaryOp(op='!',expr=c_ast.ID(name='_con_flag'+str(count_for__insert_flag))))
                    #update_new_block_temp.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
                    #arg_list1=[]
                    #arg_list1.append(c_ast.Constant(type="string", value="\"Else-IfCondition1:"+programPrint(c_ast.UnaryOp(op='!',expr=statement.cond))+":"+str(line_no)+":%d"+"\\n\""))
                    #arg_list1.append(c_ast.UnaryOp(op='!',expr=c_ast.ID(name='_con_flag'+str(count_for__insert_flag))))
                    #list_of_con_ex_trace1.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list1)))
                Else_stmt=c_ast.Compound(block_items=new_block_temp)
                #Else_stmt=c_ast.Compound(block_items=update_new_block_temp+new_block_temp)
            else:
                Else_stmt=statement.iffalse
        else:
            if type(statement.iffalse) is c_ast.If:
                Else_stmt,list_of_con_ex_trace_temp,list_of_con_ex_trace1_temp=constructExcutionTraceIf(statement.iffalse,all_variable_map,'Else',methodname,new_statements)
                list_of_con_ex_trace=list_of_con_ex_trace+list_of_con_ex_trace_temp
                list_of_con_ex_trace1=list_of_con_ex_trace1+list_of_con_ex_trace1_temp
            else:
                Else_stmt=statement.iffalse
    return c_ast.If(cond=cond_stmt, iftrue=If_stmt, iffalse=Else_stmt),list_of_con_ex_trace,list_of_con_ex_trace1



def getFunctionCallAssigment(statement,function_assgmt):
    global count_for__function_flag
    if type(statement) is c_ast.BinaryOp:
        return c_ast.BinaryOp(op=statement.op,left=getFunctionCallAssigment(statement.left,function_assgmt),right=getFunctionCallAssigment(statement.right,function_assgmt))
    elif type(statement) is c_ast.Assignment:
        return c_ast.Assignment(op=statement.op,lvalue=getFunctionCallAssigment(statement.lvalue,function_assgmt),rvalue=getFunctionCallAssigment(statement.rvalue,function_assgmt))
    elif type(statement) is c_ast.FuncCall:
        if '__VERIFIER_nondet' not in statement.name.name:
            if statement.args is not None:
                count_for__function_flag+=1
                function_assgmt['_fun_call'+str(count_for__function_flag)]=c_ast.Assignment(op='=',lvalue=c_ast.ID(name='_fun_call'+str(count_for__function_flag)),rvalue=statement)
                return c_ast.ID(name='_fun_call'+str(count_for__function_flag))
            else:
                return statement
        else:
            return statement
    else:
        return statement




def getAllNodesOfAssetion(statement,map_nodes):
    if type(statement) is c_ast.BinaryOp:
        if type(statement.left) is c_ast.BinaryOp:
            getAllNodesOfAssetion(statement.left,map_nodes)
        elif type(statement.left) is c_ast.ID:
            map_nodes.append(statement.left)
        elif type(statement.left) is c_ast.ArrayRef:
            map_nodes.append(statement.left)
        if type(statement.right) is c_ast.BinaryOp:
            getAllNodesOfAssetion(statement.right,map_nodes)
        elif type(statement.right) is c_ast.ID and ('_PROVE' in statement.right.name or '_FAILED' in statement.right.name or '_ASSUME' in statement.right.name):
            map_nodes.append(statement.right)
        elif type(statement.right) is c_ast.ArrayRef:
            array_name=getArrayRef_Name(statement.right)
            if ('_PROVE' in array_name or '_FAILED' in array_name or '_ASSUME' in array_name):
                map_nodes.append(statement.right)
    


def addPrintStmt(statements,localvariables,inputvariables):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Assignment:
            if type(statement.lvalue) is c_ast.ID and '_PROVE' in statement.lvalue.name:
                update_statements.append(statement)
                nodes=[]
                list_variables=[]
                getAllNodesOfAssetion(statement.rvalue,nodes)
                update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))
                for node in nodes:
                        if type(node) is c_ast.ID:
                            list_variables.append(node.name)
                        update_statements.append(createPrint(node,localvariables,inputvariables))
                for var in localvariables.keys():
                    varObject=localvariables[var]
                    if varObject.getDimensions()==0 or varObject.getDimensions() is None:
                        if varObject.getVariablename() not in list_variables and '_PROVE' not in varObject.getVariablename() and '_ASSUME' not in varObject.getVariablename() and 'RET' not in varObject.getVariablename() and '_FAILED' not in varObject.getVariablename() and 'DUMMY' not in varObject.getVariablename() and 'break_' not in varObject.getVariablename() and 'bool_go' not in varObject.getVariablename():
                            update_statements.append(createPrint(c_ast.ID(name=varObject.getVariablename()),localvariables,inputvariables))
                arg_list=[]
                arg_list.append(c_ast.Constant(type="string", value="\"--------\\n\""))
                update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
            
            elif type(statement.lvalue) is c_ast.ID and '_FAILED' in statement.lvalue.name and type(statement.rvalue) is c_ast.Constant and statement.rvalue.value=='1':
                update_statements.append(statement)
                nodes=[]
                list_variables=[]
                getAllNodesOfAssetion(statement.rvalue,nodes)
                update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))
                for node in nodes:
                        if type(node) is c_ast.ID:
                            list_variables.append(node.name)
                        update_statements.append(createPrint(node,localvariables,inputvariables))
                for var in localvariables.keys():
                    varObject=localvariables[var]
                    if varObject.getDimensions()==0 or varObject.getDimensions() is None:
                        if varObject.getVariablename() not in list_variables and '_PROVE' not in varObject.getVariablename() and '_ASSUME' not in varObject.getVariablename() and '_FAILED' not in varObject.getVariablename() and 'RET' not in varObject.getVariablename() and 'DUMMY' not in varObject.getVariablename() and 'break_' not in varObject.getVariablename() and 'bool_go' not in varObject.getVariablename():
                            update_statements.append(createPrint(c_ast.ID(name=varObject.getVariablename()),localvariables,inputvariables))
                arg_list=[]
                arg_list.append(c_ast.Constant(type="string", value="\"--------\\n\""))
                update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))            
            
            
            elif type(statement.lvalue) is c_ast.ID and '_ASSUME' in statement.lvalue.name and type(statement.rvalue) is c_ast.BinaryOp:
                update_statements.append(statement)
                nodes=[]
                list_variables=[]
                getAllNodesOfAssetion(statement.rvalue,nodes)
                update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))
                arg_list=[]
                arg_list.append(c_ast.Constant(type="string", value="\"--------\\n\""))
                update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
            
            
            
            else:
                if type(statement.lvalue) is c_ast.ArrayRef and '_PROVE' in getArrayRef_Name(statement.lvalue):
                    update_statements.append(statement)
                    nodes=[]
                    list_variables=[]
                    getAllNodesOfAssetion(statement.rvalue,nodes)
                    update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))
                    for node in nodes:
                        if type(node) is c_ast.ID:
                            list_variables.append(node.name)
                        update_statements.append(createPrint(node,localvariables,inputvariables))
                    for var in localvariables.keys():
                        varObject=localvariables[var]
                        if varObject.getDimensions()==0 or varObject.getDimensions() is None:
                            if varObject.getVariablename() not in list_variables and '_PROVE' not in varObject.getVariablename() and '_ASSUME' not in varObject.getVariablename() and '_FAILED' not in varObject.getVariablename() and 'RET' not in varObject.getVariablename() and 'DUMMY' not in varObject.getVariablename() and 'break_' not in varObject.getVariablename() and 'bool_go' not in varObject.getVariablename():
                                update_statements.append(createPrint(c_ast.ID(name=varObject.getVariablename()),localvariables,inputvariables))
                    arg_list=[]
                    arg_list.append(c_ast.Constant(type="string", value="\"--------\\n\""))
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
                
                elif type(statement.lvalue) is c_ast.ID and '_FAILED' in statement.lvalue.name and  type(statement.rvalue) is c_ast.Constant and statement.rvalue.value=='1':
                    update_statements.append(statement)
                    nodes=[]
                    list_variables=[]
                    getAllNodesOfAssetion(statement.rvalue,nodes)
                    update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))
                    for node in nodes:
                            if type(node) is c_ast.ID:
                                list_variables.append(node.name)
                            update_statements.append(createPrint(node,localvariables,inputvariables))
                    for var in localvariables.keys():
                        varObject=localvariables[var]
                        if varObject.getDimensions()==0 or varObject.getDimensions() is None:
                            if varObject.getVariablename() not in list_variables and '_PROVE' not in varObject.getVariablename() and '_ASSUME' not in varObject.getVariablename() and '_FAILED' not in varObject.getVariablename() and 'DUMMY' not in varObject.getVariablename() and 'break_' not in varObject.getVariablename() and 'bool_go' not in varObject.getVariablename():
                                update_statements.append(createPrint(c_ast.ID(name=varObject.getVariablename()),localvariables,inputvariables))
                    arg_list=[]
                    arg_list.append(c_ast.Constant(type="string", value="\"--------\\n\""))
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list))) 
                
                elif type(statement.lvalue) is c_ast.ArrayRef and '_ASSUME' in getArrayRef_Name(statement.lvalue):
                    update_statements.append(statement)
                    nodes=[]
                    list_variables=[]
                    getAllNodesOfAssetion(statement.rvalue,nodes)
                    update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))
                    arg_list=[]
                    arg_list.append(c_ast.Constant(type="string", value="\"--------\\n\""))
                    update_statements.append(c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list)))
                        
                else:
                    update_statements.append(statement)
        elif type(statement) is c_ast.While:
            update_statements.append(c_ast.While(cond=statement.cond, stmt=c_ast.Compound(block_items=addPrintStmt(statement.stmt.block_items,localvariables,inputvariables))))
        elif type(statement) is c_ast.If:
            update_statements.append(addPrintStmtIf(statement,localvariables,inputvariables))
        else:
            update_statements.append(statement)
    
    return update_statements



def addPrintStmtIf(statement,localvariables,inputvariables):
    If_stmt=None
    Else_stmt=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            new_block_temp=addPrintStmt(statement.iftrue.block_items,localvariables,inputvariables)
            If_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            If_stmt=statement.iftrue
    if type(statement.iffalse) is c_ast.Compound:
        if statement.iffalse.block_items is not None:
            new_block_temp=addPrintStmt(statement.iffalse.block_items,localvariables,inputvariables)
            Else_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            Else_stmt=statement.iffalse
    else:
        if type(statement.iffalse) is c_ast.If:
            Else_stmt=addPrintStmtIf(statement.iffalse,localvariables,inputvariables)
        else:
            Else_stmt=statement.iffalse
    return c_ast.If(cond=statement.cond, iftrue=If_stmt, iffalse=Else_stmt)






def addPrintStmt2(statements,localvariables,inputvariables):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Assignment:
            if type(statement.lvalue) is c_ast.ID and '_PROVE' in statement.lvalue.name:
                update_statements.append(statement)
                nodes=[]
                list_variables=[]
                update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))
            
            elif type(statement.lvalue) is c_ast.ID and '_FAILED' in statement.lvalue.name and type(statement.rvalue) is c_ast.Constant and statement.rvalue.value=='1':
                update_statements.append(statement)
                nodes=[]
                list_variables=[]
                update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))            
            
            elif type(statement.lvalue) is c_ast.ID and '_ASSUME' in statement.lvalue.name and type(statement.rvalue) is c_ast.BinaryOp:
                update_statements.append(statement)
                nodes=[]
                list_variables=[]
                update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))
            
            
            
            else:
                if type(statement.lvalue) is c_ast.ArrayRef and '_PROVE' in getArrayRef_Name(statement.lvalue):
                    update_statements.append(statement)
                    nodes=[]
                    list_variables=[]
                    update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))                
                elif type(statement.lvalue) is c_ast.ID and '_FAILED' in statement.lvalue.name and  type(statement.rvalue) is c_ast.Constant and statement.rvalue.value=='1':
                    update_statements.append(statement)
                    nodes=[]
                    list_variables=[]
                    update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))

                
                elif type(statement.lvalue) is c_ast.ArrayRef and '_ASSUME' in getArrayRef_Name(statement.lvalue):
                    update_statements.append(statement)
                    nodes=[]
                    list_variables=[]

                    update_statements.append(createPrint(statement.lvalue,localvariables,inputvariables))
                        
                else:
                    update_statements.append(statement)
        elif type(statement) is c_ast.While:
            update_statements.append(c_ast.While(cond=statement.cond, stmt=c_ast.Compound(block_items=addPrintStmt2(statement.stmt.block_items,localvariables,inputvariables))))
        elif type(statement) is c_ast.If:
            update_statements.append(addPrintStmtIf2(statement,localvariables,inputvariables))
        else:
            update_statements.append(statement)
    
    return update_statements



def addPrintStmtIf2(statement,localvariables,inputvariables):
    If_stmt=None
    Else_stmt=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            new_block_temp=addPrintStmt2(statement.iftrue.block_items,localvariables,inputvariables)
            If_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            If_stmt=statement.iftrue
    if type(statement.iffalse) is c_ast.Compound:
        if statement.iffalse.block_items is not None:
            new_block_temp=addPrintStmt2(statement.iffalse.block_items,localvariables,inputvariables)
            Else_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            Else_stmt=statement.iffalse
    else:
        if type(statement.iffalse) is c_ast.If:
            Else_stmt=addPrintStmtIf2(statement.iffalse,localvariables,inputvariables)
        else:
            Else_stmt=statement.iffalse
    return c_ast.If(cond=statement.cond, iftrue=If_stmt, iffalse=Else_stmt)


def modify__VERIFIER_nondet_block(statements):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Assignment:
            update_statements.append(modify__VERIFIER_nondet_stmt(statement))
        elif type(statement) is c_ast.While:
            update_statements.append(c_ast.While(cond=modify__VERIFIER_nondet_stmt(statement.cond), stmt=c_ast.Compound(block_items=modify__VERIFIER_nondet_block(statement.stmt.block_items))))
        elif type(statement) is c_ast.If:
            update_statements.append(modify__VERIFIER_nondet_blockIf(statement))
        else:
            update_statements.append(statement)
    
    return update_statements
    
def modify__VERIFIER_nondet_blockIf(statement):
    If_stmt=None
    Else_stmt=None
    cond_stmt=modify__VERIFIER_nondet_stmt(statement.cond)
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            new_block_temp=modify__VERIFIER_nondet_block(statement.iftrue.block_items)
            If_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            If_stmt=statement.iftrue
    if type(statement.iffalse) is c_ast.Compound:
        if statement.iffalse.block_items is not None:
            new_block_temp=modify__VERIFIER_nondet_block(statement.iffalse.block_items)
            Else_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            Else_stmt=statement.iffalse
    else:
        if type(statement.iffalse) is c_ast.If:
            Else_stmt=modify__VERIFIER_nondet_blockIf(statement.iffalse)
        else:
            Else_stmt=statement.iffalse
    return c_ast.If(cond=cond_stmt, iftrue=If_stmt, iffalse=Else_stmt)
    
    
    
def modify__VERIFIER_nondet_stmt(statement):
    global count_for__VERIFIER_nondet
    if type(statement) is c_ast.BinaryOp:
        return c_ast.BinaryOp(op=statement.op,left=modify__VERIFIER_nondet_stmt(statement.left),right=modify__VERIFIER_nondet_stmt(statement.right))
    elif type(statement) is c_ast.Assignment:
        return c_ast.Assignment(op=statement.op,lvalue=modify__VERIFIER_nondet_stmt(statement.lvalue),rvalue=modify__VERIFIER_nondet_stmt(statement.rvalue))
    elif type(statement) is c_ast.FuncCall:
        if '__VERIFIER_nondet' in statement.name.name:
            if statement.args is None:
                arg_list=[]
                count_for__VERIFIER_nondet=count_for__VERIFIER_nondet+1
                arg_list.append(c_ast.Constant(type="int", value=str(count_for__VERIFIER_nondet)))
                return c_ast.FuncCall(name=statement.name, args=c_ast.ExprList(exprs=arg_list))
            else:
                return statement
        else:
            return statement
    else:
        return statement
    


def getArrayRef_Name(statement):
    if type(statement.name) is c_ast.ArrayRef:
        return getArrayRef_Name(statement.name)
    else:
        return statement.name.name
        

def createPrint(statement,localvariables,inputvariables):
    generator = c_generator.CGenerator()
    arg_list=[]
    mod_operator=None
    if type(statement) is c_ast.ID:
        if statement.name in localvariables.keys():
            mod_operator=localvariables[statement.name].getVariableType()
        elif statement.name in inputvariables.keys():
            mod_operator=inputvariables[statement.name].getVariableType()
    elif type(statement) is c_ast.ArrayRef:
        array_name=getArrayRef_Name(statement)
        if array_name in inputvariables.keys():
            mod_operator=inputvariables[array_name].getVariableType()
        elif array_name in localvariables.keys():
            mod_operator=localvariables[array_name].getVariableType()
    if mod_operator is not None:
        if mod_operator=='int':
            mod_operator='%d'
        elif mod_operator=='unsigned':
            mod_operator='%u'
        elif mod_operator=='long':
             mod_operator='%ld'
        elif mod_operator=='float':
            mod_operator='%f'
        elif mod_operator=='double':
            mod_operator='%f'
        else:
            mod_operator='%d'
            
    else:
        mod_operator='%d'
    var_name=str(generator.visit(statement))
    arg_list.append(c_ast.Constant(type="string", value="\""+var_name+":"+mod_operator+"\\n\""))
    arg_list.append(statement)
    print_stmt=c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list))
    return print_stmt

def programPrint(statement):
    generator = GnuCGenerator()
    return str(generator.visit(statement))
 
    
def getArrayDetails(statement,degree,dimension_map):
    if type(statement.type) is c_ast.ArrayDecl:
        degree=degree+1
        if type(statement.type.dim) is c_ast.ID:
            if is_number(statement.type.dim.name)==True:
                dimension_map['_x'+str(degree+1)]=statement.type.dim.name+'_var1'
            elif statement.type.dim.name in ['S','Q','N','in','is']:
                dimension_map['_x'+str(degree+1)]=statement.type.dim.name+'_var1'
            else:
                dimension_map['_x'+str(degree+1)]=statement.type.dim.name+'1'
        elif type(statement.type.dim) is c_ast.Constant:
            dimension_map['_x'+str(degree+1)]=statement.type.dim.value
        return getArrayDetails(statement.type,degree,dimension_map)
    elif type(statement.type) is c_ast.PtrDecl:
        degree=degree+1
        return getArrayDetails(statement.type,degree,dimension_map)
    else:
        if type(statement.type.type) is c_ast.Struct:
            return statement.type.type.name,degree,statement.type.type.name
        elif type(statement.type.type) is c_ast.Union:
            return statement.type.type.name,degree,statement.type.type.name
        else:
            return statement.type.type.names[0],degree,None


#Simplify Declaration 

def simplificationOfDec(statements):
        update_statements=[]
        for statement in statements:
            if type(statement) is c_ast.Decl:
                statement.show()
            else:
                update_statements.append(statement)



#Get All Variables


def getVariables(function_body):
    #statements=handlingPointer(function_body.block_items)
    statements=function_body.block_items
    #for decl in function_body.block_items:
    return getVariablesC(statements)


#Get Variable 

def getVariablesC(statements):
    localvarmap={}
    if statements is None:
        return localvarmap
    for decl in statements:
        if type(decl) is c_ast.Decl:
            var_type=None
            initial_value=None
            structType=None
            if type(decl.type) is c_ast.ArrayDecl:
                #if checkingArrayName(decl.type)==True:
                if is_number(decl.name[-1])==True:
                    decl=c_ast.Decl(name=decl.name+'_var', quals=decl.quals, storage=decl.storage, funcspec=decl.funcspec, type=renameArrayName(decl.type), init=decl.init, bitsize=decl.bitsize)
                elif decl.name in ['S','Q','N','in','is']:
                    decl=c_ast.Decl(name=decl.name+'_var', quals=decl.quals, storage=decl.storage, funcspec=decl.funcspec, type=renameArrayName(decl.type), init=decl.init, bitsize=decl.bitsize)
            elif type(decl.type) is c_ast.PtrDecl:
                if type(decl.type.type) is c_ast.TypeDecl:
                    if is_number(decl.type.type.declname[-1])==True:
                        decl.type.type=c_ast.TypeDecl(decl.type.type.declname+'_var', quals=decl.type.type.quals, type=decl.type.type.type)
                    elif decl.name in ['S','Q','N','in','is']:
                        decl.type.type=c_ast.TypeDecl(decl.type.type.declname+'_var', quals=decl.type.type.quals, type=decl.type.type.type)
            else:
                if is_number(decl.type.declname[-1])==True :
                    decl=c_ast.Decl(name=decl.name+'_var', quals=decl.quals, storage=decl.storage, funcspec=decl.funcspec, type=c_ast.TypeDecl(declname=decl.type.declname+'_var', quals=decl.type.quals, type=decl.type.type), init=decl.init, bitsize=decl.bitsize)


            if type(decl.type) is c_ast.ArrayDecl:
                degree=0
                dimensionmap={}
                var_type,degree,structType=getArrayDetails(decl,degree,dimensionmap)
                variable=variableclass(decl.name, var_type,None,dimensionmap,initial_value,structType)
            elif type(decl.type) is c_ast.PtrDecl:
                degree=0
                dimensionmap={}
                var_type,degree,structType=getArrayDetails(decl,degree,dimensionmap)
                variable=variableclass(decl.name, var_type,'Pointer',dimensionmap,initial_value,structType)
            else:
            	for child in decl.children():
                    if type(child[1]) is c_ast.TypeDecl:
                        if type(child[1].type) is c_ast.IdentifierType:
                            var_type=child[1].type.names[0]
                        else:
                            if type(child[1].type) is c_ast.Struct:
                                structType=child[1].type.name
                                var_type=child[1].type.name
                            else:
                                initial_value=child[1].value
                    else:
                            if type(child[1]) is c_ast.FuncCall:
                                parameter=''
                                if child[1].args is not None:
                                    for param in child[1].args.exprs:
                                        if type(param) is c_ast.ID:
                                            if parameter=='':
                                                parameter = "expres('"+param.name+"')"
                                            else:
                                                parameter += ",expres('"+param.name+"')"
                                        elif type(param) is c_ast.Constant:
                                            if parameter=='':
                                                parameter = "expres('"+param.value+"')"
                                            else:
                                                parameter += ",expres('"+param.value+"')"
                                        else:
                                            if type(statement) is c_ast.ArrayRef:
                                                degree=0
                                                stmt,degree=createArrayList_C(statement,degree)
                                                if parameter=='':
                                                    parameter = "expres('d"+str(degree)+'array'+"',["+stmt+"])"
                                                else:
                                                    parameter += ","+"expres('d"+str(degree)+'array'+"',["+stmt+"])"
                                    #initial_value="['"+child[1].name.name+"',"+parameter+"]"
                                    initial_value="['"+child[1].name.name+"',"+parameter+"]"
                                else:
                                    #initial_value="expres('"+child[1].name.name+"'"+")"
                                    initial_value=child[1].name.name
                            else:
                                if type(child[1]) is c_ast.Constant:
                                    initial_value=child[1].value
                                elif type(child[1]) is c_ast.ID:
                                    initial_value=child[1].name
                                else:
                                    #print expressionCreator_C(child[1])
                                    initial_value=child[1]
            	variable=variableclass(decl.name, var_type,None,None,initial_value,structType)
            localvarmap[decl.name]=variable
        elif type(decl) is c_ast.While:
        	localvarmap_temp=getVariablesC(decl.stmt.block_items)
        	for var in localvarmap_temp.keys():
        		localvarmap[var]=localvarmap_temp[var]
        elif type(decl) is c_ast.If:
        	localvarmap_temp=getVariablesC_If(decl)
        	for var in localvarmap_temp.keys():
        		localvarmap[var]=localvarmap_temp[var]
    return localvarmap


def getVariablesC_If(statement):
    localvarmap={}
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            localvarmap_temp=getVariablesC(statement.iftrue.block_items)
            for var in localvarmap_temp.keys():
                localvarmap[var]=localvarmap_temp[var]				
    if type(statement.iffalse) is c_ast.Compound:
        if statement.iffalse.block_items is not None:
            localvarmap_temp=getVariablesC(statement.iffalse.block_items)
            for var in localvarmap_temp.keys():
                localvarmap[var]=localvarmap_temp[var]	
        else:
            if type(statement.iffalse) is c_ast.If:
                localvarmap_temp=getVariablesC_If(statement.iffalse)
                for var in localvarmap_temp.keys():
                    localvarmap[var]=localvarmap_temp[var]	
    return localvarmap





def getVariablesInit(statements):
    update_statement=[]
    for decl in statements:
        if type(decl) is c_ast.Decl:
            if type(decl.type) is not c_ast.ArrayDecl:
                if decl.init is not None and '_PROVE' not in decl.name:
                    new_word=None
                    if new_word is None:
                        new_word=copy.deepcopy(decl.init)
                    decl=c_ast.Decl(name=decl.name, quals=decl.quals, storage=decl.storage, funcspec=decl.funcspec, type=c_ast.TypeDecl(declname=decl.type.declname, quals=decl.type.quals, type=decl.type.type), init=None, bitsize=decl.bitsize)
                    update_statement.append(decl)
                    if '_PROVE' not in decl.name:
                        if new_word is not None:
                            update_statement.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=decl.name), rvalue=new_word))
                else:
                    update_statement.append(decl)
            else:
                update_statement.append(decl)
        elif type(decl) is c_ast.While:
            new_block_temp=getVariablesInit(decl.stmt.block_items)
            update_statement.append(c_ast.While(cond=decl.cond, stmt=c_ast.Compound(block_items=new_block_temp)))
        elif type(decl) is c_ast.If:
                update_statement.append(getVariablesInit_If(decl))
        else:
             update_statement.append(decl)
    return update_statement


def getVariablesInit_If(statement):
    If_stmt=None
    Else_stmt=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            new_block_temp=getVariablesInit(statement.iftrue.block_items)
            If_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            If_stmt=statement.iftrue
        if type(statement.iffalse) is c_ast.Compound:
           if statement.iffalse.block_items is not None:
                    new_block_temp=getVariablesInit(statement.iffalse.block_items)
                    Else_stmt=c_ast.Compound(block_items=new_block_temp)
           else:
                Else_stmt=statement.iffalse
        else:
           if type(statement.iffalse) is c_ast.If:
                Else_stmt=getVariablesInit_If(statement.iffalse)
           else:
                Else_stmt=statement.iffalse
    return c_ast.If(cond=statement.cond, iftrue=If_stmt, iffalse=Else_stmt)
















"""

Organization of AST 

"""
               
def organizeStatementToObject_C(statements):
    count=0
    degree=0
    expressions=[]
    for statement in statements:
        if type(statement) is c_ast.Assignment:
            count=count+1
            expression=expressionclass(statement, count, True,degree)
            expressions.append(expression)
        elif type(statement) is c_ast.While:
            blockexpressions=[]
            if statement.stmt is not None:
                degree=degree+1
                count,blockexpressions=blockToExpressions_C(statement.stmt.block_items, degree, count)
                degree=degree-1
            block=blockclass( blockexpressions, statement.cond, count , True, degree)
            expressions.append(block)
        else:
            if type(statement) is c_ast.If:
                count,ifclass=ifclassCreator_C(statement, degree, count)
                expressions.append(ifclass)
            else:
                count=count+1
                expression=expressionclass(statement, count, True,degree)
                expressions.append(expression)
					
    return expressions



"""

Organization of AST 

"""


               
def organize__VERIFIER_nondet_C(statements,count):
    expressions=[]
    for statement in statements:
        if type(statement) is c_ast.Assignment:
            expressions.append(expression)
        elif type(statement) is c_ast.While:
            blockexpressions=[]
            if statement.stmt is not None:
                count,blockexpressions=organize__VERIFIER_nondet_C(statement.stmt.block_items,count)
            block=blockclass( blockexpressions, statement.cond, count , True, degree)
            expressions.append(block)
        else:
            if type(statement) is c_ast.If:
                count,ifclass=ifclassCreator_C(statement, degree, count)
                expressions.append(ifclass)
            else:
                count=count+1
                expression=expressionclass(statement, count, True,degree)
                expressions.append(expression)
					
        return expressions,count

"""

Conditionl Loop to a Array of Statement Compatible to Translator Program 
IfClass Creator

"""

def ifclassCreator_C(statement, degree, count):
    blockexpressions1=None
    blockexpressions2=None
    predicate=statement.cond
	#print statement.iftrue.show()
	#print statement.iffalse.show()
    if statement.iftrue is not None:
            if type(statement.iftrue) is c_ast.Compound:
                count,blockexpressions1=blockToExpressions_C(statement.iftrue.block_items, degree, count)
            else:
                new_block_items=[]
                new_block_items.append(statement.iftrue)
                count,blockexpressions1=blockToExpressions_C(new_block_items, degree, count)
    if statement.iffalse is not None and type(statement.iffalse) is c_ast.If:
        	count,blockexpressions2=ifclassCreator_C(statement.iffalse, degree, count)
    else:
            if statement.iffalse is not None:
                if type(statement.iffalse) is c_ast.Compound:
                    count,blockexpressions2=blockToExpressions_C(statement.iffalse.block_items, degree, count)
                else:
                    new_block_items=[]
                    new_block_items.append(statement.iffalse)
                    count,blockexpressions2=blockToExpressions_C(new_block_items, degree, count)
    ifclass=Ifclass(predicate, blockexpressions1, blockexpressions2, count ,True ,degree)
    return count,ifclass



"""

Converting code block,while loop ,conditional expression and expression to corresponding Classes

"""

def blockToExpressions_C(body, degree, count):
    expressions=[]
    if body is not None:
        for statement in body:
            if type(statement) is c_ast.Assignment:
                    count=count+1
                    expression=expressionclass(statement, count, True,degree)
                    expressions.append(expression)
            elif type(statement) is c_ast.While:
                blockexpressions=[]
                if statement.stmt is not None:
                    degree=degree+1
                    count,blockexpressions=blockToExpressions_C(statement.stmt.block_items, degree, count)
                    degree=degree-1
                block=blockclass( blockexpressions, statement.cond, count , True, degree)
                expressions.append(block)
            else:
                if type(statement) is c_ast.If:
                    count,ifclass=ifclassCreator_C(statement, degree, count)
                    expressions.append(ifclass)
    return count,expressions




"""

Block of Statement to Array of Statement Compatible to Translator Program 

"""
def programToinductiveDefination_C(expressions, allvariable):
    programsstart=""
    programsend=""
    statements=""
    #print('1@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@start')
    #print(expressions)
    for expression in expressions:
        #print('+++++++++++++++++++++')
        #print(type(expression))
        #print(expression.show())
        #print('+++++++++++++++++++++')
        if type(expression) is expressionclass:
            if type(expression.getExpression()) is c_ast.Assignment:
                                var=None
                                if type(expression.getExpression().lvalue) is c_ast.ID:
                                    var=str(eval("expres('"+str(expression.getExpression().lvalue.name)+"')"))
                                    #print(var)
                                elif type(expression.getExpression().lvalue) is c_ast.Constant:
                                    var=str(eval("expres('"+str(expression.getExpression().lvalue.value)+"')"))
                                elif type(expression.getExpression().lvalue) is c_ast.ArrayRef:
                                    degree=0
                                    stmt,degree=createArrayList_C(expression.getExpression().lvalue,degree)
                                    var=str(eval("expres('d"+str(degree)+'array'+"',["+stmt+"])"))
                                elif type(expression.getExpression().lvalue) is c_ast.FuncCall:
                                    parameter=''
                                    statement=expression.getExpression().lvalue
                                    if statement.args is not None:
                                        for param in statement.args.exprs:
                                            if type(param) is c_ast.ID:
                                                if parameter=='':
                                                   
                                                    parameter = str(eval("expres('"+param.name+"')"))
                                                else:
                                                    parameter += ","+str(eval("expres('"+param.name+"')"))
                                            elif type(param) is c_ast.Constant:
                                                if parameter=='':
                                                    parameter = str(eval("expres('"+param.value+"')"))
                                                else:
                                                    parameter += ","+str(eval("expres('"+param.value+"')"))
                                            elif type(param) is c_ast.BinaryOp:
                                                if parameter=='':
                                                    parameter =expressionCreator_C(param)
                                                else:
                                                    parameter += ","+expressionCreator_C(param)
                                            else:
                                                            if type(param) is c_ast.ArrayRef:
                                                            #parameter_list.append('int')
                                                                degree=0
                                                                stmt,degree=createArrayList_C(param,degree)
                                                                if parameter=='':
                                                                    parameter = str(eval("expres('d"+str(degree)+'array'+"',["+stmt+"])"))
                                                                else:
                                                                    parameter += ","+str(eval("expres('d"+str(degree)+'array'+"',["+stmt+"])"))
                                    var="['"+statement.name.name+"',"+parameter+"]"
		
                                
                                if expression.getIsPrime()==False:
                                    if programsstart=="":
                                        programsstart="['-1','seq',['-1','=',"+str(var)+","+str(expressionCreator_C(expression.getExpression().rvalue))+"]"
                                        programsend="]"
                                    else:
                                        programsstart+=",['-1','seq',['-1','=',"+str(var)+","+str(expressionCreator_C(expression.getExpression().rvalue))+"]"
                                        programsend+="]"
                                else:
                                    if programsstart=="":
                                        programsstart="['-1','=',"+str(var)+","+str(expressionCreator_C(expression.getExpression().rvalue))+"]"+programsend
                                    else:
                                        programsstart+=",['-1','=',"+str(var)+","+str(expressionCreator_C(expression.getExpression().rvalue))+"]"+programsend

            elif type(expression.getExpression()) is c_ast.FuncCall:
                parameter=''
                statement=expression.getExpression()
                if statement.args is not None:
                    for param in statement.args.exprs:
                            if type(param) is c_ast.ID:
                                if parameter=='':
                                    parameter = str(eval("expres('"+param.name+"')"))
                                else:
                                    parameter += ","+str(eval("expres('"+param.name+"')"))
                            elif type(param) is c_ast.Constant:
                                if parameter=='':
                                    parameter = str(eval("expres('"+param.value+"')"))
                                else:
                                    parameter += ","+str(eval("expres('"+param.value+"')"))
                            elif type(param) is c_ast.BinaryOp:
                                if parameter=='':
                                    parameter =expressionCreator_C(param)
                                else:
                                    parameter += ","+expressionCreator_C(param)
                            else:
                                    if type(param) is c_ast.ArrayRef:
                                        #parameter_list.append('int')
                                        degree=0
                                        stmt,degree=createArrayList_C(param,degree)
                                        if parameter=='':
                                            parameter = str(eval("expres('d"+str(degree)+'array'+"',["+stmt+"])"))
                                        else:
                                            parameter += ","+str(eval("expres('d"+str(degree)+'array'+"',["+stmt+"])"))
					
                    if expression.getIsPrime()==False:
                        if programsstart=="":
                            programsstart="['-1','seq',"+"['"+statement.name.name+"',"+parameter+"]"
                            programsend="]"
                        else:
                            programsstart+=","+"['-1','seq',"+"['"+statement.name.name+"',"+parameter+"]"
                            programsend+="]"
                    else:
                        if programsstart=="":
                            programsstart="['-1','seq',"+"['"+statement.name.name+"',"+parameter+"]"+programsend
                        else:
                            programsstart+=","+"['-1','seq',"+"['"+statement.name.name+"',"+parameter+"]"+programsend
                else:
                    if expression.getIsPrime()==False:
                        if programsstart=="":
                            programsstart="['-1','seq',"+str(eval("expres('"+statement.name.name+"'"+")"))
                            programsend="]"
                        else:
                            programsstart+=","+"['-1','seq',"+str(eval("expres('"+statement.name.name+"'"+")"))
                            programsend+="]"
                    else:
                        if programsstart=="":
                            programsstart="['-1','seq',"+str(eval("expres('"+statement.name.name+"'"+")"))+programsend
                        else:
                            programsstart+=","+"['-1','seq',"+str(eval("expres('"+statement.name.name+"'"+")"))+programsend
        elif type(expression) is blockclass:
            predicatestmt="['-1','while',"+expressionCreator_C(expression.predicate)+","+programToinductiveDefination_C( expression.getExpression(), allvariable)+"]"
            if expression.getIsPrime()==False:
                if programsstart=="":
                    programsstart="['-1','seq',"+predicatestmt
                    programsend="]"
                else:
                    programsstart+=",['-1','seq',"+predicatestmt
                    programsend+="]"
            else:
                programsstart+=","+predicatestmt+programsend
        elif type(expression) is Ifclass:
            condition=expressionCreator_C(expression.predicate)
            expressionif=None
            expressionelse=None
            predicatestmt=""
            if expression.getExpressionif() is not None:
                expressionif=programToinductiveDefination_C( expression.getExpressionif(), allvariable)
            if expression.getExpressionelse() is not None:
                if type(expression.getExpressionelse()) is Ifclass:
					#expressionelse=programToinductiveDefination( expression.getExpressionelse().getExpressionif(), allvariable)
                    expressionelse=programToinductiveDefinationIfElse_C( expression.getExpressionelse(), allvariable)
                else:
                    expressionelse=programToinductiveDefination_C( expression.getExpressionelse(), allvariable)
            if expressionif is not None and expressionelse is not None:
                predicatestmt="['-1','if2',"+condition+","+expressionif+","+expressionelse+"]"
            elif expressionif is not None and expressionelse is None:
                predicatestmt="['-1','if1',"+condition+","+expressionif+"]"

            #print('=================================')
            #print(expressionif)
            #print('=================================')
            #print(expressionelse)
            #print('=================================')
            if expression.getIsPrime()==False:
                if programsstart=="":
                    programsstart="['-1','seq',"+predicatestmt
                    programsend="]"
                else:
                    programsstart+=",['-1','seq',"+predicatestmt
                    programsend+="]"
            else:
                if programsstart=="":
                    programsstart=predicatestmt+programsend
                else:
                    programsstart+=","+predicatestmt+programsend
    #print(programsstart)
    if programsstart[0]==',':
        programsstart=programsstart[1:]	
    #print('1~~~~~~~~~~~~~~~~end')
    return programsstart





"""

IfElse Block Statement to Array of Statement Compatible to Translator Program 

"""
def programToinductiveDefinationIfElse_C(expression, allvariable):
    programsstart=""
    programsend=""
    statements=""
    #print('2@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@start')
    if type(expression) is expressionclass:
        if type(expression.getExpression()) is c_ast.Assignment:
                        var=None
                        if type(expression.getExpression().lvalue) is c_ast.ID:
                            var=str(eval("expres('"+str(expression.getExpression().lvalue.name)+"')"))
                        elif type(expression.getExpression().lvalue) is c_ast.Constant:
                            var=str(eval("expres('"+str(expression.getExpression().lvalue.value)+"')"))
                        elif type(expression.getExpression().lvalue) is c_ast.ArrayRef:
                            degree=0
                            stmt,degree=createArrayList_C(expression.getExpression().lvalue,degree)
                            var=str(eval("expres('d"+str(degree)+'array'+"',["+stmt+"])"))
                        if expression.getIsPrime()==False:
                            if programsstart=="":
                                programsstart="['-1','seq',['-1','=',"+str(var)+","+str(expressionCreator(expression.getExpression().rhs))+"]"
                                programsend="]"
                            else:
                                programsstart+=",['-1','seq',['-1','=',"+str(var)+","+str(expressionCreator(expression.getExpression().rhs))+"]"
                                programsend+="]"
                        else:
                            if programsstart=="":
                                programsstart+="['-1','=',"+str(var)+","+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend
                            else:
                                programsstart+=",['-1','=',"+str(var)+","+str(expressionCreator(expression.getExpression().rhs))+"]"+programsend

    elif type(expression) is blockclass:
        predicatestmt="['-1','while',"+expressionCreator_C(expression.predicate)+","+programToinductiveDefination_C( expression.getExpression(), allvariable)+"]"
        if expression.getIsPrime()==False:
            if programsstart=="":
                programsstart="['-1','seq',"+predicatestmt
                programsend="]"
            else:
                programsstart+=",['-1','seq',"+predicatestmt
                programsend+="]"
        else:
            if programsstart=="":
                programsstart+=","+predicatestmt+programsend
			
    elif type(expression) is Ifclass:
        condition=expressionCreator_C(expression.predicate)
        expressionif=None
        expressionelse=None
        predicatestmt=""
        if expression.getExpressionif() is not None:
            expressionif=programToinductiveDefination_C( expression.getExpressionif(), allvariable)
        if expression.getExpressionelse() is not None:
            if type(expression.getExpressionelse()) is Ifclass:
				#expressionelse=programToinductiveDefination( expression.getExpressionelse().getExpressionif(), allvariable)
                expressionelse=programToinductiveDefinationIfElse_C( expression.getExpressionelse(), allvariable)
            else:
                expressionelse=programToinductiveDefination_C( expression.getExpressionelse(), allvariable)
        if expressionif is not None and expressionelse is not None:
            predicatestmt="['-1','if2',"+condition+","+expressionif+","+expressionelse+"]"
        elif expressionif is not None and expressionelse is None:
            predicatestmt="['-1','if1',"+condition+","+expressionif+"]"
        if expression.getIsPrime()==False:
            if programsstart=="":
                programsstart="['-1','seq',"+predicatestmt
                programsend="]"
            else:
                programsstart+=",['-1','seq',"+predicatestmt
                programsend+="]"
        else:
            if programsstart=="":
                programsstart=predicatestmt+programsend
            else:
                programsstart+=","+predicatestmt+programsend
    #print('~~~~~~~~~~~~~~~~')
    #print(programsstart)
    #print('2~~~~~~~~~~~~~~~~end')
    return programsstart


"""

Program Expression to a Array of Statement Compatible to Translator Program 

"""

fun_call_map={}
current_fun_call=None


def expressionCreator_C(statement):
    expression=""
    global defineMap
    global defineDetaillist
    global fun_call_map
    global current_fun_call
    if type(statement) is c_ast.ID:
        if statement.name in defineMap.keys():
            value = defineMap[statement.name]
            return str(eval("expres('"+value+"')"))
        else:
        	return str(eval("expres('"+statement.name+"')"))
    elif type(statement) is c_ast.Constant:
        if statement.type=='char':
                if str(statement.value)==str("'\\0'"):
                    return str(eval("expres('0')"))
                else:
                    return "['char',expres("+statement.value+")]"
        elif statement.type=='float':
            if statement.value[-1]=='f':
    			#return "expres('"+str(round(float(statement.value[:-1]), 7))+"')"
                return str(eval("expres('"+str(statement.value[:-1])+"')"))
	        #return "expres('"+str(float(statement.value))+"')"
            return str(eval("expres('"+str(statement.value)+"')"))
        elif statement.type=='double':
            #return "expres('"+str(float(statement.value))+"')"
            return str(eval("expres('"+str(statement.value)+"')"))
        else:
        	if is_hex(statement.value) is not None:
        		return str(eval("expres('"+is_hex(statement.value)+"')"))
        	else:
        		return str(eval("expres('"+statement.value+"')"))
    elif type(statement) is c_ast.FuncCall:
        parameter=''
        parameter_list=[]
        defineDetaillist=[]
        defineDetailtemp=[]
        parameter_list.append('int')
        if statement.args is not None:
            for param in statement.args.exprs:
                if type(param) is c_ast.ID:
                    parameter_list.append('int')
                    if param.name in defineMap.keys():
                        param.name = defineMap[param.name]
                    if parameter=='':
                        parameter = str(eval("expres('"+param.name+"')"))
                    else:
                        parameter += ","+str(eval("expres('"+param.name+"')"))
                elif type(param) is c_ast.Constant:
                    parameter_list.append('int')
                    if parameter=='':
                        if is_hex(param.value) is not None:
                            parameter = str(eval("expres('"+is_hex(param.value)+"')"))
                        else:
                            parameter = str(eval("expres('"+param.value+"')"))
                    else:
                        if is_hex(param.value) is not None:
                            parameter += ","+str(eval("expres('"+is_hex(param.value)+"')"))
                        else:
                            parameter += ","+str(eval("expres('"+param.value+"')"))
                elif type(param) is c_ast.UnaryOp:
                    if parameter=='':
                        parameter = str(eval("expres('"+param.op+"',["+expressionCreator_C(param.expr)+"])"))
                    else:
                        parameter +=','+str(eval("expres('"+param.op+"',["+expressionCreator_C(param.expr)+"])"))
                elif type(param) is c_ast.BinaryOp:
                    if parameter=='':
                        parameter =expressionCreator_C(param)
                    else:
                        parameter +=','+expressionCreator_C(param)
                elif type(param) is c_ast.FuncCall:
                    if parameter=='':
                        parameter =expressionCreator_C(param)
                    else:
                        parameter +=','+expressionCreator_C(param)
                else:
                    if type(param) is c_ast.ArrayRef:
                        parameter_list.append('int')
                        degree=0
                        stmt,degree=createArrayList_C(param,degree)
                        if parameter=='':
                            parameter = str(eval("expres('d"+str(degree)+'array'+"',["+stmt+"])"))
                        else:
                            parameter += ","+str(eval("expres('d"+str(degree)+'array'+"',["+stmt+"])"))
				
				#print '@@@@@@@@@@@RamRam'
				#print param.show()
				#print '@@@@@@@@@@@'
            if 'uniform' in statement.name.name:
                   parameter="['"+statement.name.name+"'],"+parameter
                   return "['RV',"+parameter+"]"
            elif 'gauss' in statement.name.name:
                   parameter="['"+statement.name.name+"'],"+parameter
                   return "['RV',"+parameter+"]"
            else:
                 defineDetailtemp.append(statement.name.name)
                 defineDetailtemp.append(len(parameter_list)-1)
                 defineDetailtemp.append(parameter_list)
                 defineDetaillist.append(defineDetailtemp)
                
            #if statement.name.name in fun_call_map.keys() and statement.name.name != current_fun_call and '__VERIFIER_nondet_' not in statement.name.name:
            #        fc_count=fun_call_map[statement.name.name]
            #        fc_count+=1
            #        fun_call_map[statement.name.name]=fc_count
            #        return "['"+statement.name.name+"_"+str(fc_count)+"',"+parameter+"]"
            #else:
            #        fun_call_map[statement.name.name]=0
            return "['"+statement.name.name+"',"+parameter+"]"
        else:
            if '__VERIFIER_nondet_' not in statement.name.name:
                    defineDetailtemp.append(statement.name.name)
                    defineDetailtemp.append(len(parameter_list)-1)
                    defineDetailtemp.append(parameter_list)
                    defineDetaillist.append(defineDetailtemp)
            #if statement.name.name in fun_call_map.keys() and statement.name.name != current_fun_call and '__VERIFIER_nondet_' not in statement.name.name:
            #        fc_count=fun_call_map[statement.name.name]
            #        fc_count+=1
            #        fun_call_map[statement.name.name]=fc_count
            #        return str(eval("expres('"+statement.name.name+"_"+str(fc_count)+"'"+")"))
            #else:
            #        fun_call_map[statement.name.name]=0
            return str(eval("expres('"+statement.name.name+"'"+")"))
                    
    elif type(statement) is c_ast.ArrayRef:
        degree=0
        stmt,degree=createArrayList_C(statement,degree)
        return str(eval("expres('d"+str(degree)+'array'+"',["+stmt+"])"))
    else:
        if type(statement) is c_ast.Cast:
            if statement.to_type.type.type.names[0]=='float':
                return "['"+"_ToReal"+"',"+expressionCreator_C(statement.expr)+"]"
            elif statement.to_type.type.type.names[0]=='double':
                return "['"+"_ToReal"+"',"+expressionCreator_C(statement.expr)+"]"
            elif statement.to_type.type.type.names[0]=='int':
                return "['"+"_ToInt"+"',"+expressionCreator_C(statement.expr)+"]"
        else:
            
            if statement.op in ['+','-','*','/','%']:
                expression="expres('"
                expression+=statement.op
                if type(statement) is c_ast.BinaryOp:
                    expression+="',["+expressionCreator_C(statement.left)
                    expression+=','+expressionCreator_C(statement.right)
                else:
                    expression+="',["+expressionCreator_C(statement.expr)
                expression+='])'
                expression=str(eval(expression))
                return expression
            else:
                #if statement.op == '!=':
                #    statement=c_ast.UnaryOp(op='!', expr=c_ast.BinaryOp(op='==',left=statement.left, right=statement.right))

                expression="['"
                if statement.op == '&&':
                    expression+='and'
                elif statement.op == '||':
                    expression+='or'
                elif statement.op == '!':
                    expression+='not'
                else:
                    expression+=statement.op
                if type(statement) is c_ast.BinaryOp:
                    expression+="',"+expressionCreator_C(statement.left)

                    expression+=','+expressionCreator_C(statement.right)
                    expression+=']'
                else:
                    expression="expres('"
                    if statement.op == '!':
                            expression+='not'
                    else:
                            expression+=statement.op
                    expression+="',["+expressionCreator_C(statement.expr)+"]"
                    expression+=')'
                    expression=str(eval(expression))
                return expression




"""

Construct Array List

"""
def createArrayList_C(statement,degree):
    if type(statement) is c_ast.ArrayRef:
        degree=degree+1
        stmt=''
        if type(statement.name) is c_ast.ArrayRef:
            stmt,degree=createArrayList_C(statement.name,degree)
            if type(statement.subscript) is c_ast.ID:
                stmt+=",expres('"+statement.subscript.name+"')"
            elif type(statement.subscript) is c_ast.BinaryOp:
                stmt+=","+expressionCreator_C(statement.subscript)
            else:
                stmt+=",expres('"+statement.subscript.value+"')"
            return stmt,degree
        else:
            if type(statement.name) is c_ast.ID:
                if type(statement.subscript) is c_ast.ID:
                    stmt+="expres('"+statement.name.name+"')"+",expres('"+statement.subscript.name+"')"
                    return stmt,degree
                elif type(statement.subscript) is c_ast.BinaryOp:
                    stmt+="expres('"+statement.name.name+"')"+","+expressionCreator_C(statement.subscript)
                    return stmt,degree
                else:
                                        if type(statement.subscript) is c_ast.ArrayRef:
                                            temp_degree=0
                                            temp_stmt,temp_degree=createArrayList_C(statement.subscript,temp_degree)
                                            stmt+="expres('"+statement.name.name+"')"+","+"expres('d"+str(temp_degree)+'array'+"',["+temp_stmt+"])"
                                            return stmt,degree 
                                        else:
                                            stmt+="expres('"+statement.name.name+"')"+",expres('"+statement.subscript.value+"')"
                                            return stmt,degree
            else:
                if type(statement.name) is c_ast.FuncCall:
                    if type(statement.subscript) is c_ast.FuncCall:
                        stmt+=expressionCreator_C(statement.name)+","+expressionCreator_C(statement.subscript)
                    elif type(statement.subscript) is c_ast.BinaryOp:
                        stmt+=expressionCreator_C(statement.name)+","+expressionCreator_C(statement.subscript)
                    else:
                        stmt+=expressionCreator_C(statement.name)+",expres('"+statement.subscript.value+"')"
                else:
                    stmt+="expres('"+statement.name.value+"')"+",expres('"+statement.subscript.value+"')"
                return stmt,degree
    else:
        return "expres('"+statement.name+"')",degree














    
"""
 
Translate Syntax Code 
 
"""
 

"""

Syntax translation module

"""



def syntaxTranslate(statements):
        update_statements=[]
        for statement in statements:
                if type(statement) is c_ast.UnaryOp:
                        
                        if statement.op=='++' or statement.op=='p++':
                                update_statements.append(c_ast.Assignment(op='=',lvalue=statement.expr, rvalue=c_ast.BinaryOp(op='+',left=statement.expr, right=c_ast.Constant('int','1'))))
                        elif statement.op=='--' or statement.op=='p--':
                                update_statements.append(c_ast.Assignment(op='=',lvalue=statement.expr, rvalue=c_ast.BinaryOp(op='-',left=statement.expr, right=c_ast.Constant('int','1'))))
                        else:
                                update_statements.append(statement)
                elif type(statement) is c_ast.For:
                        if type(statement.init) is c_ast.DeclList:
                            for stmt in statement.init.decls:
                                update_statements.append(stmt)
                        else:
                            update_statements.append(statement.init)
                        if type(statement.stmt) is c_ast.Compound:
                        	new_block_items=statement.stmt.block_items
                        	if new_block_items is None:
                                    new_block_items=[]
                        	new_block_items.append(statement.next)
                        	new_block_items=syntaxTranslate(new_block_items)
                        	new_stmt=c_ast.Compound(block_items=new_block_items)
                        	update_while=c_ast.While(statement.cond,new_stmt)
                        	update_statements.append(update_while)
                        else:
                            new_block_items=[]
                            new_block_items.append(statement.stmt)
                            new_block_items.append(statement.next)
                            new_block_items=syntaxTranslate(new_block_items)
                            new_stmt=c_ast.Compound(block_items=new_block_items)
                            update_while=c_ast.While(statement.cond,new_stmt)
                            update_statements.append(update_while)
                elif type(statement) is c_ast.DoWhile:
                    if type(statement.stmt) is c_ast.Compound:
                        new_block_items=statement.stmt.block_items
                        if new_block_items is None:
                            new_block_items=[]
                        for item in new_block_items:
                            update_statements.append(item)
                        new_block_items=syntaxTranslate(new_block_items)
                        new_stmt=c_ast.Compound(block_items=new_block_items)
                        update_while=c_ast.While(statement.cond,new_stmt)
                        update_statements.append(update_while)
                    else:
                        new_block_items=[]
                        new_block_items.append(statement.stmt)
                        for item in new_block_items:
                            update_statements.append(item)
                        new_block_items=syntaxTranslate(new_block_items)
                        new_stmt=c_ast.Compound(block_items=new_block_items)
                        update_while=c_ast.While(statement.cond,new_stmt)
                        update_statements.append(update_while)
                elif type(statement) is c_ast.Switch:
                    stmts=statement.stmt.block_items
                    statement=convertToIfElse(stmts,statement.cond)
                	#update_statements.append(statement)
                    update_statements.append(syntaxTranslateIf(statement))
                elif type(statement) is c_ast.While:
                    if type(statement.stmt) is c_ast.Compound:
                        update_statements.append(c_ast.While(cond=syntaxTranslateStmt(statement.cond),stmt=c_ast.Compound(block_items=syntaxTranslate(statement.stmt.block_items))))
                    else:
                        new_block_items=[]
                        new_block_items.append(statement.stmt)
                        update_statements.append(c_ast.While(cond=syntaxTranslateStmt(statement.cond),stmt=c_ast.Compound(block_items=syntaxTranslate(new_block_items))))
                elif type(statement) is c_ast.If:
                	update_statements.append(syntaxTranslateIf(statement))
                elif type(statement) is c_ast.Assignment:
                    if statement.op=='+=':
                        if type(statement.lvalue) is c_ast.ID:
                            update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='+', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue)))
                        else:
                            update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='+', left=statement.lvalue, right=statement.rvalue)))
                    elif statement.op=='-=':
                        if type(statement.lvalue) is c_ast.ID:
                            update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='-', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue)))
                        else:
                            update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='-', left=statement.lvalue.name, right=statement.rvalue)))
                    elif statement.op=='/=':
                        if type(statement.lvalue) is c_ast.ID:
                            update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='/', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue)))
                        else:
                            update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='/', left=statement.lvalue, right=statement.rvalue)))
                    elif statement.op=='%=':
                        if type(statement.lvalue) is c_ast.ID:
                            update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='%', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue)))
                        else:
                            update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='%', left=statement.lvalue, right=statement.rvalue)))
                    elif statement.op=='*=':
                        if type(statement.lvalue) is c_ast.ID:
                            update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='*', left=c_ast.ID(name=statement.lvalue.name), right=statement.rvalue)))
                        else:
                            update_statements.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=c_ast.BinaryOp(op='*', left=statement.lvalue, right=statement.rvalue)))
                    else:
                        if type(statement.rvalue) is c_ast.Assignment:
                            stmts=[]
                            separateAllAssignment(statement,stmts)
                            for stmt in stmts:
                                update_statements.append(stmt)
                        else:
                            if type(statement.lvalue) is c_ast.ID and type(statement.rvalue) is c_ast.TernaryOp:
                                update_statements.append(syntaxTranslateStmtTernaryOp(statement))
                                            
                            else:
                                    update_statements.append(c_ast.Assignment(op=statement.op, lvalue=statement.lvalue, rvalue=statement.rvalue))
                
                elif type(statement) is c_ast.ExprList:
                    statement=syntaxTranslate(statement.exprs)
                    for exp_stmt in statement:
                        update_statements.append(exp_stmt)
                elif type(statement) is c_ast.Label:
                    update_statements.append(c_ast.Label(name=statement.name, stmt=None))
                    if type(statement.stmt) is c_ast.Compound:
                        new_block_items=syntaxTranslate(statement.stmt.block_items)
                        for item in new_block_items:
                            update_statements.append(item)	
                    else:
                        if statement.stmt is not None:
                            new_block_items=[]
                            new_block_items.append(statement.stmt)
                            new_block_items=syntaxTranslate(new_block_items)
                            for item in new_block_items:
                                    update_statements.append(item)

                elif type(statement) is c_ast.Compound:
                	new_stmts=syntaxTranslate(statement.block_items)
                	for stmt in new_stmts:
                		update_statements.append(stmt)
                	
                else:
                        if type(statement) is not c_ast.EmptyStatement:
                        	update_statements.append(statement)
        return update_statements



def syntaxTranslateIf(statement):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			if statement.iftrue.block_items is not None:
				new_iftrue=c_ast.Compound(block_items=syntaxTranslate(statement.iftrue.block_items))
			else:
				new_iftrue=c_ast.Compound(block_items=[])
		else:
			if type(statement.iftrue) is c_ast.UnaryOp:
				new_iftrue=syntaxTranslateStmt(statement.iftrue)
			elif type(statement.iftrue) is c_ast.BinaryOp:
				new_iftrue=syntaxTranslateStmt(statement.iftrue)
			else:
				new_blocks=[]
				new_blocks.append(statement.iftrue)
				new_iftrue=c_ast.Compound(block_items=syntaxTranslate(new_blocks))
				
		if type(statement.iffalse) is c_ast.Compound:
			if statement.iffalse.block_items is not None:
				new_iffalse=c_ast.Compound(block_items=syntaxTranslate(statement.iffalse.block_items))
			else:
				new_iffalse=c_ast.Compound(block_items=[])
		else:
			if type(statement.iffalse) is c_ast.If:
				new_iffalse=syntaxTranslateIf(statement.iffalse)
			else:
				if type(statement.iffalse) is c_ast.UnaryOp:
					new_iffalse=syntaxTranslateStmt(statement.iffalse)
				elif type(statement.iffalse) is c_ast.BinaryOp:
					new_iffalse=syntaxTranslateStmt(statement.iffalse)
				else:
					new_blocks=[]
					new_blocks.append(statement.iffalse)
					new_iffalse=c_ast.Compound(block_items=syntaxTranslate(new_blocks))
	return c_ast.If(cond=syntaxTranslateStmt(statement.cond), iftrue=new_iftrue, iffalse=new_iffalse)


#
# Change Assignment statement to a list of Assignment statements
#


def separateAllAssignment(statement,stmts):
	if type(statement) is c_ast.Assignment:
		if type(statement.rvalue) is c_ast.Assignment:
			value=separateAllAssignment(statement.rvalue,stmts)
			stmts.append(c_ast.Assignment(op=statement.op, lvalue=statement.lvalue, rvalue=value))
			return value
		else:
			stmts.append(c_ast.Assignment(op=statement.op, lvalue=statement.lvalue, rvalue=statement.rvalue))
			return statement.rvalue
	return None
	

"""

Covert Switch Case to If-Else-If loop

"""



def convertToIfElse(statements,condition):
	if statements is not None and len(statements)>0:
		statement=statements[0]
		if type(statement) is not c_ast.Default:
			new_condition_left=constructCondition(statements,condition)
			new_condition_right,new_block_items,statements,is_break=constructBody(statements,condition)
			new_compund_left=c_ast.Compound(block_items=new_block_items)
			
			if new_condition_left is not None:
				new_Else_stmt=convertToIfElse(statements,condition)
				new_If_stmt=c_ast.If(cond=c_ast.BinaryOp(op='||', left=new_condition_left, right=new_condition_right),iftrue=new_compund_left,iffalse=new_Else_stmt)
				return new_If_stmt
			else:
				new_Else_stmt=convertToIfElse(statements,condition)
				new_If_stmt=c_ast.If(cond=new_condition_right,iftrue=new_compund_left,iffalse=new_Else_stmt)
				return new_If_stmt
		else:
			update_stmts=[]
			for stmt in statement.stmts:
				#if type(stmt) is not c_ast.Break:
                                update_stmts.append(stmt)
			return c_ast.Compound(block_items=update_stmts)
		

	return None


def syntaxTranslateStmt(statement):
    if type(statement) is c_ast.UnaryOp:
        if statement.op=='++' or statement.op=='p++':
	        	return c_ast.Assignment(op='=',lvalue=statement.expr, rvalue=c_ast.BinaryOp(op='+',left=statement.expr, right=c_ast.Constant('int','1')))
        elif statement.op=='--' or statement.op=='p--':
	        	return c_ast.Assignment(op='=',lvalue=statement.expr, rvalue=c_ast.BinaryOp(op='-',left=statement.expr, right=c_ast.Constant('int','1')))
        else:
                return statement
    else:
        if type(statement) is c_ast.BinaryOp:
            return c_ast.BinaryOp(op=statement.op,left=syntaxTranslateStmt(statement.left),right=syntaxTranslateStmt(statement.right))
        else:
            return statement



def syntaxTranslateStmtTernaryOp(statement):
    new_blocks_true=[]
    
    new_blocks_true.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=statement.rvalue.iftrue))
    new_iftrue=c_ast.Compound(block_items=syntaxTranslate(new_blocks_true))
                        
    new_blocks_false=[]
    
    new_blocks_false.append(c_ast.Assignment(op='=', lvalue=statement.lvalue, rvalue=statement.rvalue.iffalse))
    new_iffalse=c_ast.Compound(block_items=syntaxTranslate(new_blocks_false))
                        
    return c_ast.If(cond=statement.rvalue.cond,iftrue=new_iftrue,iffalse=new_iffalse)




"""

Covert Switch Case to If-Else-If loop

"""

	
def constructCondition(statements,condition):
	if statements is not None and len(statements)>0:
		statement=statements[0]
		if type(statement) is not c_ast.Default:
			if len(statement.stmts)==0:
				new_condition_left=c_ast.BinaryOp(op='==', left=condition, right=statement.expr)
				new_condition_right=constructCondition(statements[1:],condition)
				if new_condition_right is None:
					return new_condition_left
				else:
					return c_ast.BinaryOp(op='||', left=new_condition_left, right=new_condition_right)
			else:
				return None
		else:
			return None
	return None


"""

Covert Switch Case to If-Else-If loop

"""


def constructBody(statements,condition):
	if statements is not None and len(statements)>0:
		statement=statements[0]
		if type(statement) is not c_ast.Default:
			if len(statement.stmts)>0:
				update_stmts=[]
				new_condition=c_ast.BinaryOp(op='==', left=condition, right=statement.expr)
				is_break=False
				for stmt in statement.stmts:
					if type(stmt) is c_ast.Break:
						is_break=True;
					else:
						update_stmts.append(stmt)
				return new_condition,update_stmts,statements[1:],is_break
			else:
				return constructBody(statements[1:],condition)
		else:
			return None,None,None,False
	return None,None,None,False



			    
"""
 
Goto removal Modules Start

"""

new_variable={}

break_count=0

continue_count=0



def remove_return(statements,membermethod):
    end_label_map={}
    statements=returnReplacement(statements,end_label_map)
    update_statements=[]
    if isRetPresent(statements)==True:
            if membermethod is not None:
                if membermethod.getreturnType() is not None and membermethod.getreturnType() is not 'array':
                    temp=c_ast.Decl(name='RET', quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname='RET', quals=[], type=c_ast.IdentifierType(names=[membermethod.getreturnType()])), init=c_ast.Constant(type=membermethod.getreturnType(), value='0'), bitsize=None)
                    update_statements.append(temp)
                else:
                    temp=c_ast.Decl(name='RET', quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname='RET', quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
                    update_statements.append(temp)
    for statement in statements:
        update_statements.append(statement)
    for label in end_label_map.keys():
        update_statements.append(c_ast.Label(name=label, stmt=None))
    return update_statements



def isRetPresent(statements):
    status_flag=False
    for statement in statements:
        if type(statement) is c_ast.Assignment:
            if type(statement.lvalue) is not c_ast.UnaryOp and type(statement.lvalue.name) is str and 'RET' in statement.lvalue.name:
                status_flag=True
        elif type(statement) is c_ast.If:
            if isRetPresentIf(statement)==True:
                status_flag=True
    return status_flag

def isRetPresentIf(statement):
    status_flag=False
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            if statement.iftrue.block_items is not None:
                    if isRetPresent(statement.iftrue.block_items)==True:
                        status_flag=True
        else:
            if type(statement.iftrue) is c_ast.Assignment:
                        if type(statement.iftrue.lvalue) is not c_ast.UnaryOp and type(statement.iftrue.lvalue.name) is str and 'RET' in statement.iftrue.lvalue.name:
                            status_flag=True
        if type(statement.iffalse) is c_ast.Compound:
            if statement.iffalse.block_items is not None:
                    if isRetPresent(statement.iffalse.block_items)==True:
                            status_flag=True
        elif type(statement.iffalse) is c_ast.If:
            new_iffalse=isRetPresentIf(statement.iffalse)
        else:
            if type(statement.iffalse) is c_ast.Assignment:
                        if type(statement.iffalse.lvalue) is not c_ast.UnaryOp and type(statement.iffalse.lvalue.name) is str and 'RET' in statement.iffalse.lvalue.name:
                            status_flag=True
    return status_flag


"""

Is Variable is present and Type


"""

def isVarPresnt(statements,variable_name):
    status_flag=False
    for statement in statements:
        if type(statement) is c_ast.Assignment:
                flag_r=isVarPresntStmt(statement.rvalue,variable_name)
                flag_l=isVarPresntStmt(statement.lvalue,variable_name)
                if flag_r==True and flag_l==True:
                    return True
                elif flag_r==False and flag_l==True:
                    return True 
                elif flag_r==True and flag_l==False:
                    return True 
        elif type(statement) is c_ast.If:
            if isVarPresntIf(statement,variable_name)==True:
                return True
        elif type(statement) is c_ast.While:
            if type(statement.stmt) is c_ast.Compound:
                if isVarPresnt(statement.stmt.block_items,variable_name)==True:
                    return True
    return False

def isVarPresntIf(statement,variable_name):
    status_flag=False
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            if statement.iftrue.block_items is not None:
                                if isVarPresnt(statement.iftrue.block_items,variable_name)==True:
                                    status_flag=True
        else:
                    if type(statement.iftrue) is c_ast.Assignment:
                        flag_r=isVarPresntStmt(statement.iftrue.rvalue,variable_name)
                        flag_l=isVarPresntStmt(statement.iftrue.lvalue,variable_name)
                        if flag_r==True and flag_l==True:
                            status_flag = True
                        elif flag_r==False and flag_l==True:
                            status_flag = True 
                        elif flag_r==True and flag_l==False:
                            status_flag = True
        if type(statement.iffalse) is c_ast.Compound:
            if statement.iffalse.block_items is not None:
                            if isVarPresnt(statement.iffalse.block_items,variable_name)==True:
                                    status_flag=True
        elif type(statement.iffalse) is c_ast.If:
            if isVarPresntIf(statement.iffalse,variable_name):
                            status_flag=True
        else:
                    if type(statement.iffalse) is c_ast.Assignment:
                        flag_r=isVarPresntStmt(statement.iffalse.rvalue,variable_name)
                        flag_l=isVarPresntStmt(statement.iffalse.lvalue,variable_name)
                        if flag_r==True and flag_l==True:
                            status_flag = True
                        elif flag_r==False and flag_l==True:
                            status_flag = True 
                        elif flag_r==True and flag_l==False:
                            status_flag = True
    return status_flag


def isVarPresntStmt(statement,variable_name):
    if type(statement) is c_ast.UnaryOp:
                return isVarPresntStmt(statement.expr,variable_name)
    elif type(statement) is c_ast.BinaryOp:
                flag_r=isVarPresntStmt(statement.right,variable_name)
                flag_l=isVarPresntStmt(statement.left,variable_name)
                if flag_r==True and flag_l==True:
                    return True
                elif flag_r==False and flag_l==True:
                    return True 
                elif flag_r==True and flag_l==False:
                    return True 
                else:
                    return False 
    elif type(statement) is c_ast.ID:
            if variable_name==statement.name:
                return True
            else:
                return False
    elif type(statement) is c_ast.StructRef:
            return isVarPresntStmt(statement.name,variable_name)
    elif type(statement) is c_ast.ArrayRef:
            if variable_name == getArrayName(statement):
                return True
            else:
                return False
    else:
            return False









"""

Method for simplification of Condition

"""

def simplifyCondition(statement):
	if type(statement) is c_ast.UnaryOp:
		if statement.op=='!':
			if type(statement.expr) is c_ast.ID:
				return statement
			elif type(statement.expr) is c_ast.Constant:
				return statement
			elif type(statement.expr) is c_ast.ArrayRef:
				return statement
			elif type(statement.expr) is c_ast.FuncCall:
				return statement
			else:
				return getComplement(statement.expr)
		else:
			return c_ast.UnaryOp(op=statement.op,expr=simplifyCondition(statement.expr))
	elif type(statement) is c_ast.BinaryOp:
		return c_ast.BinaryOp(op=statement.op,left=simplifyCondition(statement.left), right=simplifyCondition(statement.right))
	else:
		return statement

"""

Method for Generate  Complement of Condition

"""


def getComplement(statement):
	if type(statement) is c_ast.UnaryOp:
		if statement.op=='!': 
			return simplifyCondition(statement.expr)
		else:
			return c_ast.UnaryOp(op=statement.op,expr=simplifyCondition(statement.expr))
	
	elif type(statement) is c_ast.BinaryOp:
		if statement.op=='<':
			return c_ast.BinaryOp(op='>=',left=getComplement(statement.left), right=getComplement(statement.right))
		elif statement.op=='>':
			return c_ast.BinaryOp(op='<=',left=getComplement(statement.left), right=getComplement(statement.right))
		elif statement.op=='<=':
			return c_ast.BinaryOp(op='>',left=getComplement(statement.left), right=getComplement(statement.right))
		elif statement.op=='>=':
			return c_ast.BinaryOp(op='<',left=getComplement(statement.left), right=getComplement(statement.right))
		elif statement.op=='!=':
			return c_ast.BinaryOp(op='==',left=getComplement(statement.left), right=getComplement(statement.right))
		elif statement.op=='==':
			return c_ast.BinaryOp(op='!=',left=getComplement(statement.left), right=getComplement(statement.right))
		elif statement.op=='&&':
			return c_ast.BinaryOp(op='||',left=getComplement(statement.left), right=getComplement(statement.right))
		elif statement.op=='||':
			return c_ast.BinaryOp(op='&&',left=getComplement(statement.left), right=getComplement(statement.right))
		else:
			return c_ast.BinaryOp(op=statement.op,left=getComplement(statement.left), right=getComplement(statement.right))


	else:
		return statement




"""

For Whole program

"""

def changeCondition(statement):
	if type(statement) is c_ast.ID:
		return c_ast.BinaryOp(op='>',left=statement,right=c_ast.Constant(type='int', value='0'))
	elif type(statement) is c_ast.Constant:
		return c_ast.BinaryOp(op='>',left=statement,right=c_ast.Constant(type='int', value='0'))
	elif type(statement) is c_ast.FuncCall:
		return c_ast.BinaryOp(op='>',left=statement,right=c_ast.Constant(type='int', value='0'))
	elif type(statement) is c_ast.ArrayRef:
		return c_ast.BinaryOp(op='>',left=statement,right=c_ast.Constant(type='int', value='0'))
	elif type(statement) is c_ast.UnaryOp:
		if statement.op=='!':
			if type(statement.expr) is c_ast.ID:
				return c_ast.BinaryOp(op='<=',left=statement.expr,right=c_ast.Constant(type='int', value='0'))
			elif type(statement.expr) is c_ast.Constant:
				return c_ast.BinaryOp(op='<=',left=statement.expr,right=c_ast.Constant(type='int', value='0'))
			elif type(statement.expr) is c_ast.FuncCall:
				return c_ast.BinaryOp(op='<=',left=statement.expr,right=c_ast.Constant(type='int', value='0'))
			elif type(statement.expr) is c_ast.ArrayRef:
				return c_ast.BinaryOp(op='<=',left=statement.expr,right=c_ast.Constant(type='int', value='0'))
			else:
				return statement
		else:
			return statement
	elif type(statement) is c_ast.BinaryOp:
                left_stmt=None
                right_stmt=None
                if statement.op=='||':
                    if type(statement.left) is c_ast.ID:
                        left_stmt=c_ast.BinaryOp(op='>',left=statement.left,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.left) is c_ast.Constant:
                        left_stmt=c_ast.BinaryOp(op='>',left=statement.left,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.left) is c_ast.FuncCall:
                        left_stmt=c_ast.BinaryOp(op='>',left=statement.left,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.left) is c_ast.ArrayRef:
                        left_stmt=c_ast.BinaryOp(op='>',left=statement.left,right=c_ast.Constant(type='int', value='0'))
                    else:
                        left_stmt=changeCondition(statement.left)
                        
                    if type(statement.right) is c_ast.ID:
                        right_stmt=c_ast.BinaryOp(op='>',left=statement.right,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.right) is c_ast.Constant:
                        right_stmt=c_ast.BinaryOp(op='>',left=statement.right,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.right) is c_ast.FuncCall:
                        right_stmt=c_ast.BinaryOp(op='>',left=statement.right,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.right) is c_ast.ArrayRef:
                        right_stmt=c_ast.BinaryOp(op='>',left=statement.right,right=c_ast.Constant(type='int', value='0'))
                    else:
                        right_stmt=changeCondition(statement.right)
                    return c_ast.BinaryOp(op=statement.op,left=left_stmt, right=right_stmt)
                elif statement.op=='&&':
                    if type(statement.left) is c_ast.ID:
                        left_stmt=c_ast.BinaryOp(op='>',left=statement.left,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.left) is c_ast.Constant:
                        left_stmt=c_ast.BinaryOp(op='>',left=statement.left,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.left) is c_ast.FuncCall:
                        left_stmt=c_ast.BinaryOp(op='>',left=statement.left,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.left) is c_ast.ArrayRef:
                        left_stmt=c_ast.BinaryOp(op='>',left=statement.left,right=c_ast.Constant(type='int', value='0'))
                    else:
                        left_stmt=changeCondition(statement.left)
                        
                    if type(statement.right) is c_ast.ID:
                        right_stmt=c_ast.BinaryOp(op='>',left=statement.right,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.right) is c_ast.Constant:
                        right_stmt=c_ast.BinaryOp(op='>',left=statement.right,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.right) is c_ast.FuncCall:
                        right_stmt=c_ast.BinaryOp(op='>',left=statement.right,right=c_ast.Constant(type='int', value='0'))
                    elif type(statement.right) is c_ast.ArrayRef:
                        right_stmt=c_ast.BinaryOp(op='>',left=statement.right,right=c_ast.Constant(type='int', value='0'))
                    else:
                        right_stmt=changeCondition(statement.right)
                    return c_ast.BinaryOp(op=statement.op,left=left_stmt, right=right_stmt)
                else:
                 	return statement
                        
		
	else:
		return statement




def modificationOfCondition(statement):
    if type(statement) is c_ast.ID:
        return True,statement
    elif type(statement) is c_ast.Constant:
        return True,statement
    elif type(statement) is c_ast.FuncCall:
        return True,statement
    elif type(statement) is c_ast.UnaryOp:
        if statement.op=='!':
            status,statement.expr=modificationOfCondition(statement.expr)
            if status==True:
                return False,c_ast.BinaryOp(op='<=',left=statement.expr,right=c_ast.Constant(type='int', value='0'))
            else:
                return True,statement
        else:
            return True,statement
    elif type(statement) is c_ast.BinaryOp:
        left_stmt=None
        right_stmt=None
        if statement.op=='||':
            status,left_stmt=modificationOfCondition(statement.left)
            if status==True:
                left_stmt=c_ast.BinaryOp(op='>',left=left_stmt,right=c_ast.Constant(type='int', value='0'))
            status=False
            status,right_stmt=modificationOfCondition(statement.right)
            if status==True:
                right_stmt=c_ast.BinaryOp(op='>',left=right_stmt,right=c_ast.Constant(type='int', value='0'))
            return False,c_ast.BinaryOp(op=statement.op,left=left_stmt, right=right_stmt)
        elif statement.op=='&&':
            status,left_stmt=modificationOfCondition(statement.left)
            if status==True:
                left_stmt=c_ast.BinaryOp(op='>',left=left_stmt,right=c_ast.Constant(type='int', value='0'))
            status=False
            status,right_stmt=modificationOfCondition(statement.right)
            if status==True:
                right_stmt=c_ast.BinaryOp(op='>',left=right_stmt,right=c_ast.Constant(type='int', value='0'))
            return False,c_ast.BinaryOp(op=statement.op,left=left_stmt, right=right_stmt)
        elif statement.op=='>':
            return False,statement
        elif statement.op=='<':
            return False,statement
        elif statement.op=='>=':
            return False,statement
        elif statement.op=='<=':
            return False,statement
        elif statement.op=='=':
            return False,statement
        elif statement.op=='==':
            return False,statement
        elif statement.op=='!=':
            return False,statement
        else:
            status1,left_stmt=modificationOfCondition(statement.left)
            status2,right_stmt=modificationOfCondition(statement.right)
            if status1==True and status2==True:
                return True,c_ast.BinaryOp(op=statement.op,left=left_stmt,right=right_stmt)
            else:
                return False,c_ast.BinaryOp(op=statement.op,left=left_stmt,right=right_stmt)
			
    else:
        return False,statement
		


def changeConditionProgram(statements):
	if statements is not None:
		update_statements=[]
		for statement in statements:
			if type(statement) is c_ast.If:
				update_statements.append(changeConditionProgramIf(statement))
			elif type(statement) is c_ast.While:
				update_statements.append(c_ast.While(cond=changeCondition(statement.cond),stmt=c_ast.Compound(block_items=changeConditionProgram(statement.stmt.block_items))))
			else:
				update_statements.append(statement)
		return update_statements			
	return None



def changeConditionProgramIf(statement):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			if statement.iftrue.block_items is not None:
				new_iftrue=c_ast.Compound(block_items=changeConditionProgram(statement.iftrue.block_items))
			else:
				new_iftrue=statement.iftrue
		else:
			new_iftrue=statement.iftrue
		if type(statement.iffalse) is c_ast.Compound:
			if statement.iffalse.block_items is not None:
				new_iffalse=c_ast.Compound(block_items=changeConditionProgram(statement.iffalse.block_items))
			else:
				new_iftrue=statement.iffalse
		elif type(statement.iffalse) is c_ast.If:
			new_iffalse=changeConditionProgramIf(statement.iffalse)
		else:
			new_iffalse=statement.iffalse
	return c_ast.If(cond=changeCondition(statement.cond),iftrue=new_iftrue,iffalse=new_iffalse)




def simplifyProgram(statements):
	if statements is not None:
		update_statements=[]
		for statement in statements:
			if type(statement) is c_ast.If:
				update_statements.append(simplifyProgram_If(statement))
			elif type(statement) is c_ast.While:
				update_statements.append(c_ast.While(cond=simplifyCondition(statement.cond),stmt=c_ast.Compound(block_items=simplifyProgram(statement.stmt.block_items))))
			else:
				update_statements.append(statement)
		return update_statements			
	return None



def simplifyProgram_If(statement):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			if statement.iftrue.block_items is not None:
				new_iftrue=c_ast.Compound(block_items=simplifyProgram(statement.iftrue.block_items))
			else:
				new_iftrue=statement.iftrue
		else:
			new_iftrue=statement.iftrue
		if type(statement.iffalse) is c_ast.Compound:
			if statement.iffalse.block_items is not None:
				new_iffalse=c_ast.Compound(block_items=simplifyProgram(statement.iffalse.block_items))
			else:
				new_iftrue=statement.iffalse
		elif type(statement.iffalse) is c_ast.If:
			new_iffalse=simplifyProgram_If(statement.iffalse)
		else:
			new_iffalse=statement.iffalse
	return c_ast.If(cond=simplifyCondition(statement.cond),iftrue=new_iftrue,iffalse=new_iffalse)



def removeDeadCode(statements):
	update_statements=[]
	flag=False
	if statements is not None:
		for statement in statements:
			if type(statement) is c_ast.Goto:
				flag=True
			elif type(statement) is c_ast.Label:
				flag=False
				stmts=statement.stmt
				if stmts is not None:
					for stmt in stmts:
						update_statements.append(stmt)
			else:
				if flag==False:
					update_statements.append(statement)
	return update_statements



def gotoremoval(statements):
    if statements is not None:
        label_map=constructLabelTable(statements,0,0,0)
        updateLabelTable(statements,0,0,0,label_map)
        keys= list(label_map.keys())
        for key in keys:
            labelMap={}
            listL=label_map[key]
            if len(listL[3])>1:
                    statements=removeMultipleLabel(statements,key,labelMap)
                    statements=addMultipleLabel(statements,key,labelMap)
                    label_map=constructLabelTable(statements,0,0,0)
                    updateLabelTable(statements,0,0,0,label_map)
            else:
                    if len(listL[3])==0:
                        #statements=removeOrphanLabel(statements,key)
                        label_map=constructLabelTable(statements,0,0,0)
                        updateLabelTable(statements,0,0,0,label_map)
    			
        label_map=constructLabelTable(statements,0,0,0)
        updateLabelTable(statements,0,0,0,label_map)
    		
    		
        blank_label_map1={}
        blank_label_map2={}
        for element in list(label_map.keys()):
            temp_list=label_map[element]
            temp_temp_list=temp_list[3]
            temp_temp_list1=[]
            temp_temp_list2=[]
            for iteam in temp_temp_list:
                if iteam[3] is not None:
                    temp_temp_list1.append(iteam)
                else:
                    temp_temp_list2.append(iteam)
			
			
            if len(temp_temp_list1)>0:
                temp_list1=[]
                temp_list1.append(temp_list[0])
                temp_list1.append(temp_list[1])
                temp_list1.append(temp_list[2])
                temp_list1.append(temp_temp_list1)
                blank_label_map1[element]=temp_list1
			
            if len(temp_temp_list2)>0:
                temp_list2=[]
                temp_list2.append(temp_list[0])
                temp_list2.append(temp_list[1])
                temp_list2.append(temp_list[2])
                temp_list2.append(temp_temp_list2)
                blank_label_map2[element]=temp_list2
		

        label_map=blank_label_map1
        keys=list(label_map.keys())
        if len(keys)>0:
            item=keys[0]
            element = label_map[item]
            Lists = element[3]
            for List in Lists:
                    if element[0]>=List[0] and element[1]>=List[1]:
                        statements=goto_finder(statements,item)
                        statements=go_block_finder(statements,item)
                        statements=gotoremoval(statements)
                    else:
                        if element[1]>=1:
                            statements=label_finder_inside(statements,item)
                            statements=go_block_finder(statements,item)
                            statements=gotoremoval(statements)
                        else:
                            #generator = c_generator.CGenerator()
                            #print('XXXXXXXXXXX-XXXXXXXXXXXX1')
                            #print(item)
                            statements=label_finder(statements,item)
                            #print('#######@1')
                            #print(generator.visit(c_ast.Compound(block_items=statements)))
                            #print('#######@1')
                            statements=go_block_finder(statements,item)
                            #print('#######@2')
                            #print(generator.visit(c_ast.Compound(block_items=statements)))
                            #print('#######@2')
                            statements=gotoremoval(statements)
                            #print('#######@3')
                            #print(generator.visit(c_ast.Compound(block_items=statements)))
                            #print('#######@3')

    return statements





#Finding Goto in a Block to Call gotomovein
#Parameter pass block of statement 
#Label
testcount=0

def go_block_finder(statements,label):
	if statements is not None:
		flag_block_label=check_label_block(statements,label)  
		flag_block_goto=check_goto_block_Sp(statements,label)
		if flag_block_label==True and flag_block_goto==True:
			return remove_goto_block(statements,label)
		else:
			update_statements=[]
			for statement in statements:
				if type(statement) is c_ast.If:
					update_statements.append(go_block_finder_if(statement,label))
				elif type(statement) is c_ast.While:
					update_statements.append(c_ast.While(cond=statement.cond, stmt=c_ast.Compound(block_items=go_block_finder(statement.stmt.block_items,label))))
				else:
					update_statements.append(statement)
		return update_statements
	return statements
				


#Finding Goto in a If Block to Call gotomovein
#Parameter pass statement 
#Label

def go_block_finder_if(statement,label):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			if statement.iftrue.block_items is not None:
				new_iftrue=c_ast.Compound(block_items=go_block_finder(statement.iftrue.block_items,label))
			else:
				new_iftrue=statement.iftrue
		else:
			new_iftrue=statement.iftrue
		if type(statement.iffalse) is c_ast.Compound:
			if statement.iffalse.block_items is not None:
				new_iffalse=c_ast.Compound(block_items=go_block_finder(statement.iffalse.block_items,label))
			else:
				new_iftrue=statement.iffalse
		elif type(statement.iffalse) is c_ast.If:
			new_iffalse=go_block_finder_if(statement.iffalse,label)
		else:
			new_iffalse=statement.iffalse
	return c_ast.If(cond=statement.cond,iftrue=new_iftrue,iffalse=new_iffalse)






#Method to Remove Goto 


def remove_goto_block(statements,label): 
    flag_block_label=check_label_block(statements,label)  
    flag_block_goto=check_goto_block_Sp(statements,label)
    flag_block2,condition=check_goto(statements,label)
    flag_label=False
    flag_goto=False
    new_statements1=[]
    new_statements2=[]
    process_part1=False
    process_part2=False
    generator = c_generator.CGenerator()
    #print('#######@1start')
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print('#######@1start')
    if flag_block_label==True and flag_block_goto==True:
                #print '#######1234'
                #generator = c_generator.CGenerator() 
                #print(generator.visit(c_ast.Compound(block_items=statements)))
                #print '#######1234'
        for statement in statements:
			#print type(statement)
			#print flag_label
			#print flag_goto
            if type(statement) is c_ast.Label:
                if label==statement.name:
                    process_part2=True			
                    if flag_goto==True:
                        new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2),iffalse=None))
                        if type(statement.stmt) is c_ast.Assignment:
                            new_statements1.append(statement.stmt)
                        elif type(statement.stmt) is c_ast.Compound:
                            if statement.stmt is not None and statement.stmt.block_items is not None:
                                for stmt in statement.stmt.block_items:
                                    new_statements1.append(stmt)
                        else:
                            new_statements1.append(statement.stmt)
                        flag_label=False
                        flag_goto=False
                    else:
                        if type(statement.stmt) is c_ast.Assignment:
                            new_statements2.append(statement.stmt)
                        elif type(statement.stmt) is c_ast.Compound:
                            if statement.stmt is not None and statement.stmt.block_items is not None:
                                for stmt in statement.stmt.block_items:
                                    new_statements2.append(stmt)
                        flag_label=True
                else:
                    if flag_goto==True or flag_label==True:
                        if type(statement.stmt) is c_ast.Assignment:
                            new_statements2.append(c_ast.Label(name=statement.name, stmt=None))
                            new_statements2.append(statement.stmt)
                        elif type(statement.stmt) is c_ast.Compound:
                            new_statements2.append(c_ast.Label(name=statement.name, stmt=None))
                            if statement.stmt is not None and statement.stmt.block_items is not None:
                                for stmt in statement.stmt.block_items:
                                    new_statements2.append(stmt)
                        else:
                            new_statements2.append(statement)
                    else:
                        new_statements1.append(statement)
            elif type(statement) is c_ast.If:
                flag_block_goto=check_goto_block_If(statement,label)
                if flag_block_goto:
                    process_part1=True
                    if flag_label==True:
                        print('==============================1')
                        print(label)
                        print('==============================1')
                        statement=getRidOfGoto(statement,label)
                        for stmt in new_statements2:
                            new_statements1.append(stmt)
                        new_statements1.append(statement)
						
                        new_break_map={}
                        new_statements2=reOrganizeBreaks(new_statements2,new_break_map)

                        new_statements1.append(c_ast.While(cond=condition, stmt=c_ast.Compound(block_items=new_statements2)))
                        new_statements1=addingBreakVariables(new_statements1,new_break_map)
                        flag_label=False
                        flag_goto=False
                    else:
                        #print('==============================2')
                        #print(label)
                        #print('==============================2')
                        #print('#######@1start')
                        #print(generator.visit(c_ast.Compound(block_items=[statement])))
                        #print('#######@1start')
                        statement=getRidOfGoto(statement,label)
                        #print('#######@1end')
                        #print(generator.visit(c_ast.Compound(block_items=[statement])))
                        #print('#######@1end')
                        new_statements1.append(statement)
                        flag_goto=True
                else:
                    if flag_goto==True or flag_label==True:
                        new_statements2.append(statement)
                    else:
                        new_statements1.append(statement)
            else:
                if flag_goto==True or flag_label==True:
                    new_statements2.append(statement)
                else:
                    new_statements1.append(statement)
	
    if process_part1==True and process_part2==True:
        #print('#######@1end')
        #print(generator.visit(c_ast.Compound(block_items=new_statements1)))
        #print('#######@1end')
        return new_statements1
    else:
        return None
		#return None
				
				
def remove_goto_block_sp(statements,label): 
    flag_block_label=check_label_block(statements,label)  
    flag_block_goto=check_goto_block_Sp(statements,label)
    flag_block2,condition=check_goto(statements,label)
    flag_label=False
    flag_goto=False
    new_statements1=[]
    new_statements2=[]
    if flag_block_label==True and flag_block_goto==True:
        for statement in statements:
            if type(statement) is c_ast.If:
                flag_block_goto=check_goto_block_If(statement,label)
                flag_label_sp=check_label_block_If(statement,label)  
                if flag_label_sp==True and flag_block_goto==False:
                    new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2),iffalse=None))
                    stmt=update_If_removegoto(statement,label,condition)
                    new_statements1.append(stmt)
                elif flag_block_goto:
                    if flag_label==True:
                        print('==============================3')
                        print(label)
                        print('==============================3')
                        statement=getRidOfGoto(statement,label)
                        for stmt in new_statements2:
                            new_statements1.append(stmt)
                        new_statements1.append(statement)
						
                        new_break_map={}
                        new_statements2=reOrganizeBreaks(new_statements2,new_break_map)

                        new_statements1.append(c_ast.While(cond=condition, stmt=c_ast.Compound(block_items=new_statements2)))
                        new_statements1=addingBreakVariables(new_statements1,new_break_map)
                        flag_label=False
                        flag_goto=False
                    else:
                        print('==============================4')
                        print(label)
                        print('==============================4')
                        statement=getRidOfGoto(statement,label)
                        new_statements1.append(statement)
                        flag_goto=True
                else:
                    if flag_goto==True or flag_label==True:
                        new_statements2.append(statement)
                    else:
                        new_statements1.append(statement)
            else:
                if flag_goto==True or flag_label==True:
                    new_statements2.append(statement)
                else:
                    new_statements1.append(statement)

    return new_statements1



def update_If_removegoto(statement,label,condition):
	new_if_stmt=None
	new_else_stmt=None
	if type(statement) is c_ast.If:
            if type(statement.iftrue) is c_ast.Label:
                if statement.iftrue.name==label:
                    new_statements=[]
                    new_statements.append(c_ast.If(cond=condition,iftrue=c_ast.Goto(name=label),iffalse=None))
                    new_statements.append(statement.iftrue)
                    new_if_stmt=c_ast.Compound(block_items=remove_goto_block(new_statements,label))
                else:
                    new_if_stmt=statement.iftrue
                                        
            else:
                        if type(statement.iftrue) is c_ast.Compound and statement.iftrue.block_items is not None:
                            status=False
                            for element in statement.iftrue.block_items:
                                if type(element) is c_ast.Label:
                                        if element.name==label:
                                            status = True
                                if status==True:
                                        	new_statements=[]
                                        	new_statements.append(c_ast.If(cond=condition,iftrue=c_ast.Goto(name=label),iffalse=None))
                                        	for element in statement.iftrue.block_items:
                                        		new_statements.append(element)
                                        	new_if_stmt=c_ast.Compound(block_items=remove_goto_block(new_statements,label))
                                else:
                                        	new_if_stmt=statement.iftrue
                                        		
                                                                
            if type(statement.iffalse) is c_ast.Label:
                                if statement.iffalse.name==label:
                                    new_statements=[]
                                    new_statements.append(c_ast.If(cond=condition,iftrue=c_ast.Goto(name=label),iffalse=None))
                                    new_statements.append(statement.iftrue)
                                    new_if_stmt=c_ast.Compound(block_items=remove_goto_block(new_statements,label))
                                else:
                                	new_else_stmt=statement.iffalse
            else:
                if type(statement.iffalse) is c_ast.Compound and statement.iffalse.block_items is not None:
                            status=False
                            for element in statement.iffalse.block_items:
                                if type(element) is c_ast.Label:
                                    if element.name==label:
                                        status = True
                            if status==True:
                                new_statements=[]
                                new_statements.append(c_ast.If(cond=condition,iftrue=c_ast.Goto(name=label),iffalse=None))
                                for element in statement.iffalse.block_items:
                                    new_statements.append(element)
                                new_else_stmt=c_ast.Compound(block_items=remove_goto_block(new_statements,label))
                            else:
                                new_else_stmt=statement.iffalse
                else:
                    if type(statement.iffalse) is c_ast.If:
                        new_else_stmt=update_If_removegoto(statement.iffalse,label,condition)
	return c_ast.If(cond=c_ast.BinaryOp(op='&&', left=statement.cond, right=condition),iftrue=new_if_stmt,iffalse=new_else_stmt)







    
    
def constructLabelTable(statements,level,block,lineCount):
    label_map={}
    if statements is not None:
        for statement in statements:
            if type(statement) is c_ast.If:
                block=block+1
                label_map_temp=constructLabelTable_If(statement,level,block,lineCount)
                for item in label_map_temp:
                    label_map[item]=label_map_temp[item]
                block=block-1
            elif type(statement) is c_ast.Label:
                lineCount=lineCount+1
                info=[]
                info.append(level)
                info.append(block)
                info.append(lineCount)
                info.append([])
                label_map[statement.name]=info
            else:
                    if type(statement) is c_ast.While:
                        level=level+1
                        label_map_temp=constructLabelTable(statement.stmt.block_items,level,block,lineCount)
                        for item in label_map_temp:
                            label_map[item]=label_map_temp[item]
                        level=level-1
                    else:
                        lineCount=lineCount+1
    return label_map




def constructLabelTable_If(statement,level,block,lineCount):
	label_map={}
	if type(statement) is c_ast.If:
            if type(statement.iftrue) is c_ast.Label:
                lineCount=lineCount+1	            				
                info=[]
                info.append(level)
                nfo.append(block)
                info.append(lineCount)
                info.append([])
                label_map[statement.iftrue.name]=info
            else:
                        if type(statement.iftrue) is c_ast.Compound and statement.iftrue.block_items is not None:
                            for element in statement.iftrue.block_items:
                                if type(element) is c_ast.Label:
                                    lineCount=lineCount+1	            				
                                    info=[]
                                    info.append(level)
                                    info.append(block)
                                    info.append(lineCount)
                                    info.append([])
                                    label_map[element.name]=info
                                elif type(element) is c_ast.If:
                                    block=block+1
                                    label_map_temp=constructLabelTable_If(element,level,block,lineCount)
                                    for item in label_map_temp:
                                        label_map[item]=label_map_temp[item]
                                    block=block-1
                                else:
                                    if type(element) is c_ast.While:
                                        level=level+1
                                        label_map_temp=constructLabelTable(element.stmt.block_items,level,block,lineCount)
                                        for item in label_map_temp:
                                            label_map[item]=label_map_temp[item]
                                        level=level-1
                                    else:
                                        lineCount=lineCount+1
	
            if type(statement.iffalse) is c_ast.Label:
                lineCount=lineCount+1	            				
                info=[]
                info.append(level)
                info.append(block)
                info.append(lineCount)
                info.append([])
                label_map[statement.iffalse.name]=statement.iffalse.name
            else:
                if type(statement.iffalse) is c_ast.Compound and statement.iffalse.block_items is not None:
                            for element in statement.iffalse.block_items:
                                if type(element) is c_ast.Label:
                                    lineCount=lineCount+1
                                    info=[]
                                    info.append(level)
                                    info.append(block)
                                    info.append(lineCount)
                                    info.append([])
                                    label_map[element.name]=info
                                elif type(element) is c_ast.If:
                                    block=block+1
                                    label_map_temp=constructLabelTable_If(element,level,block,lineCount)
                                    for item in label_map_temp:
                                        label_map[item]=label_map_temp[item]
                                    block=block-1
                                else:
                                    if type(element) is c_ast.While:
                                        level=level+1
                                        label_map_temp=constructLabelTable(element.stmt.block_items,level,block,lineCount)
                                        for item in label_map_temp:
                                            label_map[item]=label_map_temp[item]
                                        level=level-1
                                    else:
                                        lineCount=lineCount+1
                else:
                    if type(statement.iffalse) is c_ast.If:
                        label_map_temp=constructLabelTable_If(statement.iffalse,level,block,lineCount)
                        for item in label_map_temp:
                            label_map[item]=label_map_temp[item]
	return label_map

    
    

def updateLabelTable(statements,level,block,lineCount,label_map):
    if statements is not None:
        for statement in statements:
            if type(statement) is c_ast.If:
                updateLabelTable_If(statement,level,block,lineCount,label_map)
            else:
                    if type(statement) is c_ast.While:
                        level=level+1
                        updateLabelTable(statement.stmt.block_items,level,block,lineCount,label_map)
                        level=level-1
                    elif type(statement) is c_ast.Goto:
                                    lineCount=lineCount+1	            				
                                    info=[]
                                    info.append(level)
                                    info.append(block)
                                    info.append(lineCount)
                                    info.append(None)
                                    if statement.name in label_map.keys():
                                        info_update=label_map[statement.name]
                                        list=info_update[3]
                                        list.append(info)	
                    else:
                            lineCount=lineCount+1





def updateLabelTable_If(statement,level,block,lineCount,label_map):
    if type(statement) is c_ast.If:
            if type(statement.iftrue) is c_ast.Goto:
                lineCount=lineCount+1	            				
                info=[]
                info.append(level)
                info.append(block)
                info.append(lineCount)
                info.append(statement.cond)
                if statement.iftrue.name in label_map.keys():
                    info_update=label_map[statement.iftrue.name]
                    list=info_update[3]
                    list.append(info)		

            else:
                    if type(statement.iftrue) is c_ast.Compound and statement.iftrue.block_items is not None:
                            for element in statement.iftrue.block_items:
                                if type(element) is c_ast.Goto:
                                    lineCount=lineCount+1	            				
                                    info=[]
                                    info.append(level)
                                    info.append(block)
                                    info.append(lineCount)
                                    info.append(statement.cond)
                                    if element.name in label_map.keys():
                                        info_update=label_map[element.name]
                                        list=info_update[3]
                                        list.append(info)
                                elif type(element) is c_ast.If:
                                    block=block+1
                                    updateLabelTable_If(element,level,block,lineCount,label_map)
                                    block=block-1
                                else:
                                    if type(element) is c_ast.While:
                                        level=level+1
                                        updateLabelTable(element.stmt.block_items,level,block,lineCount,label_map)
                                        level=level-1
                                    else:
                                        lineCount=lineCount+1
	
            if type(statement.iffalse) is c_ast.Goto:
                lineCount=lineCount+1	            				
                info=[]
                info.append(level)
                info.append(block)
                info.append(lineCount)
                info.append(statement.cond)
                if statement.iffalse.name in label_map.keys():
                    info_update=label_map[statement.iffalse.name]
                    list=info_update[3]
                    list.append(info)
            else:
                if type(statement.iffalse) is c_ast.Compound and statement.iffalse.block_items is not None:
                            for element in statement.iffalse.block_items:
                                if type(element) is c_ast.Goto:
                                    lineCount=lineCount+1
                                    info=[]
                                    info.append(level)
                                    info.append(block)
                                    info.append(lineCount)
                                    info.append(statement.cond)
                                    if element.name in label_map.keys():
                                        info_update=label_map[element.name]
                                        list=info_update[3]
                                        list.append(info)
                                elif type(element) is c_ast.If:
                                    block=block+1
                                    updateLabelTable_If(element,level,block,lineCount,label_map)
                                    block=block-1
                                else:
                                    if type(element) is c_ast.While:
                                        level=level+1
                                        updateLabelTable(element.stmt.block_items,level,block,lineCount,label_map)
                                        level=level-1
                                    else:
                                        lineCount=lineCount+1
                else:
                    if type(statement.iffalse) is c_ast.If:
                        updateLabelTable_If(statement.iffalse,level,block,lineCount,label_map)
					
					
#Check a label in a block of statement


def check_label_block(statements,label):
    status=False
    for statement in statements:
        if type(statement) is c_ast.If:
                        temp_status=check_label_block_If(statement,label)
                        if temp_status==True:
                                status=True 
        elif type(statement) is c_ast.Label:
                        if statement.name==label:
                                status = True
    return status
	



def check_label_block_sp(statements,label):
    status=False
    for statement in statements:
        if type(statement) is c_ast.Label:
                        if statement.name==label:
                                status = True
    return status

#Check a label in the blocks of statement of if loop
	
def check_label_block_If(statement,label):
    status=False
    if type(statement) is c_ast.If:
            if type(statement.iftrue) is c_ast.Label:
                if statement.iftrue.name==label:
                        status = True
            else:
	            		if type(statement.iftrue) is c_ast.Compound and statement.iftrue.block_items is not None:
	            			for element in statement.iftrue.block_items:
	            				if type(element) is c_ast.Label:
                                                        if element.name==label:
                                                                status = True
                                                                
            if type(statement.iffalse) is c_ast.Label:
                                if statement.iffalse.name==label:
                                        status = True
            else:
                if type(statement.iffalse) is c_ast.Compound and statement.iffalse.block_items is not None:
                            for element in statement.iffalse.block_items:
                                if type(element) is c_ast.Label:
                                    if element.name==label:
                                                                status = True
                else:
                    if type(statement.iffalse) is c_ast.If:
                        temp_status = check_label_block_If(statement.iffalse,label)
                        if temp_status==True:
                                                	status=True
    return status



#Check a label in statement


def check_label(statements,label):
    status=False
    for statement in statements:
        if type(statement) is c_ast.If:
                        temp_status=check_label_If(statement,label)
                        if temp_status==True:
                               status=True 
        elif type(statement) is c_ast.Label:
                        if statement.name==label:
                                status = True
        else:
	        	if type(statement) is c_ast.While:
	            		temp_status= check_label(statement.stmt.block_items,label)
	            		if temp_status==True:
                                        status=True
    return status



def check_label_sp(statements,label):
    status=False
    for statement in statements:
        if type(statement) is c_ast.If:
                        temp_status=check_label_If(statement,label)
                        if temp_status==True:
                               status=True 
        elif type(statement) is c_ast.Label:
                        if statement.name==label:
                                status = True
    return status



#Check a label in statement of if loop

def check_label_If(statement,label):
    status=False
    if type(statement) is c_ast.If:
            if type(statement.iftrue) is c_ast.Label:
                if statement.iftrue.name==label:
                                        status = True
            else:
                        if type(statement.iftrue) is c_ast.Compound and statement.iftrue.block_items is not None:
                            for element in statement.iftrue.block_items:
                                if type(element) is c_ast.Label:
                                                        if element.name==label:
                                                                status = True
                                elif type(element) is c_ast.If:
                                                        temp_status = check_label_If(element,label)
                                                        if temp_status==True:
                                                               status=True
                                else:
                                                if type(element) is c_ast.While:
                                                    temp_status = check_label(element.stmt.block_items,label)
                                                    if temp_status==True:
                                                                status=True
	
            if type(statement.iffalse) is c_ast.Label:
                                if statement.iffalse.name==label:
                                        status = True
            else:
                if type(statement.iffalse) is c_ast.Compound and statement.iffalse.block_items is not None:
                            for element in statement.iffalse.block_items:
                                if type(element) is c_ast.Label:
                                    if element.name==label:
                                        status = True
                                elif type(element) is c_ast.If:
                                    temp_status = check_label_If(element,label)
                                    if temp_status==True:
                                        status=True
                                else:
                                    if type(element) is c_ast.While:
                                        temp_status = check_label(element.stmt.block_items,label)
                                        if temp_status==True:
                                            status=True

                else:
                    temp_status = check_label_If(statement.iffalse,label)
                    if temp_status==True:
                        status=True
    return status





#Check a goto-label in a block of statement


def check_goto_block(statements,label):
    status=False
    for statement in statements:
        if type(statement) is c_ast.Goto:
            if statement.name==label:
                status = True
    return status


def check_goto_block_Sp(statements,label):
    status=False
    for statement in statements:
        if type(statement) is c_ast.Goto:
                if statement.name==label:
                    status = True
        elif type(statement) is c_ast.If:
                temp_status=check_goto_block_If(statement,label)
                if temp_status==True:
                    status=True
    return status
	
	

#Check a label in the blocks of statement of if loop
	
def check_goto_block_If(statement,label):
    status=False
    if type(statement) is c_ast.If:
            if type(statement.iftrue) is c_ast.Goto:
                if statement.iftrue.name==label:
                    status = True
            else:
                if type(statement.iftrue) is c_ast.Compound and statement.iftrue.block_items is not None:
                    for element in statement.iftrue.block_items:
                        if type(element) is c_ast.Goto:
                                if element.name==label:
                                    status = True
            if type(statement.iffalse) is c_ast.Label:
                                if statement.iffalse.name==label:
                                        status = True
            else:
                if type(statement.iffalse) is c_ast.Compound and statement.iffalse.block_items is not None:
                        for element in statement.iffalse.block_items:
                                if type(element) is c_ast.Goto:
                                    if element.name==label:
                                            status = True
                else:
                    if type(statement.iffalse) is c_ast.If:
                        temp_status = check_goto_block_If(statement.iffalse,label)
                        if temp_status==True:
                            status=True
    return status



#Check a label in statement


def check_goto(statements,label):
    status=False
    condition=None
    for statement in statements:
        if type(statement) is c_ast.If:
                        temp_status,temp_cond=check_goto_If(statement,label)
                        if temp_status==True:
                               status=True
                               condition=temp_cond
        elif type(statement) is c_ast.Goto:
                        if statement.name==label:
                                status = True
        else:
	        	if type(statement) is c_ast.While:
	            		temp_status,temp_cond= check_goto(statement.stmt.block_items,label)
	            		if temp_status==True:
                                        status=True
                                        condition=temp_cond
    return status,condition




#Check a label in statement of if loop

def check_goto_If(statement,label):
    status=False
    condition=None
    if type(statement) is c_ast.If:
            if type(statement.iftrue) is c_ast.Goto:
                if statement.iftrue.name==label:
                        status = True
                        condition=statement.cond
            else:
                        if type(statement.iftrue) is c_ast.Compound and statement.iftrue.block_items is not None:
                            for element in statement.iftrue.block_items:
                                if type(element) is c_ast.Goto:
                                    if element.name==label:
                                        status = True
                                        condition=statement.cond
                                elif type(element) is c_ast.If:
                                    temp_status,temp_cond = check_goto_If(element,label)
                                    if temp_status==True:
                                            status=True
                                            #condition=temp_cond
                                            condition=c_ast.BinaryOp(op='&&', left=temp_cond, right=statement.cond)
                                else:
                                    if type(element) is c_ast.While:
                                        temp_status,temp_cond = check_goto(element.stmt.block_items,label)
                                        if temp_status==True:
                                            status=True
                                            condition=temp_cond
	
            if type(statement.iffalse) is c_ast.Goto:
                                if statement.iffalse.name==label:
                                        status = True
                                        condition = c_ast.UnaryOp(op='!', expr=statement.cond)
            else:
                if type(statement.iffalse) is c_ast.Compound and statement.iffalse.block_items is not None:
                            for element in statement.iffalse.block_items:
                                if type(element) is c_ast.Goto:
                                    if element.name==label:
                                            status = True
                                            condition = c_ast.UnaryOp(op='!', expr=statement.cond)
                                elif type(element) is c_ast.If:
                                        temp_status,temp_cond = check_goto_If(element,label)
                                        if temp_status==True:
                                            status=True
                                            #condition=temp_cond
                                            condition=c_ast.BinaryOp(op='&&', left=temp_cond, right=c_ast.UnaryOp(op='!', expr=statement.cond))
                                else:
                                    if type(element) is c_ast.While:
                                        temp_status,temp_cond = check_goto(element.stmt.block_items,label)
                                        if temp_status==True:
                                                status=True
                                                condition=temp_cond

                else:
                    temp_status,temp_cond = check_goto_If(statement.iffalse,label)
                    if temp_status==True:
                                                status=True
                                                #condition=temp_cond
                                                condition=c_ast.BinaryOp(op='&&', left=temp_cond, right=c_ast.UnaryOp(op='!', expr=statement.cond))
    return status,condition






#Finding Goto in a Block to Call gotomovein
#Parameter pass block of statement 
#Label


def label_finder(statements,label):
	if statements is not None:
		flag_block1=check_label_block(statements,label)
		if flag_block1==True:
			return gotomoveout(statements,label)
		else:
			update_statements=[]
			if statements is not None:
				for statement in statements:
					if type(statement) is c_ast.If:
						update_statements.append(label_finder_if(statement,label))
					elif type(statement) is c_ast.While:
						update_statements.append(c_ast.While(cond=statement.cond, stmt=c_ast.Compound(block_items=label_finder(statement.stmt.block_items,label))))
					else:
						update_statements.append(statement)
				return update_statements
			return statements
	return statements
				




#Finding Goto in a Block to Call gotomovein
#Parameter pass block of statement 
#Label


def label_finder_inside(statements,label):
	if statements is not None:
		flag_block1=check_label_block(statements,label)
		flag_block2=check_label_block_sp(statements,label)
		flag_block3=check_goto_block_Sp(statements,label)
		#if flag_block1==False and flag_block2==False and flag_block3==False:
		if flag_block2==False and flag_block3==False:
			status,condition=check_goto(statements,label)
			if status==True:
				statements=gotomoveout_inside(statements,label)
				flag_block1=check_label_block(statements,label)
				flag_block2=check_label_block_sp(statements,label)
				flag_block3=check_goto_block_Sp(statements,label)
				#if flag_block1==False and flag_block2==False and flag_block3==True:
				if flag_block2==False and flag_block3==True:
					statements=gotomovein(statements,label)
	return statements







#Finding Goto in a If Block to Call gotomovein
#Parameter pass statement 
#Label

def label_finder_if(statement,label):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			if statement.iftrue.block_items is not None:
				new_iftrue=c_ast.Compound(block_items=label_finder(statement.iftrue.block_items,label))
			else:
				new_iftrue=statement.iftrue
		else:
			new_iftrue=statement.iftrue
		if type(statement.iffalse) is c_ast.Compound:
			if statement.iffalse.block_items is not None:
				new_iffalse=c_ast.Compound(block_items=label_finder(statement.iffalse.block_items,label))	
			else:
				new_iffalse=statement.iffalse
		elif type(statement.iffalse) is c_ast.If:
			new_iffalse=label_finder_if(statement.iffalse,label)
		else:
			new_iffalse=statement.iffalse
	return c_ast.If(cond=statement.cond,iftrue=new_iftrue,iffalse=new_iffalse)






#Method to Move Goto Outside
#Parameter pass statement 
#Label


def gotomoveout(statements,label):
    flag_block1=check_label_block(statements,label)
    update_statements=[]
    condition=None
    if flag_block1==True:
        for statement in statements:
            if type(statement) is c_ast.If:
                flag_block2,condition=check_goto_If(statement,label)
                flag_stmt2=check_goto_block_If(statement,label)
                if flag_block2==True and flag_stmt2==False:
                    statement=gotomoveoutrec_if(statement,label)
                    update_statements.append(statement)
                    update_statements.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
                elif flag_block2==True and flag_stmt2==True:
                    print('==============================5')
                    print(label)
                    print('==============================5')
                    statement=getRidOfGoto(statement,label)
                    if statement is not None:
                        update_statements.append(statement)
                        update_statements.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
                else:
                        update_statements.append(statement)
			
            elif type(statement) is c_ast.While:
                flag_block2,condition=check_goto(statement.stmt.block_items,label)
                flag_stmt2=check_goto_block(statement.stmt.block_items,label)
                if flag_block2==True and flag_stmt2==False:
                    stmts=gotomoveoutrec(statement.stmt.block_items,label)
                    stmts.append(c_ast.If(cond=condition, iftrue=c_ast.Break(), iffalse=None))
                    statement=c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=stmts))
                    update_statements.append(statement)
                    update_statements.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
                elif flag_block2==True and flag_stmt2==True:
                    update_statements.append(statement)
                else:
                    update_statements.append(statement)
			                       
            else:
                update_statements.append(statement)
                                
        return update_statements




#Method to Move Goto Outside
#Parameter pass statement 
#Label


def gotomoveout_inside(statements,label):
    update_statements=[]
    condition=None
    for statement in statements:
        if type(statement) is c_ast.If:
            flag_block2,condition=check_goto_If(statement,label)
            flag_stmt2=check_goto_block_If(statement,label)
            if flag_block2==True and flag_stmt2==False:
                statement=gotomoveoutrec_if(statement,label)
                update_statements.append(statement)
                update_statements.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
            elif flag_block2==True and flag_stmt2==True:
                print('==============================6')
                print(label)
                print('==============================6')
                statement=getRidOfGoto(statement,label)
                if statement is not None:
                        update_statements.append(statement)
                        update_statements.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
            else:
                update_statements.append(statement)
			
        elif type(statement) is c_ast.While:
            flag_block2,condition=check_goto(statement.stmt.block_items,label)
            flag_stmt2=check_goto_block(statement.stmt.block_items,label)
            if flag_block2==True and flag_stmt2==False:
                stmts=gotomoveoutrec(statement.stmt.block_items,label)
                stmts.append(c_ast.If(cond=condition, iftrue=c_ast.Break(), iffalse=None))
                statement=c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=stmts))
                update_statements.append(statement)
                update_statements.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
            elif flag_block2==True and flag_stmt2==True:
                update_statements.append(statement)
            else:
                update_statements.append(statement)
			                       
        else:
            update_statements.append(statement)
                                
    return update_statements












#Method to Move Goto Outside Recursive
#Parameter pass statement 
#Label

def gotomoveoutrec(statements,label):
    new_statements1=[]
    new_statements2=[]
    flag=False
    condition=None
    generator = c_generator.CGenerator()
    #print('#######@2start')
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print('#######@2start')
    #print('YYYYYYYYYYYYYYYYYYYYY')
    for statement in statements:
        if type(statement) is c_ast.If:
            flag_block2,condition_new=check_goto_If(statement,label)
            flag_stmt2=check_goto_block_If(statement,label)
            if condition_new is not None:
                condition=condition_new
            if flag_block2==True and flag_stmt2==False:
                statement=gotomoveoutrec_if(statement,label)
                new_statements1.append(statement)
                flag=True
            elif flag_block2==True and flag_stmt2==True:
                #print('==============================7')
                #print(label)
                #print('==============================7')
                #print('#######@2start')
                #print(generator.visit(c_ast.Compound(block_items=[statement])))
                #print('#######@2start')
                statement=getRidOfGoto(statement,label)
                #print('#######@2end')
                #print(generator.visit(c_ast.Compound(block_items=[statement])))
                #print('#######@2end')

                flag=True
                if statement is not None:
                    new_statements1.append(statement)
            else:
                if flag==True:
                    new_statements2.append(statement)
                else:
                    new_statements1.append(statement)

        elif type(statement) is c_ast.While:
            flag_block2,condition_new=check_goto(statement.stmt.block_items,label)
            flag_stmt2=check_goto_block(statement.stmt.block_items,label)
            if condition_new is not None:
                condition=condition_new
            if flag_block2==True and flag_stmt2==False:
                stmts=gotomoveoutrec(statement.stmt.block_items,label)
                stmts.append(c_ast.If(cond=condition, iftrue=c_ast.Break(), iffalse=None))
                statement=c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=stmts))
                new_statements1.append(statement)
            elif flag_block2==True and flag_stmt2==True:
                flag=True
                new_statements1.append(statement)
            else:
                if flag==True:
                    new_statements2.append(statement)
                else:
                    new_statements1.append(statement)
                       
        else:
            if flag==True:
                new_statements2.append(statement)
            else:
                new_statements1.append(statement)

    #print('#######@2mid1')
    #print(generator.visit(c_ast.Compound(block_items=new_statements1)))
    #print('#######@2mid1')

    #print('#######@2mid2')
    #print(generator.visit(c_ast.Compound(block_items=new_statements2)))
    #print('#######@2mid2')
    if condition is not None:
        if len(new_statements2)>0:
            new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2), iffalse=None))
        statements=new_statements1
    #print('#######@TTend')
    #print(generator.visit(c_ast.Compound(block_items=statements)))
    #print('#######@TTend')
    #print('XXXXXXXXXXXXXXXXXXXXXXXXXXXXX')
    return statements



#Finding Goto in a Block to Call gotomovein
#Parameter pass block of statement 
#Label
				
				
def gotomoveoutrec_if(statement,label):
	#print statement.show()
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Goto:
            if statement.iftrue.name==label:
                    status = True
        else:
                if type(statement.iftrue) is c_ast.Compound and statement.iftrue.block_items is not None:
                    flag_block2,condition=check_goto(statement.iftrue.block_items,label)
                    flag_stmt2=check_goto_block(statement.iftrue.block_items,label)
                if flag_block2==True and flag_stmt2==False:
                    statement.iftrue.block_items=gotomoveoutrec(statement.iftrue.block_items,label)
                    statement.iftrue=c_ast.Compound(block_items=statement.iftrue.block_items)
                elif flag_block2==True and flag_stmt2==True:
                    statement.iftrue=c_ast.Compound(block_items=statement.iftrue.block_items)
	                                                                
        if type(statement.iffalse) is c_ast.Label:
	        	if statement.iffalse.name==label:
	                	status = True
        else:
            if type(statement.iffalse) is c_ast.Compound and statement.iffalse.block_items is not None:
                flag_block2,condition=check_goto(statement.iffalse.block_items,label)
                flag_stmt2=check_goto_block(statement.iffalse.block_items,label)
            if flag_block2==True and flag_stmt2==False:
                statement.iffalse.block_items=gotomoveoutrec(statement.iffalse.block_items,label)
                statement.iffalse=c_ast.Compound(block_items=statement.iffalse.block_items)
            elif flag_block2==True and flag_stmt2==True:
                statement.iffalse=c_ast.Compound(block_items=statement.iffalse.block_items)
            else:
                if type(statement.iffalse) is c_ast.If: 
                    gotomoveoutrec_if(statement.iffalse,label)
	#print statement.show()
    return c_ast.If(cond=statement.cond, iftrue=statement.iftrue, iffalse=statement.iffalse)
				



#Updating Each If Else for Goto
#Parameter pass statement 
#Label
		
	
def getRidOfGoto(statement,label):
    generator = c_generator.CGenerator()

    #print('#######@1XXXXXXXX')
    #print(label)
    #print(generator.visit(c_ast.Compound(block_items=[statement])))
    #print('#######@1XXXXXXXX')

    new_iftrue=None
    new_iffalse=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Goto:
            if statement.iftrue.name==label:
                    new_iftrue=None
        else:
                if type(statement.iftrue) is c_ast.Compound:
                    new_block=[]
                    for stmt in statement.iftrue.block_items:
                        if type(stmt) is c_ast.Goto:
                            if stmt.name!=label:
                                new_block.append(stmt)
                        else:
                            if stmt is not None:
                                if type(stmt) is c_ast.Label and stmt.name!=label:
                                    new_block.append(stmt)
                                else:
                                    new_block.append(stmt)
                                    
                    #new_iffalse=c_ast.Compound(block_items=new_block)
                    new_iftrue=c_ast.Compound(block_items=new_block)
                                     
		
        if type(statement.iffalse) is c_ast.Label:
            if statement.iffalse.name==label:
                    new_iffalse=None
        else:
            if type(statement.iffalse) is c_ast.Compound:
                new_block=[]
                for stmt in statement.iffalse.block_items:
                    if type(stmt) is c_ast.Goto:
                        if stmt.name!=label:
                            new_block.append(stmt)
                    else:
                        new_block.append(stmt)
                new_iffalse=c_ast.Compound(block_items=new_block)
            else:
                if type(statement.iffalse) is c_ast.If:
                    new_iffalse=getRidOfGoto(statement.iffalse,label)
    if new_iftrue is not None:
        #print('#######@2XXXXXXXX')
        #print(generator.visit(c_ast.Compound(block_items=[c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)])))
        #print('#######@2XXXXXXXX')

        return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
    else:
        return None





#Finding Goto in a Block to Call gotomovein
#Parameter pass block of statement 
#Label


def goto_finder(statements,label):
	flag_block1=check_goto_block_Sp(statements,label)
	if flag_block1==True:
		flag_block1=check_label_block_sp(statements,label)
		if flag_block1==True:
			return statements
		else:
			return gotomovein(statements,label)
	else:
		update_statements=[]
		for statement in statements:
			if type(statement) is c_ast.If:
				update_statements.append(goto_finder_if(statement,label))
			elif type(statement) is c_ast.While:
				update_statements.append(c_ast.While(cond=statement.cond, stmt=c_ast.Compound(block_items=goto_finder(statement.stmt.block_items,label))))
			else:
				update_statements.append(statement)
		return update_statements


#Finding Goto in a If Block to Call gotomovein
#Parameter pass statement 
#Label

def goto_finder_if(statement,label):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement) is c_ast.If:
			if type(statement.iftrue) is c_ast.Compound:
				if statement.iftrue.block_items is not None:
					new_iftrue=c_ast.Compound(block_items=goto_finder(statement.iftrue.block_items,label))
				else:
					new_iftrue=statement.iftrue				
			else:
				new_iftrue=statement.iftrue
			if type(statement.iffalse) is c_ast.Compound:
				if statement.iffalse.block_items is not None:
					new_iffalse=c_ast.Compound(block_items=goto_finder(statement.iffalse.block_items,label))
				else:
					new_iffalse=statement.iffalse
			elif type(statement.iffalse) is c_ast.If:
				new_iffalse=goto_finder_if(statement.iffalse,label)
			else:
				new_iffalse=statement.iffalse
	return c_ast.If(cond=statement.cond,iftrue=new_iftrue,iffalse=new_iffalse)




#Method to Move Goto Inside
#Parameter pass statement 
#Label

def gotomovein(statements,label):
    flag_block1=check_goto_block_Sp(statements,label)
    new_statements1=[]
    new_statements2=[]
    flag=False
    if flag_block1==True:
        flag_block1,condition=check_goto(statements,label)
        for statement in statements:
            if type(statement) is c_ast.If:
                flag_stmt3=check_goto_block_If(statement,label)				
                flag_block2=check_label_If(statement,label)
                flag_stmt2=check_label_block_If(statement,label)
                if flag_stmt3==True:
                    if flag_block2==True and flag_stmt2==True:
                        new_statements1.append(statement)
                    else:
                        para_list=[]
                        para_list.append(condition)
                        newFun=c_ast.FuncCall(name=c_ast.ID(name='_Bool2Int'), args=c_ast.ExprList(exprs=para_list))
                        new_statement=c_ast.Assignment(op='=', lvalue=c_ast.ID(name='bool_go_'+label), rvalue=newFun)
                        new_variable['bool_go_'+label]='bool_go_'+label
                        condition=c_ast.BinaryOp(op='>', left=c_ast.ID(name='bool_go_'+label), right=c_ast.Constant(type='int', value='0'))
                        new_statements1.append(new_statement)
                        flag=True
                else:
                    if flag_block2==True and flag_stmt2==False:
                        flag=False
                        new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2), iffalse=None))
                        new_statements1.append(updateIfBlock(statement,label,condition))

                        new_statements2=[]
                    else:
                        if flag_block2==True and flag_stmt2==True:
                            flag=False
                            new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2), iffalse=None))
                            new_statements1.append(updateIfBlock(statement,label,condition))
                            new_statements2=[]
                        else:
                            if flag==False:
                                new_statements1.append(statement)
                            else:
                                new_statements2.append(statement)
            elif type(statement) is c_ast.While:
                flag_block2=check_label(statement.stmt.block_items,label)
                #flag_stmt2=check_label_block(statement.stmt.block_items,label)
                flag_stmt2=check_label_block_sp(statement.stmt.block_items,label)			
                if flag_block2==False and flag_stmt2==False:
                    statement=c_ast.While(cond=statement.cond, stmt=statement.stmt)
                elif flag_block2==True and flag_stmt2==True:
                    if len(new_statements2)>0:
                        new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2), iffalse=None))
                    new_cond=c_ast.BinaryOp(op='||', left=condition, right=statement.cond)
                    new_blocks=[]
                    new_blocks.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
                    for stmt in statement.stmt.block_items:
                        new_blocks.append(stmt)
                    new_blocks.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='bool_go_'+label) , rvalue= c_ast.Constant(type='int', value='0')))
                    statement=c_ast.While(cond=new_cond, stmt=c_ast.Compound(block_items=new_blocks))
                    flag=False
                    new_statements2=[]
                elif flag_block2==True and flag_stmt2==False:
                    if len(new_statements2)>0:
                        new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2), iffalse=None))
                    new_cond=c_ast.BinaryOp(op='||', left=condition, right=statement.cond)
                    new_blocks=[]
                    new_blocks.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
                    for stmt in statement.stmt.block_items:
                        new_blocks.append(stmt)
                    new_blocks.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='bool_go_'+label) , rvalue= c_ast.Constant(type='int', value='0')))
                    new_blocks=gotomoveinrec(new_blocks,label,condition)
                    statement=c_ast.While(cond=new_cond, stmt=c_ast.Compound(block_items=new_blocks))
                    flag=False
                    new_statements2=[]
                else:
                    statement=c_ast.While(cond=statement.cond, stmt=statement.stmt)
                if flag==False:
                    new_statements1.append(statement)
                else:
                    new_statements2.append(statement)
            else:
                if flag==False:
                    new_statements1.append(statement)
                else:
                    new_statements2.append(statement)

        return new_statements1
    else:
        return statements



#Method to Move Goto Inside Recursive 
#Parameter pass statement 
#Label


def gotomoveinrec(statements,label,condition):
	flag_block1,condition=check_goto(statements,label)
	new_statements1=[]
	new_statements2=[]
	flag=False
	if flag_block1==True:
		for statement in statements:
			if type(statement) is c_ast.If:
				flag_stmt3=check_goto_block_If(statement,label)				
				flag_block2=check_label_If(statement,label)
				flag_stmt2=check_label_block_If(statement,label)
				if flag_stmt3==True:
					if flag_block2==True and flag_stmt2==True:
						new_statements1.append(statement)
					else:
						flag=True
				else:
					if flag_block2==True and flag_stmt2==False:
						flag=False
						new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2), iffalse=None))
						new_statements1.append(updateIfBlock(statement,label,condition))

						new_statements2=[]
					else:
						if flag_block2==True and flag_stmt2==True:
							flag=False
							if len(new_statements2)>0:
								new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2), iffalse=None))
							new_statements1.append(updateIfBlock(statement,label,condition))
							new_statements2=[]
						else:
							if flag==False:
								new_statements1.append(statement)
							else:
								new_statements2.append(statement)
			elif type(statement) is c_ast.While:
				flag_block2=check_label(statement.stmt.block_items,label)
				#flag_stmt2=check_label_block(statement.stmt.block_items,label)
				flag_stmt2=check_label_block_sp(statement.stmt.block_items,label)
				if flag_block2==False and flag_stmt2==False:
					statement=c_ast.While(cond=statement.cond, stmt=statement.stmt)
				elif flag_block2==True and flag_stmt2==True:
					if len(new_statements2)>0:
						new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2), iffalse=None))
					new_cond=c_ast.BinaryOp(op='||', left=condition, right=statement.cond)
					new_blocks=[]
					new_blocks.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
					for stmt in statement.stmt.block_items:
						new_blocks.append(stmt)
					new_blocks.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='bool_go_'+label) , rvalue= c_ast.Constant(type='int', value='0')))
					statement=c_ast.While(cond=new_cond, stmt=c_ast.Compound(block_items=new_blocks))
					flag=False
					new_statements2=[]
				elif flag_block2==True and flag_stmt2==False:
					if len(new_statements2)>0:
						new_statements1.append(c_ast.If(cond=c_ast.UnaryOp(op='!', expr=condition), iftrue=c_ast.Compound(block_items=new_statements2), iffalse=None))
					new_cond=c_ast.BinaryOp(op='||', left=condition, right=statement.cond)
					new_blocks=[]
					new_blocks.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
					for stmt in statement.stmt.block_items:
						new_blocks.append(stmt)
					new_blocks.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='bool_go_'+label) , rvalue= c_ast.Constant(type='int', value='0')))
					new_blocks=gotomoveinrec(new_blocks,label,condition)
					statement=c_ast.While(cond=new_cond, stmt=c_ast.Compound(block_items=new_blocks))
					flag=False
					new_statements2=[]
				else:
					statement=c_ast.While(cond=statement.cond, stmt=statement.stmt)
				if flag==False:
					new_statements1.append(statement)
				else:
					new_statements2.append(statement)
			else:
				if flag==False:
					new_statements1.append(statement)
				else:
					new_statements2.append(statement)
		return new_statements1
	else:
		return statements




#Updating Each If Else for Goto
#Parameter pass statement 
#Label

def updateIfBlock(statement,label,condition):
    new_iftrue=None
    new_iffalse=None
    new_condtion=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Goto:
            if statement.iftrue.name==label:
                new_block=[]
                new_block.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
                new_block.append(statement.iftrue)
                new_iftrue=c_ast.Compound(block_items=new_block)
        else:
            if type(statement.iftrue) is c_ast.Compound:
                flag_stmt=check_label(statement.iftrue.block_items,label)
                flag_stmt_block=check_label_block_sp(statement.iftrue.block_items,label)
                if flag_stmt==True:
                        new_block=[]
                        new_block.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
                        for stmt in statement.iftrue.block_items:
                            new_block.append(stmt)
                        if flag_stmt_block==False:
                            new_block=gotomoveinrec(new_block,label,condition)
                        new_iftrue=c_ast.Compound(block_items=new_block)
                else:
                    new_condtion=c_ast.BinaryOp(op='&&', left=c_ast.UnaryOp(op='!', expr=condition), right=statement.cond)
                    new_iftrue=statement.iftrue
                         
			
        if type(statement.iffalse) is c_ast.Label:
            new_block=[]
            new_block.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
            new_block.append(statement.iffalse)
            new_iftrue=c_ast.Compound(block_items=new_block)
        else:
            if type(statement.iffalse) is c_ast.Compound:
                flag_stmt=check_label(statement.iffalse.block_items,label)
                flag_stmt_block=check_label_block_sp(statement.iffalse.block_items,label)
                if flag_stmt==True:
                        new_block=[]
                        new_block.append(c_ast.If(cond=condition, iftrue=c_ast.Goto(name=label), iffalse=None))
                        for stmt in statement.iffalse.block_items:
                            new_block.append(stmt)
                        if flag_stmt_block==False:
                            new_block=gotomoveinrec(new_block,label,condition)
                        new_iffalse=c_ast.Compound(block_items=new_block)
                else:
                    new_condtion=c_ast.BinaryOp(op='&&', left=c_ast.UnaryOp(op='!', expr=condition), right=statement.cond)
                    new_iffalse=statement.iffalse
            else:
                if type(statement.iffalse) is c_ast.If:
                    new_iffalse=updateIfBlock(statement.iffalse,label,condition)
    if new_condtion is not None:
        return c_ast.If(cond=new_condtion, iftrue=new_iftrue, iffalse=new_iffalse)
    else:
        return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
	
	
	

def reOrganizeBreaks(statements,new_break_map):
	update_statement=[]
	if statements is not None:
		for statement in statements:
			if type(statement) is c_ast.If:
				statement=reOrganizeBreaksIf(statement,new_break_map)
				update_statement.append(statement)
			elif type(statement) is c_ast.Break:
				update_statement.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='do_break'+str(len(new_break_map.keys())+1)), rvalue=c_ast.Constant(type='int', value='1')))
				new_break_map['do_break'+str(len(new_break_map.keys())+1)]='do_break'+str(len(new_break_map.keys())+1)
				update_statement.append(statement)
			else:
				update_statement.append(statement)
		return update_statement
	else:
		return None


def reOrganizeBreaksIf(statement,new_break_map):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Break:
			new_block=[]
			new_block.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='do_break'+str(len(new_break_map.keys())+1)), rvalue=c_ast.Constant(type='int', value='1')))
			new_break_map['do_break'+str(len(new_break_map.keys())+1)]='do_break'+str(len(new_break_map.keys())+1)
			new_block.append(statement.iftrue)
			new_iftrue=c_ast.Compound(block_items=new_block)
		else:
			if type(statement.iftrue) is c_ast.Compound:
				new_block=reOrganizeBreaks(statement.iftrue.block_items,new_break_map)
				new_iftrue=c_ast.Compound(block_items=new_block)
		
		if type(statement.iffalse) is c_ast.Break:
			new_block=[]
			new_block.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='do_break'+str(len(new_break_map.keys())+1)), rvalue=c_ast.Constant(type='int', value='1')))
			new_break_map['do_break'+str(len(new_break_map.keys())+1)]='do_break'+str(len(new_break_map.keys())+1)
			new_block.append(statement.iffalse)
			new_iffalse=c_ast.Compound(block_items=new_block)
		else:
			if type(statement.iffalse) is c_ast.Compound:
				new_block=reOrganizeBreaks(statement.iffalse.block_items,new_break_map)
				new_iffalse=c_ast.Compound(block_items=new_block)
			else:
				if type(statement.iffalse) is c_ast.If:
					new_iffalse=reOrganizeBreaksIf(statement.iffalse,new_break_map)
		return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
		
		
		
def addingBreakVariables(statements,new_break_map):
	for variable in new_break_map.keys():
		global new_variable
		new_variable[variable]=variable
		new_block=[]
		new_block.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=variable), rvalue=c_ast.Constant(type='int', value='0')))
		new_block.append(c_ast.Break())
		new_iftrue=c_ast.Compound(block_items=new_block)
		statements.append(c_ast.If(cond=c_ast.BinaryOp(op='==', left=c_ast.ID(name=variable), right=c_ast.Constant(type='int', value='1')), iftrue=new_iftrue, iffalse=None))
	return statements
	
	

def removeEmptyIfLoop(statements):
	update_statements=[]
	for statement in statements:
		if type(statement) is c_ast.If:
			statement=removeEmptyIfLoop_If(statement)
			if statement is not None:
				update_statements.append(statement)
		elif type(statement) is c_ast.While:
			new_block_items=removeEmptyIfLoop(statement.stmt.block_items)
			update_statements.append(c_ast.While(cond=statement.cond, stmt=c_ast.Compound(block_items=new_block_items)))
		else:
			if statement is not None:
				if type(statement) is not c_ast.EmptyStatement:
					update_statements.append(statement)
	return update_statements
			
			
			
def removeEmptyIfLoop_If(statement):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			if len(statement.iftrue.block_items)==0:
				new_iftrue=None
			else:
				new_block=removeEmptyIfLoop(statement.iftrue.block_items)
				if len(new_block)==0:
					new_iftrue=None
				else:
					new_iftrue=c_ast.Compound(block_items=new_block)
		else:
			if type(statement.iftrue) is c_ast.EmptyStatement:
				new_iftrue=None
			else:
				new_iftrue=statement.iftrue
				
		if type(statement.iffalse) is c_ast.Compound:
			if len(statement.iffalse.block_items)==0:
				new_iffalse=None
			else:
				new_block=removeEmptyIfLoop(statement.iffalse.block_items)
				if len(new_block)==0:
					new_iffalse=None 
				else:
					new_iffalse=c_ast.Compound(block_items=new_block) 
		elif type(statement.iffalse) is c_ast.If:
			result=removeEmptyIfLoop_If(statement.iffalse)
			if result is not None:
				new_iffalse=result
		else:
			if type(statement.iffalse) is c_ast.EmptyStatement:
				new_iftrue=None
			else:
				new_iffalse=statement.iffalse
	
	
	if new_iftrue is not None and new_iffalse is None:
		return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=None)
	elif new_iftrue is not None and new_iffalse is not None:
		return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
	elif new_iffalse is not None and type(new_iffalse) is c_ast.Compound:
		return c_ast.If(cond=c_ast.UnaryOp(op='!', expr=statement.cond), iftrue=new_iffalse, iffalse=None)
	elif new_iffalse is not None and type(new_iffalse) is c_ast.If:
		return new_iffalse
	else:
		return None

		
		
def returnReplacement(statements,end_label_map):
	update_statements=[]
	for statement in statements:
		if type(statement) is c_ast.If:
			statement=returnReplacementIf(statement,end_label_map)
			if statement is not None:
				update_statements.append(statement)
		elif type(statement) is c_ast.While:
			new_block_items=returnReplacement(statement.stmt.block_items,end_label_map)
			update_statements.append(c_ast.While(cond=statement.cond, stmt=c_ast.Compound(block_items=new_block_items)))
		elif type(statement) is c_ast.Return:
			if statement.expr is not None:
				label='Label'+str(len(end_label_map.keys())+1)
				update_statements.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='RET'), rvalue=statement.expr))
				update_statements.append(c_ast.Goto(name=label))
				end_label_map[label]=label
			else:
				label='Label'+str(len(end_label_map.keys())+1)
				update_statements.append(c_ast.Goto(name=label))
				end_label_map[label]=label
		elif type(statement) is c_ast.Label:
			update_statements.append(c_ast.Label(name=statement.name, stmt=None))
			if type(statement.stmt) is c_ast.Return:
				if statement.stmt.expr is not None:
					label='Label'+str(len(end_label_map.keys())+1)
					update_statements.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='RET'), rvalue=statement.stmt.expr))
					update_statements.append(c_ast.Goto(name=label))
					end_label_map[label]=label
				else:
					label='Label'+str(len(end_label_map.keys())+1)
					update_statements.append(c_ast.Goto(name=label))
					end_label_map[label]=label
			else:
				if statement.stmt is not None:
					update_statements.append(statement.stmt)
			
		else:
			update_statements.append(statement)
	return update_statements
	
	
	
	
	
	
def returnReplacementIf(statement,end_label_map):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Return:
			new_block=[]
			if statement.iftrue.expr is not None:
				label='Label'+str(len(end_label_map.keys())+1)
				new_block.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='RET'), rvalue=statement.iftrue.expr))
				new_block.append(c_ast.Goto(name=label))
				end_label_map[label]=label
			else:
				label='Label'+str(len(end_label_map.keys())+1)
				new_block.append(c_ast.Goto(name=label))
				end_label_map[label]=label
			new_iftrue=c_ast.Compound(block_items=new_block)
		else:
			if type(statement.iftrue) is c_ast.Compound:
				new_block=returnReplacement(statement.iftrue.block_items,end_label_map)
				new_iftrue=c_ast.Compound(block_items=new_block)
			else:
                                new_iftrue=statement.iftrue
			
		if type(statement.iffalse) is c_ast.Return:
			new_block=[]
			if statement.iffalse.expr is not None:
				label='Label'+str(len(end_label_map.keys())+1)
				new_block.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='RET'), rvalue=statement.iffalse.expr))
				new_block.append(c_ast.Goto(name=label))
				end_label_map[label]=label
			else:
				label='Label'+str(len(end_label_map.keys())+1)
				new_block.append(c_ast.Goto(name=label))
				end_label_map[label]=label
			new_iffalse=c_ast.Compound(block_items=new_block)
		else:
			if type(statement.iffalse) is c_ast.Compound:
				new_block=returnReplacement(statement.iffalse.block_items,end_label_map)
				new_iffalse=c_ast.Compound(block_items=new_block)
			else:
				if type(statement.iffalse) is c_ast.If:
					new_iffalse=returnReplacementIf(statement.iffalse,end_label_map)
				else:
                                        new_iffalse=statement.iffalse
	return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)









"""
 
Goto removal Modules End 

"""


break_count=0

continue_count=0	
	


def getBreakStmt(statements,break_map):
    update_statement1=[]
    update_statement2=[]
    flag=False
    global break_count
    global continue_count
    global new_variable
    for statement in statements:
        if type(statement) is c_ast.If:
            if flag==False:
                break_map_temp={}
                statement=getBreakStmtIf(statement,break_map_temp)
                for e_break in break_map_temp.keys():
                    break_map[e_break]=break_map_temp[e_break]
                update_statement1.append(statement)
                if len(break_map_temp.keys())>0:
                    flag=True
            else:
                update_statement2.append(statement)
        elif type(statement) is c_ast.While:
            break_map_temp={}
            new_block_items1=getBreakStmt(statement.stmt.block_items,break_map_temp)
            new_block_items2=[]
            new_condtion=statement.cond
            if len(break_map_temp.keys())>0:
                for var_name in break_map_temp.keys():
                        new_block_items2.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=var_name), rvalue=c_ast.Constant(type='int', value='0')))
                        if break_map_temp[var_name]=='Break':
                            temp_new_condition=c_ast.BinaryOp(op='&&', left=new_condtion, right=c_ast.BinaryOp(op='==', left=c_ast.ID(name=var_name), right=c_ast.Constant(type='int', value='0')))
                            new_condtion=temp_new_condition
			
            for item in new_block_items1:
                new_block_items2.append(item)
            if flag==False:
                update_statement1.append(c_ast.While(cond=new_condtion, stmt=c_ast.Compound(block_items=new_block_items2)))
            else:
                update_statement2.append(c_ast.While(cond=new_condtion, stmt=c_ast.Compound(block_items=new_block_items2)))
        elif type(statement) is c_ast.Break:
            break_count=break_count+1
            var_name='break_'+str(break_count)+'_flag'
            new_variable[var_name]=var_name
            update_statement1.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=var_name), rvalue=c_ast.Constant(type='int', value='1')))
            break_map[var_name]='Break'
        elif type(statement) is c_ast.Continue:
            continue_count=continue_count+1
            var_name='continue_'+str(continue_count)+'_flag'
            new_variable[var_name]=var_name
            update_statement1.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=var_name), rvalue=c_ast.Constant(type='int', value='1')))
            break_map[var_name]='Continue'
        else:
            if flag==False:
                update_statement1.append(statement)
            else:
                update_statement2.append(statement)
    if flag==True:
        update_condition=None
        for var_name in break_map.keys():
            if update_condition is None:
                update_condition=c_ast.BinaryOp(op='==', left=c_ast.ID(name=var_name), right=c_ast.Constant(type='int', value='0'))
            else:
                update_condition=c_ast.BinaryOp(op='&&', left=update_condition, right=c_ast.BinaryOp(op='==', left=c_ast.ID(name=var_name), right=c_ast.Constant(type='int', value='0')))
        if len(update_statement2)>0:
            update_statement1.append(c_ast.If(cond=update_condition, iftrue=c_ast.Compound(block_items=update_statement2), iffalse=None))
		
        return getBreakStmt(update_statement1,break_map)
    else:
        return update_statement1
			
		




def getBreakStmtIf(statement,break_map):
    new_iftrue=None
    new_iffalse=None
    global break_count
    global new_variable
    global continue_count
    if type(statement) is c_ast.If:
			
        if type(statement.iftrue) is c_ast.Break:
            new_block_items=[]
            break_count=break_count+1
            var_name='break_'+str(break_count)+'_flag'
            new_variable[var_name]=var_name
            new_block_items.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=var_name), rvalue=c_ast.Constant(type='int', value='1')))
            break_map[var_name]='Break'
            new_iftrue=c_ast.Compound(block_items=new_block_items)
        elif type(statement.iftrue) is c_ast.Continue:
            new_block_items=[]
            break_count=break_count+1
            var_name='continue_'+str(continue_count)+'_flag'
            new_variable[var_name]=var_name
            new_block_items.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=var_name), rvalue=c_ast.Constant(type='int', value='1')))
            break_map[var_name]='Continue'
            new_iftrue=c_ast.Compound(block_items=new_block_items)
        elif type(statement.iftrue) is c_ast.Compound:
            new_block_items=getBreakStmt(statement.iftrue.block_items,break_map)
            new_iftrue=c_ast.Compound(block_items=new_block_items)
        else:
            new_iftrue=statement.iftrue
			
        if type(statement.iffalse) is c_ast.Break:
            new_block_items=[]
            break_count=break_count+1
            var_name='break_'+str(break_count)+'_flag'
            new_variable[var_name]=var_name
            new_block_items.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=var_name), rvalue=c_ast.Constant(type='int', value='1')))
            break_map[var_name]='Break'
            new_iffalse=c_ast.Compound(block_items=new_block_items)
        elif type(statement.iffalse) is c_ast.Continue:
            new_block_items=[]
            continue_count=continue_count+1
            var_name='continue_'+str(continue_count)+'_flag'
            new_variable[var_name]=var_name
            new_block_items.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=var_name), rvalue=c_ast.Constant(type='int', value='1')))
            break_map[var_name]='Continue'
            new_iffalse=c_ast.Compound(block_items=new_block_items)	
        elif type(statement.iffalse) is c_ast.Compound:
            new_block_items=getBreakStmt(statement.iffalse.block_items,break_map)
            new_iffalse=c_ast.Compound(block_items=new_block_items)
        else:
            if type(statement.iffalse) is c_ast.If:
                new_iffalse=getBreakStmtIf(statement.iffalse,break_map)
            else:
                new_iffalse=statement.iffalse
    if new_iftrue is not None and new_iffalse is None:
        return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=None)
    elif new_iftrue is not None and new_iffalse is not None:
        return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
    elif new_iffalse is not None and type(new_iffalse) is c_ast.Compound:
        return c_ast.If(cond=c_ast.UnaryOp(op='!', expr=statement.cond), iftrue=new_iffalse, iffalse=None)
    elif new_iffalse is not None and type(new_iffalse) is c_ast.If:
        return new_iffalse
    else:
        return None
		
		


"""

#Program Class
#Plain Python object to store Information about Member Method of a Java Class 
"""
class programclass(object):
    def __init__(self, filename, functionMap , variableMap, axiomeMap, witnessXmlMap,dispalyMapInfo):
        self.filename = filename
        self.functionMap = functionMap
        self.variableMap = variableMap
        self.axiomeMap = axiomeMap
        self.witnessXmlMap = witnessXmlMap
        self.dispalyMapInfo = dispalyMapInfo
    def getFilename(self):
        return self.filename
    def getFunctionMap(self):
        return self.functionMap
    def getVariableMap(self):
        return self.variableMap
    def getAxiomeMap(self):
        return self.axiomeMap
    def getWitnessXmlMap(self):
        return self.witnessXmlMap
    def getDispalyMapInfo(self):
        return self.dispalyMapInfo
    def setFilename(self, filename):
        self.filename=filename
    def setFunctionMap(self, functionMap):
        self.functionMap=functionMap
    def setVariableMap(self, variableMap):
        self.variableMap=variableMap
    def setAxiomeMap(self, axiomeMap):
        self.axiomeMap=axiomeMap
    def setWitnessXmlMap(self, witnessXmlMap):
        self.witnessXmlMap=witnessXmlMap
    def setDispalyMapInfo(self, dispalyMapInfo):
        self.dispalyMapInfo=dispalyMapInfo




"""


#Function Substitution Modules


"""

counter_variableMap={}
counter_variableMap_Conf={}


def substituteFunBlock(statements,functionvarmap,functionname,externalvarmap):
    update_statements=[]
    global new_variable
    global counter_variableMap
    global counter_variableMap_Conf
    for statement in statements:
        if type(statement) is c_ast.FuncCall:
            membermethod=functionvarmap[statement.name.name]
            in_var_map=membermethod.getInputvar().keys()
            count=membermethod.getUsedCounter()
            count=count+1
            membermethod.setUsedCounter(count)
			
            if membermethod_cur is not None:
                in_var_map_cu=[]
                in_var_map_cu=membermethod_cur.getInputvar().keys()
                all_local_var=[]
                all_local_var_cu=[]
                if in_var_map is not None:
                    for x in in_var_map:
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                if membermethod.getLocalvar() is not None:
                    for x in membermethod.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                if in_var_map_cu is not None:
                    for x in in_var_map_cu:
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
                if membermethod_cur.getLocalvar() is not None:
                    for x in membermethod_cur.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
						
                if membermethod.getInputvar() is not None:
                    all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
			
		
													
                input_map={}
			
			

                for x in range(0, len(statement.args.exprs)):
                    arg=statement.args.exprs
                    #update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=c_ast.ID(name=arg[x].name)))
                    nput_map[in_var_map[x]]=arg[x]
				
                new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),membermethod.getInputvar(),membermethod.getSerialNo())
                            
                new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)

                for x in membermethod.getInputvar():
                    if x in all_var_int:
                        if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getInputvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=(membermethod.getInputvar()[x].getVariableType(),membermethod.getInputvar()[x].getDimensions())
                        else:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
                    else:
                        if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getInputvar()[x].getDimensions()>0:
                            new_variable[x]=(membermethod.getInputvar()[x].getVariableType(),membermethod.getInputvar()[x].getDimensions())
                        else:
                            new_variable[x]=membermethod.getInputvar()[x].getVariableType()
				
                for x in membermethod.getLocalvar():
                    if x in all_var_int:
                        if membermethod.getLocalvar()[x].getDimensions() is not None and membermethod.getLocalvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=(membermethod.getLocalvar()[x].getVariableType(),membermethod.getLocalvar()[x].getDimensions())
                        else:
                                			new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
                    else:
                        if membermethod.getLocalvar()[x].getDimensions() is not None and membermethod.getLocalvar()[x].getDimensions()>0:
                            new_variable[x]=(membermethod.getLocalvar()[x].getVariableType(),membermethod.getLocalvar()[x].getDimensions())
                        else:
                            new_variable[x]=membermethod.getLocalvar()[x].getVariableType()
			
            for stmt in new_blocks:
                update_statements.append(stmt)
        elif type(statement) is c_ast.Assignment:
            new_statement,new_block=substituteFun(statement.rvalue,functionvarmap,functionname,externalvarmap)
            if new_block is not None and len(new_block)>0:
                for stmt in new_block:
                    update_statements.append(stmt)
            if type(statement.lvalue) is c_ast.ID:
                if 'DUMMY' not in statement.lvalue.name:
                    update_statements.append(c_ast.Assignment(op='=',lvalue=statement.lvalue,rvalue=new_statement))
                else:
                    if new_block is None:
                        update_statements.append(c_ast.Assignment(op='=',lvalue=statement.lvalue,rvalue=statement.rvalue))
            else:
                update_statements.append(c_ast.Assignment(op='=',lvalue=statement.lvalue,rvalue=new_statement))
        elif type(statement) is c_ast.While:
                    
            counter_variableMap_Conf={}
            counter_variableMap={}
            local_counter_varMap=getCounterVariables(statement.cond,counter_variableMap)
            getConfirmationVariables(statement.stmt.block_items,counter_variableMap,counter_variableMap_Conf)                        
            statement.cond,new_block=substituteFun(statement.cond,functionvarmap,functionname,externalvarmap)
            if new_block is not None and len(new_block)>0:
                for stmt in new_block:
                    update_statements.append(stmt)
            temp_new_block=substituteFunBlock(statement.stmt.block_items,functionvarmap,functionname,externalvarmap)
            if new_block is not None:
                for stmt in new_block:
                    temp_new_block.append(stmt)
            update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=temp_new_block)))	
        elif type(statement) is c_ast.If:
            statement,new_block=substituteFunBlockIf(statement,functionvarmap,functionname,externalvarmap)
            if new_block is not None and len(new_block)>0:
                for stmt in new_block:
                    update_statements.append(stmt)
            update_statements.append(statement)
        else:
            update_statements.append(statement)
    return update_statements





def substituteFunBlockIf(statement,functionvarmap,functionname,externalvarmap):
	new_iftrue=None
	new_iffalse=None
	update_statements=None
	if type(statement) is c_ast.If:
		statement.cond,new_block=substituteFun(statement.cond,functionvarmap,functionname,externalvarmap)
		if new_block is not None and len(new_block)>0:
			update_statements=[]
			for stmt in new_block:
				update_statements.append(stmt)
		if type(statement.iftrue) is c_ast.Compound:
			new_iftrue=c_ast.Compound(block_items=substituteFunBlock(statement.iftrue.block_items,functionvarmap,functionname,externalvarmap))
		else:
			new_iftrue=statement.iftrue
		if type(statement.iffalse) is c_ast.Compound:
			new_iffalse=c_ast.Compound(block_items=substituteFunBlock(statement.iffalse.block_items,functionvarmap,functionname,externalvarmap))
		else:
			if type(statement.iffalse) is c_ast.If:
				statement.iffalse,new_block =substituteFunBlockIf(statement.iffalse,functionvarmap,functionname,externalvarmap)
				if new_block is not None and len(new_block)>0:
					if update_statements is None:
						update_statements=[]
					for stmt in new_block:
						update_statements.append(stmt)
				new_iffalse=statement.iffalse
	return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse),update_statements



def substituteFun(statement,functionvarmap,functionname,externalvarmap):
    new_block=None
    global new_variable
    if type(statement) is c_ast.ID:
        return statement,new_block
    elif type(statement) is c_ast.Constant:
        return statement,new_block
    if type(statement) is c_ast.ArrayRef:
        return statement,new_block
    elif type(statement) is c_ast.UnaryOp:
        stmt,new_block_t=substituteFun(statement.expr,functionvarmap,functionname,externalvarmap)
        return c_ast.UnaryOp(op=statement.op, expr=stmt),new_block_t
    elif type(statement) is c_ast.FuncCall:
        update_statements=[]
        if statement.name.name not in functionvarmap.keys():
            return statement,new_block
        membermethod=functionvarmap[statement.name.name]
        in_var_map=membermethod.getInputvar().keys()
        count=membermethod.getUsedCounter()
        count=count+1
        membermethod.setUsedCounter(count)
		
        membermethod_cur=functionvarmap[functionname]
                
        if membermethod_cur is not None:
            in_var_map_cu=[]
            in_var_map_cu=membermethod_cur.getInputvar().keys()
            all_local_var=[]
            all_local_var_cu=[]
            if in_var_map is not None:
                for x in in_var_map:
                    if externalvarmap is not None:
                        if x not in externalvarmap.keys():
                            all_local_var.append(x)
            if membermethod.getLocalvar() is not None:
                for x in membermethod.getLocalvar().keys():
                    if externalvarmap is not None:
                        if x not in externalvarmap.keys():
                            all_local_var.append(x)
            if in_var_map_cu is not None:
                for x in in_var_map_cu:
                    if externalvarmap is not None:
                        if x not in externalvarmap.keys():
                            all_local_var_cu.append(x)
            if membermethod_cur.getLocalvar() is not None:
                for x in membermethod_cur.getLocalvar().keys():
                    if externalvarmap is not None:
                        if x not in externalvarmap.keys():
                            all_local_var_cu.append(x)
						
            if membermethod.getInputvar() is not None:
                all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
			
	
								
            input_map={}
		
		
            if '__VERIFIER_nondet' not in statement.name.name:
                if statement.args is not None:
                    for x in range(0, len(statement.args.exprs)):
                        arg=statement.args.exprs
                        #update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=arg[x]))
                        input_map[in_var_map[x]]=arg[x]

				
				
                new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
                                
                                
                                
                new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
                                
                                
                for x in membermethod.getInputvar().keys():
                    if x in all_var_int:
                        if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getInputvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=(membermethod.getInputvar()[x].getVariableType(),membermethod.getInputvar()[x].getDimensions())
                        else:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
                    else:
                        if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getInputvar()[x].getDimensions()>0:
                            new_variable[x]=(membermethod.getInputvar()[x].getVariableType(),membermethod.getInputvar()[x].getDimensions())
                        else:
                            new_variable[x]=membermethod.getInputvar()[x].getVariableType()
				
                for x in membermethod.getLocalvar():
                    if x in all_var_int:
                        if membermethod.getLocalvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=(membermethod.getLocalvar()[x].getVariableType(),membermethod.getLocalvar()[x].getDimensions())
                        else:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
                    else:
                        if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getLocalvar()[x].getDimensions()>0:
                            new_variable[x]=(membermethod.getLocalvar()[x].getVariableType(),membermethod.getLocalvar()[x].getDimensions())
                        else:
                            new_variable[x]=membermethod.getLocalvar()[x].getVariableType()
		
		
                for stmt in new_blocks:
                    update_statements.append(stmt)
 		
                return c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+'RET'),update_statements	
            else:
                return statement,new_block
        else:
            return statement,new_block
    elif type(statement) is c_ast.BinaryOp:
        if type(statement.left) is c_ast.ID and type(statement.right) is c_ast.ID:
 			
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block
        if type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.ArrayRef:
 			
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block	
        elif type(statement.left) is c_ast.ID and type(statement.right) is c_ast.BinaryOp:
                                               
            stmt_right,new_block=substituteFun(statement.right,functionvarmap,functionname,externalvarmap)

            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=stmt_right),new_block
 			
        elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.ID:
 			
            stmt_left,new_block=substituteFun(statement.left,functionvarmap,functionname,externalvarmap)
                        
            return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=statement.right),new_block
 			
        elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.Constant:
 		
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block
 			
        elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.ID:

            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block
 			
        elif type(statement.left) is c_ast.ID and type(statement.right) is c_ast.Constant:
 		
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block
        elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.Constant:
		 		
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block
        elif type(statement.left) is c_ast.ID and type(statement.right) is c_ast.ArrayRef:
		 		
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block
        elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.ArrayRef:
				 		
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block
        elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.ID:
				 		
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block 		
 		
        elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.BinaryOp:
		
            stmt_right,new_block=substituteFun(statement.right,functionvarmap,functionname,externalvarmap)
		                        
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=stmt_right),new_block
        elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.BinaryOp:

            stmt_right,new_block=substituteFun(statement.right,functionvarmap,functionname,externalvarmap)
                        
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=stmt_right),new_block
 			
        elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.Constant:

            stmt_left,new_block=substituteFun(statement.left,functionvarmap,functionname,externalvarmap)
 		
            return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=statement.right),new_block
 			
        elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.ArrayRef:
		
            stmt_left,new_block=substituteFun(statement.left,functionvarmap,functionname,externalvarmap)
		 		
            return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=statement.right),new_block
        elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.BinaryOp:
		
            stmt_right,new_block=substituteFun(statement.right,functionvarmap,functionname,externalvarmap)
		                        
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=stmt_right),new_block
		 			
        elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.ArrayRef:
		
            stmt_left,new_block=substituteFun(statement.left,functionvarmap,functionname,externalvarmap)
		 		
            return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=statement.right),new_block
        elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.BinaryOp:

            stmt_left,new_block1=substituteFun(statement.left,functionvarmap,functionname,externalvarmap)

            stmt_right,new_block2=substituteFun(statement.right,functionvarmap,functionname,externalvarmap)

            if new_block1 is not None and new_block2 is None:
 		
                return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=stmt_right),new_block1

            elif new_block1 is None and new_block2 is not None:
                return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=stmt_right),new_block2
            else:
                                new_block=[]
                                if new_block1 is not None:
                                	for stmt in new_block1:
                                        	new_block.append(stmt)
                                if new_block2 is not None:
                                	for stmt in new_block2:
                                        	new_block.append(stmt)
                                return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=stmt_right),new_block
 		
        elif type(statement.left) is c_ast.FuncCall and type(statement.right) is c_ast.BinaryOp:
            update_statements=[]
		 	
            if statement.left.name.name not in functionvarmap.keys():
                return statement,new_block
		 	
            membermethod=functionvarmap[statement.left.name.name]
		 	
            if membermethod.getBody() is None:
                return statement,new_block
		 	
            in_var_map=membermethod.getInputvar().keys()
            count=membermethod.getUsedCounter()
            count=count+1
            membermethod.setUsedCounter(count)
			
			
            membermethod_cur=functionvarmap[functionname]
            if membermethod_cur is not None:
                in_var_map_cu=[]
                in_var_map_cu=membermethod_cur.getInputvar().keys()
                all_local_var=[]
                all_local_var_cu=[]
                if in_var_map is not None:
                    for x in in_var_map:
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                if membermethod.getLocalvar() is not None:
                    for x in membermethod.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                if in_var_map_cu is not None:
                    for x in in_var_map_cu:
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
                if membermethod_cur.getLocalvar() is not None:
                    for x in membermethod_cur.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
						
                if membermethod.getInputvar() is not None:
                    all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
			
	
								
                input_map={}
			
			
			
                if statement.left.args is not None:
                    for x in range(0, len(statement.left.args.exprs)):
                        arg=statement.left.args.exprs
						#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
						#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=c_ast.ID(name=arg[x].name)))
                        input_map[in_var_map[x]]=arg[x]
			
                new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),membermethod.getInputvar(),membermethod.getSerialNo())
			
			
                new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
			
			
                for stmt in new_blocks:
                    update_statements.append(stmt)
				
				
				
                for x in membermethod.getInputvar():
                    if x in all_var_int:
                        if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getInputvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                        else:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
				
                for x in membermethod.getLocalvar():
                    if x in all_var_int:
                        if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getLocalvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                        else:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()

			
            stmt_right,new_block1=substituteFun(statement.right,functionvarmap,functionname,externalvarmap)
            if new_block1 is not None:
                for stmt in new_block1:
                    update_statements.append(stmt)
				
            return c_ast.BinaryOp(op=statement.op,left=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_RET'), right=stmt_right),update_statements			
 		
 		
        elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.FuncCall:
            update_statements=[]
            stmt_left,new_block1=substituteFun(statement.left,functionvarmap,functionname,externalvarmap)
            if new_block1 is not None:
                for stmt in new_block1:
                    update_statements.append(stmt)
		 	
            if statement.right.name.name not in functionvarmap.keys():
                return statement,new_block
		 	
            membermethod=functionvarmap[statement.right.name.name]
		 	
            if membermethod.getBody() is None:
                return statement,new_block
		 	
            in_var_map=membermethod.getInputvar().keys()
            count=membermethod.getUsedCounter()
            count=count+1
            membermethod.setUsedCounter(count)
			
			
            membermethod_cur=functionvarmap[functionname]
            if membermethod_cur is not None:
                in_var_map_cu=[]
                in_var_map_cu=membermethod_cur.getInputvar().keys()
                all_local_var=[]
                all_local_var_cu=[]
                if in_var_map is not None:
                    for x in in_var_map:
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                if membermethod.getLocalvar() is not None:
                    for x in membermethod.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                if in_var_map_cu is not None:
                    for x in in_var_map_cu:
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
                if membermethod_cur.getLocalvar() is not None:
                    for x in membermethod_cur.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
						
                if membermethod.getInputvar() is not None:
                    all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
			
		
					
                input_map={}
			
			
			
			
			
                if statement.right.args is not None:
                    for x in range(0, len(statement.right.args.exprs)):
                        arg=statement.right.args.exprs
                        #update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
                        #update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=arg[x]))
                        input_map[in_var_map[x]]=arg[x]
			
                new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
			
                new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
			
                for x in membermethod.getInputvar():
                    if x in all_var_int:
                        if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getInputvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                        else:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
				
                for x in membermethod.getLocalvar():
                    if x in all_var_int:
                        if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getLocalvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                        else:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
					
			
                for stmt in new_blocks:
                    update_statements.append(stmt)
            return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_RET')),update_statements	
 			
        elif type(statement.left) is c_ast.ID and type(statement.right) is c_ast.FuncCall:
            update_statements=[]
 			
            if statement.right.name.name not in functionvarmap.keys():
                return statement,new_block
 			
            membermethod=functionvarmap[statement.right.name.name]
 			
 			
            if membermethod.getBody() is None:
                return statement,new_block
 			
 			
            in_var_map=membermethod.getInputvar().keys()
            count=membermethod.getUsedCounter()
            count=count+1
            membermethod.setUsedCounter(count)
			
			
            membermethod_cur=functionvarmap[functionname]
			

			
			
            if membermethod_cur is not None:
                in_var_map_cu=[]
                in_var_map_cu=membermethod_cur.getInputvar().keys()
                all_local_var=[]
                all_local_var_cu=[]
                if in_var_map is not None:
                    for x in in_var_map:
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                if membermethod.getLocalvar() is not None:
                    for x in membermethod.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                if in_var_map_cu is not None:
                    for x in in_var_map_cu:
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
                if membermethod_cur.getLocalvar() is not None:
                    for x in membermethod_cur.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
						
                if membermethod.getInputvar() is not None:
                    all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
			
		
                input_map={}
						
                if statement.right.args is not None:
                    for x in range(0, len(statement.right.args.exprs)):
                        arg=statement.right.args.exprs
                        input_map[in_var_map[x]]=arg[x]
					#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
				#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=arg[x]))
					
                new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
						
                new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
				

				
                for x in membermethod.getInputvar():
                    if x in all_var_int:
                        if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getInputvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                        else:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
				
                for x in membermethod.getLocalvar():
                    if x in all_var_int:
                        if membermethod.getLocalvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                        else:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
                for stmt in new_blocks:
                    update_statements.append(stmt)
 		
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_RET')),update_statements	
 		
        elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.FuncCall:
            update_statements=[]
  			
            if statement.right.name.name not in functionvarmap.keys():
                return statement,new_block
  			
            membermethod=functionvarmap[statement.right.name.name]
  			
            if membermethod.getBody() is None:
                return statement,new_block
  			
  			
            in_var_map=membermethod.getInputvar().keys()
            count=membermethod.getUsedCounter()
            count=count+1
            membermethod.setUsedCounter(count)
 			
 			
            membermethod_cur=functionvarmap[functionname]
            if membermethod_cur is not None:
                in_var_map_cu=[]
                in_var_map_cu=membermethod_cur.getInputvar().keys()
                all_local_var=[]
                all_local_var_cu=[]
                if in_var_map is not None:
                    for x in in_var_map:
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                if membermethod.getLocalvar() is not None:
                    for x in membermethod.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                if in_var_map_cu is not None:
                    for x in in_var_map_cu:
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
                if membermethod_cur.getLocalvar() is not None:
                    for x in membermethod_cur.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
 						
                if membermethod.getInputvar() is not None:
                    all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
 			
 		
                input_map={}
 						
                if statement.right.args is not None:
                    for x in range(0, len(statement.right.args.exprs)):
                        arg=statement.right.args.exprs
                        input_map[in_var_map[x]]=arg[x]
 					#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
 				#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=arg[x]))
 					
                new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
 						
                new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
 				
 
 				
                for x in membermethod.getInputvar():
                    if x in all_var_int:
                        if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getInputvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                        else:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
 				
                for x in membermethod.getLocalvar():
                    if x in all_var_int:
                        if membermethod.getLocalvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                        else:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
                for stmt in new_blocks:
                    update_statements.append(stmt)
  		
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_RET')),update_statements	
 		
        elif type(statement.left) is c_ast.FuncCall and type(statement.right) is c_ast.ID :
            update_statements=[]
			
            if statement.left.name.name not in functionvarmap.keys():
                return statement,new_block
			
            membermethod=functionvarmap[statement.left.name.name]
		 	
		 	
            if membermethod.getBody() is None:
                return statement,new_block
		 	
            in_var_map=membermethod.getInputvar().keys()
            count=membermethod.getUsedCounter()
            count=count+1
            membermethod.setUsedCounter(count)
			
			
			
            membermethod_cur=functionvarmap[functionname]
            if membermethod_cur is not None:
                in_var_map_cu=[]
                in_var_map_cu=membermethod_cur.getInputvar().keys()
                all_local_var=[]
                all_local_var_cu=[]
                if in_var_map is not None:
                    for x in in_var_map:
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                if membermethod.getLocalvar() is not None:
                    for x in membermethod.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                if in_var_map_cu is not None:
                    for x in in_var_map_cu:
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
                if membermethod_cur.getLocalvar() is not None:
                    for x in membermethod_cur.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
						
                if membermethod.getInputvar() is not None:
                    all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
								
                input_map={}
			
			
                if statement.left.args is not None:
                    for x in range(0, len(statement.left.args.exprs)):
                        arg=statement.left.args.exprs
                        input_map[in_var_map[x]]=arg[x]
					#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
						#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=c_ast.ID(name=arg[x].name)))
			
			
            new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
			
            new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
			
			
            for x in membermethod.getInputvar():
                if x in all_var_int:
                    if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getInputvar()[x].getDimensions()>0:
                        new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                    else:
                        new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
				
            for x in membermethod.getLocalvar():
                if x in all_var_int:
                    if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getLocalvar()[x].getDimensions()>0:
                        new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                    else:
                        new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
					
			
            for stmt in new_blocks:
                update_statements.append(stmt)
		 		
            return c_ast.BinaryOp(op=statement.op,left=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_RET'), right=statement.right),update_statements	

        elif type(statement.left) is c_ast.FuncCall and type(statement.right) is c_ast.ArrayRef :
            update_statements=[]
			
            if statement.left.name.name not in functionvarmap.keys():
                return statement,new_block
			
			
            membermethod=functionvarmap[statement.left.name.name]
		 	
		 	
            if membermethod.getBody() is None:
                return statement,new_block
		 	
		 	
            in_var_map=membermethod.getInputvar().keys()
            count=membermethod.getUsedCounter()
            count=count+1
            membermethod.setUsedCounter(count)
			
			
			
            membermethod_cur=functionvarmap[functionname]
            if membermethod_cur is not None:
                in_var_map_cu=[]
                in_var_map_cu=membermethod_cur.getInputvar().keys()
                all_local_var=[]
                all_local_var_cu=[]
                if in_var_map is not None:
                    for x in in_var_map:
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                if membermethod.getLocalvar() is not None:
                    for x in membermethod.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                if in_var_map_cu is not None:
                    for x in in_var_map_cu:
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
                if membermethod_cur.getLocalvar() is not None:
                    for x in membermethod_cur.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
						
                if membermethod.getInputvar() is not None:
                    all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
								
                input_map={}
			
			
                if statement.left.args is not None:
                    for x in range(0, len(statement.left.args.exprs)):
                        arg=statement.left.args.exprs
                        input_map[in_var_map[x]]=arg[x]
					#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
						#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=c_ast.ID(name=arg[x].name)))
			
			
            new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
			
            new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
			
			
            for x in membermethod.getInputvar():
                if x in all_var_int:
                    if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getInputvar()[x].getDimensions()>0:
                        new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                    else:
                        new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
				
            for x in membermethod.getLocalvar():
                if x in all_var_int:
                    if membermethod.getLocalvar()[x].getDimensions()>0:
                        new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                    else:
                        new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
					
			
            for stmt in new_blocks:
                update_statements.append(stmt)
		 		
            return c_ast.BinaryOp(op=statement.op,left=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_RET'), right=statement.right),update_statements	
 		
 		
 		
 		
        elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.FuncCall:
            update_statements=[]
		 	
            if statement.right.name.name not in functionvarmap.keys():
                return statement,new_block
		 	
            membermethod=functionvarmap[statement.right.name.name]
		 	
            if membermethod.getBody() is None:
                return statement,new_block
		 	
            in_var_map=membermethod.getInputvar().keys()
            count=membermethod.getUsedCounter()
            count=count+1
            membermethod.setUsedCounter(count)
			
					
						
            membermethod_cur=functionvarmap[functionname]
            if membermethod_cur is not None:
                in_var_map_cu=[]
                in_var_map_cu=membermethod_cur.getInputvar().keys()
                all_local_var=[]
                all_local_var_cu=[]
                if in_var_map is not None:
                    for x in in_var_map:
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                if membermethod.getLocalvar() is not None:
                    for x in membermethod.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                if in_var_map_cu is not None:
                    for x in in_var_map_cu:
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
                if membermethod_cur.getLocalvar() is not None:
                    for x in membermethod_cur.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
									
                if membermethod.getInputvar() is not None:
                    all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
											
                input_map={}
			
			
                for x in range(0, len(statement.right.args.exprs)):
                    arg=statement.right.args.exprs
                    input_map[in_var_map[x]]=arg[x]
				#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
				#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=c_ast.ID(name=arg[x].name)))
			
                new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
			
                new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
			
			
                for x in membermethod.getInputvar():
                    if x in all_var_int:
                        if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getInputvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                        else:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
				
                for x in membermethod.getLocalvar():
                    if x in all_var_int:
                        if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getLocalvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                        else:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
					
			
                for stmt in new_blocks:
                    update_statements.append(stmt)
		 		
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_RET')),update_statements	
		 		
        elif type(statement.left) is c_ast.FuncCall and type(statement.right) is c_ast.Constant :
            update_statements=[]
			
            if statement.left.name.name not in functionvarmap.keys():
                return statement,new_block
			
            membermethod=functionvarmap[statement.left.name.name]
			
            if membermethod.getBody() is None:
                return statement,new_block
			
			
            in_var_map=membermethod.getInputvar().keys()
            count=membermethod.getUsedCounter()
            count=count+1
            membermethod.setUsedCounter(count)
						
            membermethod_cur=functionvarmap[functionname]
			
			
            if membermethod_cur is not None:
                in_var_map_cu=[]
                in_var_map_cu=membermethod_cur.getInputvar().keys()
                all_local_var=[]
                all_local_var_cu=[]
                for x in in_var_map:
                    if externalvarmap is not None:
                        if x not in externalvarmap.keys():
                            all_local_var.append(x)
                if membermethod.getLocalvar() is not None:
                    for x in membermethod.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                for x in in_var_map_cu:
                    if externalvarmap is not None:
                        if x not in externalvarmap.keys():
                            all_local_var_cu.append(x)
                if membermethod_cur.getLocalvar() is not None:
                    for x in membermethod_cur.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
									
                if membermethod.getInputvar() is not None:
                    all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
											
                input_map={}
						
			
                if statement.left.args is not None:
                    for x in range(0, len(statement.left.args.exprs)):
                        arg=statement.left.args.exprs
                        input_map[in_var_map[x]]=arg[x]
				#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
				#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=c_ast.ID(name=arg[x].name)))
				
				
                new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
			
                new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
			
                for x in membermethod.getInputvar():
                    if x in all_var_int:
                        if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getInputvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                        else:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
				
                for x in membermethod.getLocalvar():
                    if x in all_var_int:
                        if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getLocalvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                        else:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
					
			
                for stmt in new_blocks:
                    update_statements.append(stmt)
		
				 		
            return c_ast.BinaryOp(op=statement.op,left=c_ast.ID(name='t_'+str(count)+'_RET'), right=statement.right),update_statements	
 		
        elif type(statement.left) is c_ast.FuncCall and type(statement.right) is c_ast.FuncCall:
            update_statements=[]
		 	
            if statement.left.name.name not in functionvarmap.keys():
                return statement,new_block
		 	
            membermethod=functionvarmap[statement.left.name.name]
		 	
		 	
            if membermethod.getBody() is None:
                return statement,new_block
		 		
		 	
            in_var_map=membermethod.getInputvar().keys()
            count=membermethod.getUsedCounter()
            count=count+1
            membermethod.setUsedCounter(count)
			
            membermethod_cur=functionvarmap[functionname]
			
            if membermethod_cur is not None:
                in_var_map_cu=[]
                if membermethod_cur.getInputvar() is not None:
                    in_var_map_cu=membermethod_cur.getInputvar().keys()
                all_local_var=[]
                all_local_var_cu=[]
                if in_var_map is not None:
                    for x in in_var_map:
                        if x not in externalvarmap.keys():
                            all_local_var.append(x)
                if membermethod.getLocalvar() is not None:
                    for x in membermethod.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                if in_var_map_cu is not None:
                    for x in in_var_map_cu:
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
                if membermethod_cur.getLocalvar() is not None:
                    for x in membermethod_cur.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
									
                if membermethod.getInputvar() is not None:
                    all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
											
                input_map={}
						
                if statement.left.args is not None:
                    for x in range(0, len(statement.left.args.exprs)):
                        arg=statement.left.args.exprs
                        input_map[in_var_map[x]]=arg[x]
					#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
					#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=c_ast.ID(name=arg[x].name)))
			
			
                new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
			
                new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
			
			
			
                for x in membermethod.getInputvar():
                    if x in all_var_int:
                        if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getInputvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                        else:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
				
                for x in membermethod.getLocalvar():
                    if x in all_var_int:
                        if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getLocalvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                        else:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
					
			
                for stmt in new_blocks:
                    update_statements.append(stmt)
		 	
                stmt_left=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_RET')
            else:
                stmt_left=statement.left
		 	
		 	
            if statement.right.name.name not in functionvarmap.keys():
                return statement,new_block
		 		
            membermethod=functionvarmap[statement.right.name.name]
		 	
            if membermethod.getBody() is None:
                return statement,new_block
		 	
		 	
            in_var_map=membermethod.getInputvar().keys()
            count=membermethod.getUsedCounter()
            count=count+1
            membermethod.setUsedCounter(count)

            if membermethod_cur is not None:
                membermethod_cur=functionvarmap[functionname]
                in_var_map_cu=membermethod_cur.getInputvar().keys()
                all_local_var=[]
                all_local_var_cu=[]
                if in_var_map is not None:
                    for x in in_var_map:
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                if membermethod.getLocalvar() is not None:
                    for x in membermethod.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var.append(x)
                if in_var_map_cu is not None:
                    for x in in_var_map_cu:
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
                if membermethod_cur.getLocalvar() is not None:
                    for x in membermethod_cur.getLocalvar().keys():
                        if externalvarmap is not None:
                            if x not in externalvarmap.keys():
                                all_local_var_cu.append(x)
									
                if membermethod.getInputvar() is not None:
                    all_var_int=intersect3(all_local_var,all_local_var_cu,membermethod.getInputvar().keys())
											
                input_map={}
			
			
                if statement.left.args is not None:
                    for x in range(0, len(statement.right.args.exprs)):
                        arg=statement.right.args.exprs
                        input_map[in_var_map[x]]=arg[x]
					#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+arg[x].name),rvalue=c_ast.ID(name=in_var_map[x])))
					#update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+in_var_map[x]),rvalue=c_ast.ID(name=arg[x].name)))
			
			
			
                new_blocks=reconstructStmtBlock(membermethod.getBody().block_items,count,membermethod.getLocalvar(),input_map,membermethod.getSerialNo(),all_var_int)
			
                new_blocks=substituteFunBlock(new_blocks,functionvarmap,functionname,externalvarmap)
			
			
                for x in membermethod.getInputvar():
                    if x in all_var_int:
                        if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getInputvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                        else:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getInputvar()[x].getVariableType()
				
                for x in membermethod.getLocalvar():
                    if x in all_var_int:
                        if membermethod.getInputvar()[x].getDimensions() is not None and membermethod.getLocalvar()[x].getDimensions()>0:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]='array'
                        else:
                            new_variable['f'+str(membermethod.getSerialNo())+'_'+str(count)+'_'+x]=membermethod.getLocalvar()[x].getVariableType()
						
		
		
                for stmt in new_blocks:
                    update_statements.append(stmt)
		 	
                stmt_right=c_ast.ID(name='f'+str(membermethod.getSerialNo())+'_'+str(count)+'_RET')
            else:
                stmt_right=statement.right
		 	
            return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=stmt_right),update_statements	
	
        else:
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right),new_block
    return None


def getIndexVariable(statement,local_map):
    if type(statement) is c_ast.BinaryOp:
        getIndexVariable(statement.left,local_map)
        getIndexVariable(statement.right,local_map)
    elif type(statement) is c_ast.ArrayRef:
        if type(statement.name) is c_ast.ArrayRef:
            getIndexVariable(statement.name,local_map)
        local_map[statement.subscript.name]=statement.subscript.name
    

new_variable_array={}

def reconstructStmtBlock(statements,count,var_map,in_var_map,fun_count,all_var_int):
    update_statements=[]
    global counter_variableMap
    global counter_variableMap_Conf
    global new_variable_array
    for statement in statements:
                if type(statement) is c_ast.Decl:
                    if type(statement.type) is c_ast.ArrayDecl:
                        if statement.name in all_var_int:
                            update_statements.append(c_ast.Decl(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.name, quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=renameArrayName(statement.type), init=statement.init, bitsize=statement.bitsize))
                        else:
                            update_statements.append(statement)
                    elif type(statement.type) is c_ast.PtrDecl:
                        if type(statement.type.type) is c_ast.TypeDecl:
                            update_statements.append(c_ast.TypeDecl('f'+str(fun_count)+'_'+str(count)+'_'+statement.name, quals=statement.type.type.quals, type=statement.type.type.type))
                    else:
                        if statement.name in all_var_int:
                            update_statements.append(c_ast.Decl(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.name, quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.TypeDecl(declname='f'+str(fun_count)+'_'+str(count)+'_'+statement.type.declname, quals=statement.type.quals, type=statement.type.type), init=statement.init, bitsize=statement.bitsize))
                        else:
                            update_statements.append(statement)

                elif type(statement) is c_ast.Assignment:
                    if type(statement.lvalue) is c_ast.ID:
                        if statement.lvalue.name in all_var_int:
                            update_statements.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.lvalue.name), rvalue=reconstructStmt(statement.rvalue,count,var_map,in_var_map,fun_count,all_var_int)))
                        else:
                            if statement.lvalue.name in in_var_map.keys():
                                                r_statement=reconstructStmt(statement.rvalue,count,var_map,in_var_map,fun_count,all_var_int)
                                                l_statement=in_var_map[statement.lvalue]
                                                if '_PROVE' in statement.lvalue.name:
                                                    #local_map={}
                                                    #getIndexVariable(r_statement,local_map)
                                                    #if local_map==counter_variableMap_Conf:
                                                    #new_variable_array[l_statement.name]=creatArrayDec(l_statement.name,counter_variableMap_Conf.keys())
                                                    new_variable_array[l_statement.name]=len(counter_variableMap_Conf.keys())
                                                    l_statement=create_Assert_Array(l_statement.name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)
                                                update_statements.append(c_ast.Assignment(op='=', lvalue=l_statement, rvalue=r_statement))
                            else:
                                                r_statement=reconstructStmt(statement.rvalue,count,var_map,in_var_map,fun_count,all_var_int)
                                                l_statement=statement.lvalue
                                                #if '_PROVE' in statement.lvalue.name:
                                                #    new_variable_array[l_statement.name]=len(counter_variableMap_Conf.keys())
                                                #    l_statement=create_Assert_Array(l_statement,counter_variableMap_Conf.keys(),counter_variableMap_Conf)
                                                update_statements.append(c_ast.Assignment(op='=', lvalue=l_statement, rvalue=r_statement))
                    else:
                                r_statement=reconstructStmt(statement.rvalue,count,var_map,in_var_map,fun_count,all_var_int)
                                l_statement=reconstructStmt(statement.lvalue,count,var_map,in_var_map,fun_count,all_var_int)
                                #if '_PROVE' in statement.lvalue.name:
                                #    new_variable_array[l_statement.name]=len(counter_variableMap_Conf.keys())
                                #    l_statement=create_Assert_Array(l_statement.name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)
                                update_statements.append(c_ast.Assignment(op='=', lvalue=l_statement, rvalue=r_statement))
                elif type(statement) is c_ast.While:
                    update_statements.append(reconstructStmt(c_ast.While(cond=reconstructStmt(statement.cond,count,var_map,in_var_map,fun_count,all_var_int),stmt=c_ast.Compound(block_items=reconstructStmtBlock(statement.stmt.block_items,count,var_map,in_var_map,fun_count,all_var_int))),count,var_map,in_var_map,fun_count,all_var_int ))
                elif type(statement) is c_ast.If:
                    update_statements.append(reconstructStmtIf(statement,count,var_map,in_var_map,fun_count,all_var_int))
                else:
                    if type(statement) is c_ast.FuncCall:
                        update_statements.append(statement)
                    else:
                                #if type(statement) is c_ast.Decl:
                                #        var_type=None
                                #        initial_value=None
                                #        for child in statement.children():
                                #                if type(child[1]) is c_ast.TypeDecl:
                                #                	if type(child[1].type) is c_ast.IdentifierType:
                                #                        	var_type=child[1].type.names[0]
                                #                else:
                                #                        initial_value=child[1]
                                #        if initial_value is not None:
                                #        	
                                #        	if statement.name in all_var_int:
                                #        		update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.name), rvalue=reconstructStmt(initial_value,count,var_map,in_var_map,fun_count,all_var_int)))	
                                #        	else:
                                #        		if statement.name in in_var_map.keys():
                                #        			update_statements.append(c_ast.Assignment(op='=',lvalue=in_var_map[statement.name], rvalue=reconstructStmt(initial_value,count,var_map,in_var_map,fun_count,all_var_int)))
                                #        		else:
                                #        			update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name=statement.name), rvalue=reconstructStmt(initial_value,count,var_map,in_var_map,fun_count,all_var_int)))
                                        	
                                #else:
                                if type(statement) is not c_ast.Decl:
                                    update_statements.append(statement)
    return update_statements





def reconstructStmtIf(statement,count,var_map,in_var_map,fun_count,all_var_int):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			new_iftrue=c_ast.Compound(block_items=reconstructStmtBlock(statement.iftrue.block_items,count,var_map,in_var_map,fun_count,all_var_int))
		else:
			new_iftrue=statement.iftrue
		if type(statement.iffalse) is c_ast.Compound:
			new_iffalse=c_ast.Compound(block_items=reconstructStmtBlock(statement.iffalse.block_items,count,var_map,in_var_map,fun_count,all_var_int))
		else:
			if type(statement.iffalse) is c_ast.If:
				new_iffalse=reconstructStmtIf(statement.iffalse,count,var_map,in_var_map,all_var_int)
	
	return c_ast.If(cond=reconstructStmt(statement.cond,count,var_map,in_var_map,fun_count,all_var_int), iftrue=new_iftrue, iffalse=new_iffalse)






def reconstructStmt(statement,count,var_map,in_var_map,fun_count,all_var_int):
    if type(statement) is c_ast.ID:
        if statement.name in var_map.keys() or statement.name in in_var_map.keys():
            if statement.name in all_var_int:
                return c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.name)
            else:
                return statement
        else:
            return statement
    elif type(statement) is c_ast.UnaryOp:
        return c_ast.UnaryOp(op=statement.op,expr=reconstructStmt(statement.expr,count,var_map,in_var_map,fun_count,all_var_int))
    elif type(statement) is c_ast.Constant:
        return statement
    elif type(statement) is c_ast.BinaryOp:
        if type(statement.left) is c_ast.ID and type(statement.right) is c_ast.ID:
            stmt_left=None
            stmt_right=None
            if statement.left.name in var_map.keys() or statement.left.name in in_var_map.keys():
                if statement.left.name in all_var_int:
                    stmt_left=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.left.name)
                else:
                    stmt_left=statement.left
 						
            else:
                stmt_left=statement.left
 				
            if statement.right.name in var_map.keys() or statement.right.name in in_var_map.keys():
                if statement.right.name in all_var_int:
                    stmt_right=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.right.name)
                else:
                    stmt_right=statement.right
						
            else:
                stmt_right=statement.right
 			
            return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=stmt_right)
                        
        elif type(statement.left) is c_ast.ID and type(statement.right) is c_ast.ArrayRef:
            stmt_left=None
            stmt_right=None
            if statement.left.name in var_map.keys() or statement.left.name in in_var_map.keys():
                if statement.left.name in all_var_int:
                    stmt_left=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.left.name)
                else:
                    stmt_left=statement.left
 						
            else:
                stmt_left=statement.left
 				
            stmt_right=renameArrayName1(statement.right,count,var_map,in_var_map,fun_count,all_var_int)
 			
            return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=stmt_right)

        elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.ID:
            stmt_left=None
            stmt_right=None
                        
            stmt_left=renameArrayName1(statement.left,count,var_map,in_var_map,fun_count,all_var_int)
 				
            if statement.right.name in var_map.keys() or statement.right.name in in_var_map.keys():
                if statement.right.name in all_var_int:
                    stmt_right=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.right.name)
                else:
                    stmt_right=statement.right
						
            else:
                stmt_right=statement.right
 			
            return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=stmt_right)
 				
        elif type(statement.left) is c_ast.ID and type(statement.right) is c_ast.BinaryOp:
            stmt_left=None
            if statement.left.name in all_var_int:
                stmt_left=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.left.name)
            else:
                stmt_left=statement.left
					
            return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
 				
 			
        elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.ID:
            stmt_right=None
 			
            if statement.right.name in all_var_int:
                stmt_right=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+statement.right.name)
            else:
                stmt_right=statement.right
					
            return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=stmt_right)
 				
        elif type(statement.left) is c_ast.ID and type(statement.right) is c_ast.UnaryOp:
            stmt_left=None
 			
            if statement.left.name in all_var_int:
                stmt_left=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.left.name)
            else:
				
                stmt_left=statement.left
					
            return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
 				
 			
        elif type(statement.left) is c_ast.UnaryOp and type(statement.right) is c_ast.ID:
            stmt_right=None
 			
 		
            if statement.right.name in all_var_int:
                stmt_right=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+statement.right.name)
            else:
                stmt_right=statement.right
					
 			
            return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=stmt_right)
 					
 		

 		
        elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.Constant:
 		
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right)
 			
        elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.ID:
            stmt_right=None
  
            if statement.right.name in all_var_int:
                stmt_right=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.right.name)
            else:
                stmt_right=statement.right
								
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=stmt_right)
 				
 			
        elif type(statement.left) is c_ast.ID and type(statement.right) is c_ast.Constant:
            stmt_left=None
 			
            if statement.left.name in all_var_int:
                stmt_left=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.left.name)
            else:
                stmt_left=statement.left
					
            return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=statement.right)
 			
        elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.ArrayRef:
            stmt_right=None
  
            stmt_right=renameArrayName1(statement.right,count,var_map,in_var_map,fun_count,all_var_int)
								
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=stmt_right)
 				
 			
        elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.Constant:
            stmt_left=None
 			
            stmt_left=renameArrayName1(statement.left,count,var_map,in_var_map,fun_count,all_var_int)
					
            return c_ast.BinaryOp(op=statement.op,left=stmt_left, right=statement.right)
                    
                        
 				
        elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.UnaryOp:
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
        elif type(statement.left) is c_ast.UnaryOp and type(statement.right) is c_ast.Constant:
            return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=statement.right)	
        elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.ArrayRef:
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
        elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.Constant:
            return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=statement.right)
  		
        elif type(statement.left) is c_ast.Constant and type(statement.right) is c_ast.BinaryOp:
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
        elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.Constant:
            return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=statement.right)
        elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.BinaryOp:
            return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
        elif type(statement.left) is c_ast.UnaryOp and type(statement.right) is c_ast.UnaryOp:
            return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
        elif type(statement.left) is c_ast.UnaryOp and type(statement.right) is c_ast.BinaryOp:
            return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
        elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.UnaryOp:
            return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
 		
        elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.BinaryOp:
            return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
        elif type(statement.left) is c_ast.BinaryOp and type(statement.right) is c_ast.ArrayRef:
            return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
 		
        elif type(statement.left) is c_ast.UnaryOp and type(statement.right) is c_ast.ArrayRef:
            return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
        elif type(statement.left) is c_ast.ArrayRef and type(statement.right) is c_ast.UnaryOp:
            return c_ast.BinaryOp(op=statement.op,left=reconstructStmt(statement.left,count,var_map,in_var_map,fun_count,all_var_int), right=reconstructStmt(statement.right,count,var_map,in_var_map,fun_count,all_var_int))
 		
        else:
            return c_ast.BinaryOp(op=statement.op,left=statement.left, right=statement.right)
    else:
        return statement
    return None
	







#
#Reconstruct Program by Removing assert,assume,error
#

def reconstructPreDefinedFun(statements):
    global fail_count
    global error_count
    global assume_count
    global assert_count
    global new_variable
    global counter_variableMap
    global counter_variableMap_Conf
    global array_size_variableMap
        
    counter_variableMap={}

    counter_variableMap_Conf={}

    array_size_variableMap={}
        
    statements=getPreDefinedFun(statements,0,{})
    update_statements=[]
    temp_update_statements=[]

    for var in new_variable.keys():
        if type(new_variable[var]) is str:
            temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
        else:
            temp=new_variable[var]
        temp_update_statements.append(temp)
                
    for statement in temp_update_statements:
        update_statements.append(statement)
    for statement in statements:
        update_statements.append(statement)

        #for statement in statements:
        #    #statement.show()
        #    #if type(statement) is not c_ast.Decl:
        #    update_statements.append(statement)
        
    new_variable={}
    return update_statements



counter_variableMap={}

counter_variableMap_Conf={}

array_size_variableMap={}

def getPreDefinedFun(statements,degree,dec_map):
    update_statements=[]
    global fail_count
    global error_count
    global assume_count
    global assert_count
    global new_variable
    global counter_variableMap
    global counter_variableMap_Conf
    global array_size_variableMap
        #print '$$$$$$$$$$$$$$$$$@@@@@@@@@@@@'
        #print new_variable
        #print '$$$$$$$$$$$$$$$$$@@@@@@@@@@@@'
    for statement in statements:
        if type(statement) is c_ast.If:
            stmt=getPreDefinedFunIf(statement,degree,dec_map)
            if stmt is not None:
                update_statements.append(stmt)
        elif type(statement) is c_ast.While:
            local_counter_varMap=getCounterVariables(statement.cond,counter_variableMap)
            getConfirmationVariables(statement.stmt.block_items,counter_variableMap,counter_variableMap_Conf)
            getCounterVariablesConst(statement.cond,array_size_variableMap)
            getArraySizeVar(local_counter_varMap,counter_variableMap_Conf,array_size_variableMap)
            degree=degree+1
            new_block_items1=getPreDefinedFun(statement.stmt.block_items,degree,dec_map)
            degree=degree-1
            for item in local_counter_varMap.keys():
                if item in counter_variableMap.keys():
                    del counter_variableMap[item]
                if item in counter_variableMap_Conf.keys():
                    del counter_variableMap_Conf[item]
                if item in array_size_variableMap.keys():
                    del array_size_variableMap[item]
			#start comment on 16/08/2017
			#if degree==0:
                        #    array_size_variableMap.clear()
                        #    for var in dec_map.keys():
                        #        if type(dec_map[var]) is str:
                        #            temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
                        #        else:
                        #            temp=dec_map[var]
                        #        update_statements.append(temp)
                        #        del dec_map[var]
                        #        del new_variable[var]
                        #end comment on 16/08/2017
            update_statements.append(c_ast.While(cond=statement.cond, stmt=c_ast.Compound(block_items=new_block_items1)))
		#elif type(statement) is c_ast.Label:
		#	if statement.name=='ERROR':
                #                print 'XXXXXXXXXXXXXXXXXXXXXXXX'
		#		fail_count=fail_count+1
		#		update_statements.append(statement)
		#		update_statements.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(fail_count)+'_'+'FAILED'), rvalue=c_ast.Constant(type='int', value='1')))
		#		new_variable['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                #                dec_map['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
		#		
		#	else:
		#		update_statements.append(statement)
        elif type(statement) is c_ast.FuncCall:
            parameters=[]
            if statement.args is not None:
                for param in statement.args.exprs:
                    if type(param) is c_ast.ID:
                        parameters.append(param)
                    elif type(param) is c_ast.Constant:
                        parameters.append(param)
                    elif type(param) is c_ast.BinaryOp:
                        parameters.append(param)
                    elif type(param) is c_ast.FuncCall:
                        parameters.append(param)
                    else:
                        parameters.append(param)
                if statement.name.name=='__VERIFIER_assert':
                                    new_statement=None
                                    for parameter in parameters:
                                            if new_statement is None:
                                                    assert_count=assert_count+1
                                                    new_var_name=c_ast.ID(name='_'+str(assert_count)+'_'+'PROVE')
                                                    if len(counter_variableMap_Conf.keys())>0:
                                                        
                                                            if len(counter_variableMap_Conf)==degree:
                                                                new_var_name=create_Assert_Array(new_var_name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)
                                                            elif len(counter_variableMap)==degree:
                                                                new_var_name=create_Assert_Array(new_var_name,counter_variableMap.keys(),counter_variableMap)
                                                            else:
                                                                new_var_name=create_Assert_Array(new_var_name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)
                                                            
                                                
                                                    status,parameter=modificationOfCondition(parameter)
                                                    if status==True:
                                                            parameter=c_ast.BinaryOp(op='>',left=parameter,right=c_ast.Constant(type='int', value='0'))
						
                                                    new_statement= c_ast.Assignment(op='=', lvalue=new_var_name, rvalue=parameter)
						#new_variable['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                    if len(counter_variableMap_Conf.keys())>0:
                                            
                                                            new_variable['_'+str(assert_count)+'_'+'PROVE']=creatArrayDec('_'+str(assert_count)+'_'+'PROVE',array_size_variableMap.keys(),degree)
                                                            dec_map['_'+str(assert_count)+'_'+'PROVE']=creatArrayDec('_'+str(assert_count)+'_'+'PROVE',array_size_variableMap.keys(),degree)
                                                        
                                                    else:
                                                            new_variable['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                        
                                                            dec_map['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                        
                                                #print '#############@@@@@@@@'
                                                #print new_variable['_'+str(assert_count)+'_'+'PROVE'].show()
						#print '#############@@@@@@@@'
                                            else:
                                                    assert_count=assert_count+1
                                                    
                                                    new_var_name=c_ast.ID(name='_'+str(assert_count)+'_'+'PROVE')
                                                    if len(counter_variableMap_Conf.keys())>0:
                                                            if len(counter_variableMap_Conf)==degree:
                                                                new_var_name=create_Assert_Array(new_var_name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)
                                                            elif len(counter_variableMap)==degree:
                                                                new_var_name=create_Assert_Array(new_var_name,counter_variableMap.keys(),counter_variableMap)
                                                            else:
                                                                new_var_name=create_Assert_Array(new_var_name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)
                                                            #new_var_name=create_Assert_Array(new_var_name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)

                                                    status,stmt=modificationOfCondition(parameter)
                                                    if status==True:
                                                            parameter=c_ast.BinaryOp(op='>',left=parameter,right=c_ast.Constant(type='int', value='0'))
                                                    new_statement=c_ast.BinaryOp(op='&&', left=c_ast.Assignment(op='=', lvalue=new_var_name, rvalue=parameter), right=new_statement)
                                                    #new_variable['_'+str(assert_count)+'_'+'PROVE']='Array'
                                                    if len(counter_variableMap_Conf.keys())>0:
                                                            new_variable['_'+str(assert_count)+'_'+'PROVE']=creatArrayDec('_'+str(assert_count)+'_'+'PROVE',array_size_variableMap.keys(),degree)
                                                            

                                                        
                                                            dec_map['_'+str(assert_count)+'_'+'PROVE']=creatArrayDec('_'+str(assert_count)+'_'+'PROVE',array_size_variableMap.keys(),degree)
                                                    else:
                                                            new_variable['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                        
                                                            dec_map['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                        

                                    update_statements.append(new_statement)
                elif statement.name.name=='__VERIFIER_assume':
                                    new_statement=None
                                    for parameter in parameters:
                                            if new_statement is None:
                                                    assume_count=assume_count+1
						
                                                    new_var_name=c_ast.ID(name='_'+str(assume_count)+'_'+'ASSUME')
                                                    if len(counter_variableMap_Conf.keys())>0:
                                                            new_var_name=create_Assert_Array(new_var_name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)

                                                    status,parameter=modificationOfCondition(parameter)
                                                    if status==True:
                                                            parameter=c_ast.BinaryOp(op='>',left=parameter,right=c_ast.Constant(type='int', value='0'))
						
                                                    new_statement= c_ast.Assignment(op='=', lvalue=new_var_name, rvalue=parameter)
                                                    if len(counter_variableMap_Conf.keys())>0:
                                                        new_variable['_'+str(assume_count)+'_'+'ASSUME']=creatArrayDec('_'+str(assume_count)+'_'+'ASSUME',array_size_variableMap.keys(),degree)
                                                    
                                                        dec_map['_'+str(assume_count)+'_'+'ASSUME']=creatArrayDec('_'+str(assume_count)+'_'+'ASSUME',array_size_variableMap.keys(),degree)
                                                    
                                                    else:
                                                        new_variable['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                                    
                                                        dec_map['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                            else:
                                                    assume_count=assume_count+1
						
                                                    new_var_name=c_ast.ID(name='_'+str(assume_count)+'_'+'ASSUME')
                                                    if len(counter_variableMap_Conf.keys())>0:
                                                            new_var_name=create_Assert_Array(new_var_name,counter_variableMap_Conf.keys(),counter_variableMap_Conf)
						
                                                    status,stmt=modificationOfCondition(parameter)
                                                    if status==True:
                                                            parameter=c_ast.BinaryOp(op='>',left=parameter,right=c_ast.Constant(type='int', value='0'))						
						
                                                    new_statement=c_ast.BinaryOp(op='&&', left=c_ast.Assignment(op='=', lvalue=new_var_name, rvalue=parameter), right=new_statement)
                                                    if len(counter_variableMap_Conf.keys())>0:
                                                        new_variable['_'+str(assume_count)+'_'+'ASSUME']=creatArrayDec('_'+str(assume_count)+'_'+'ASSUME',array_size_variableMap.keys(),degree)
                                                    
                                                        dec_map['_'+str(assume_count)+'_'+'ASSUME']=creatArrayDec('_'+str(assume_count)+'_'+'ASSUME',array_size_variableMap.keys(),degree)
                                                    
                                                    else:
                                                        new_variable['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                                    
                                                        dec_map['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                    update_statements.append(new_statement)
                else:
                                    update_statements.append(statement)
            else:
                    if statement.name.name=='__VERIFIER_error':
                                    fail_count=fail_count+1
                                    #update_statements.append(statement)
                                    update_statements.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(fail_count)+'_'+'FAILED'), rvalue=c_ast.Constant(type='int', value='1')))
                                    new_variable['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                                    dec_map['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                    else:
                                    update_statements.append(statement)
		
        else:
            update_statements.append(statement)
    return update_statements
	


#
#Get Counter Variable
#

def getCounterVariables(statement,variableMap):
    variableMap_Local={}
    if type(statement) is c_ast.UnaryOp:
        if type(statement.expr) is c_ast.ID:
            variableMap[statement.expr.name]=statement.expr.name
            variableMap_Local[statement.expr.name]=statement.expr.name
        else:
            temp_variableMap=getCounterVariables(statement.expr,variableMap)
            if temp_variableMap is not None:
                for item in temp_variableMap.keys():
                    variableMap_Local[item]=item
    elif type(statement) is c_ast.ID:
        variableMap[statement.name]=statement.name
        variableMap_Local[statement.name]=statement.name
	#elif type(statement) is c_ast.ArrayRef:
	#	getCounterVariables(statement.expr,variableMap)
    elif type(statement) is c_ast.BinaryOp:
        if type(statement.left) is c_ast.ID:
            variableMap[statement.left.name]=statement.left.name
            variableMap_Local[statement.left.name]=statement.left.name
        else:
            temp_variableMap=getCounterVariables(statement.left,variableMap)
            if temp_variableMap is not None:
                for item in temp_variableMap.keys():
                    variableMap_Local[item]=item
        if type(statement.right) is c_ast.ID:
            variableMap[statement.right.name]=statement.right.name
            variableMap_Local[statement.right.name]=statement.right.name
        else:
            temp_variableMap=getCounterVariables(statement.right,variableMap)
            if temp_variableMap is not None:
                for item in temp_variableMap.keys():
                    variableMap_Local[item]=item
    elif type(statement) is c_ast.ArrayRef:
        getAllSubScripts(statement,variableMap,variableMap_Local)
    return variableMap_Local


#
#Get Varible Constant from Condition
#

def getCounterVariablesConst(statement,variableMap):
    if type(statement) is c_ast.UnaryOp:
        if type(statement.expr) is c_ast.ID:
            variableMap[statement.expr.name]=statement.expr.name
        else:
            getCounterVariablesConst(statement.expr,variableMap)    
    elif type(statement) is c_ast.ID:
        variableMap[statement.name]=statement.name
    elif type(statement) is c_ast.Constant:
        variableMap[statement.value]=statement.value
	#elif type(statement) is c_ast.ArrayRef:
	#	getCounterVariables(statement.expr,variableMap)
    elif type(statement) is c_ast.BinaryOp:
        if type(statement.left) is c_ast.ID:
            variableMap[statement.left.name]=statement.left.name
        else:
            getCounterVariablesConst(statement.left,variableMap)
        if type(statement.right) is c_ast.ID:
            variableMap[statement.right.name]=statement.right.name
        else:
            getCounterVariablesConst(statement.right,variableMap)









def getAllSubScripts(statement,variableMap,variableMap_Local):
    if type(statement.subscript) is c_ast.ID:
        variableMap[statement.subscript.name]=statement.name
        variableMap_Local[statement.subscript.name]=statement.name
    if type(statement.name) is c_ast.ArrayRef:
        getAllSubScripts(statement.name,variableMap,variableMap_Local)
#
#Get Counter Variable
#

def getCounterVariablesConf(statement,variableMap):
    variableMap_Local={}
    if type(statement) is c_ast.UnaryOp:
        if type(statement.expr) is c_ast.ID:
            variableMap[statement.expr.name]=statement.expr.name
        else:
            getCounterVariablesConf(statement.expr,variableMap)    
    elif type(statement) is c_ast.ID:
        variableMap[statement.name]=statement.name
        #elif type(statement) is c_ast.Constant:
        #        variableMap[statement.value]=statement.value
	#elif type(statement) is c_ast.ArrayRef:
	#	getCounterVariables(statement.expr,variableMap)
    elif type(statement) is c_ast.BinaryOp:
        if type(statement.left) is c_ast.ID:
            variableMap[statement.left.name]=statement.left.name
        else:
            getCounterVariablesConf(statement.left,variableMap)
        if type(statement.right) is c_ast.ID:
            variableMap[statement.right.name]=statement.right.name
        else:
            getCounterVariablesConf(statement.right,variableMap)






#
#Confirmation of Counter Variable
#

def getConfirmationVariables(statements,variableMap,variableMap_Conf):
    for statement in statements:
        if type(statement) is c_ast.Assignment:
            if type(statement.lvalue) is c_ast.ID:
                    if statement.lvalue.name in variableMap.keys():
                        variableMapExp={}
                        getCounterVariablesConf(statement.rvalue,variableMapExp)
                        if statement.lvalue.name in variableMapExp.keys():
                            variableMap_Conf[statement.lvalue.name]=statement.lvalue.name

def getArraySizeVar(local_counter_varMap,counter_variableMap_Conf,array_size_variableMap):
    for var in local_counter_varMap.keys():
        if var in counter_variableMap_Conf.keys() and var in array_size_variableMap.keys():
            #array_size_variableMap[var]=var
            del array_size_variableMap[var]
                




#create_Assert_Array(['x','y'],{'x':'x','y':'y'})
def create_Assert_Array(array_name,items,variableMap):
	if len(items)>0:
		if len(items[1:])>0:
			return c_ast.ArrayRef(name=create_Assert_Array(array_name,items[:-1],variableMap), subscript=c_ast.ID(name=items[-1]))	
		else:
			return c_ast.ArrayRef(name=array_name, subscript=c_ast.ID(name=items[-1]))
	return None
	


#creatArrayDec('a',['x','y']).show()

def creatArrayDec(name,parameterlist,degree):
    str_parameterlist=None
    count=0
    generator = c_generator.CGenerator()
    #for para in parameterlist:
    #    if is_number(para)==True and '.' in para:
    #        para=str(int(para.split(".")[0]))
    arraysize=1000000
    if degree==2:
        arraysize=100000
    elif degree==3:
        arraysize=100000
        
    for x in range(0, degree):
        if str_parameterlist==None:
            
            str_parameterlist='['+str(arraysize)+']'
        else:
            str_parameterlist='['+str(arraysize)+']'+str_parameterlist
        #if count<degree:
        #    if str_parameterlist==None:
        #        str_parameterlist='['+para+']'
        #        #str_parameterlist='['+']'
        #    else:
        #        str_parameterlist='['+para+']'+str_parameterlist
        #count=count+1
    #print '-----------@@@@@@@@@@@@'
    #print parameterlist
    #print count
    #print degree
    #print '-----------@@@@@@@@@@@@'

            #str_parameterlist='['+']'+str_parameterlist
    if str_parameterlist is not None:
        function='int '+name+str_parameterlist
    else:
        function='int '+name
    main_function='void main(){'+function+';}'
    parser = c_parser.CParser()
    ast = parser.parse(main_function)
    return ast.ext[0].body.block_items[0]







#
#Reconstruct Program by Removing assert,assume,error
#

def getPreDefinedFunIf(statement,degree,dec_map):
    new_iftrue=None
    new_iffalse=None
    global fail_count
    global error_count
    global assume_count
    global assert_count
    global new_variable

    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Label:
			#if statement.iftrue.name=='ERROR':
			#	fail_count=fail_count+1
			#	new_block_items1=[]
			#	new_block_items1.append(c_ast.Label(name=statement.iftrue.name, stmt=[]))
			#	new_block_items1.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(fail_count)+'_'+'FAILED'), rvalue=c_ast.Constant(type='int', value='1')))
			#	new_iftrue=c_ast.Compound(block_items=new_block_items1)
			#	new_variable['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                        #        dec_map['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
            if type(statement.iftrue) is c_ast.FuncCall:
                parameters=[]
                if statement.iftrue.args is not None:
                    for param in statement.iftrue.args.exprs:
                        if type(param) is c_ast.ID:
                            parameters.append(param)
                        elif type(param) is c_ast.Constant:
                            parameters.append(param)
                        elif type(param) is c_ast.BinaryOp:
                            parameters.append(param)
                        elif type(param) is c_ast.FuncCall:
                            parameters.append(param)
                        else:
                            parameters.append(param)
                    if statement.iftrue.name.name=='__VERIFIER_assert':
                                            new_statement=None
                                            for parameter in parameters:
                                                    if new_statement is None:
                                                            assert_count=assert_count+1
                                                            status,parameter=modificationOfCondition(parameter)
                                                            if status==True:
                                                                    parameter=c_ast.BinaryOp(op='>',left=parameter,right=c_ast.Constant(type='int', value='0'))
                                                            new_statement= c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(assert_count)+'_'+'PROVE'), rvalue=parameter)
                                                            new_variable['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                            dec_map['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                    else:
                                                            assert_count=assert_count+1
                                                            status,parameter=modificationOfCondition(parameter)
                                                            if status==True:
                                                                    parameter=c_ast.BinaryOp(op='>',left=parameter,right=c_ast.Constant(type='int', value='0'))
                                                            new_statement=c_ast.BinaryOp(op='&&', left=c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(assert_count)+'_'+'PROVE'), rvalue=parameter), right=new_statement)
                                                            new_variable['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                            dec_map['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                            new_iftrue=new_statement
                    elif statement.iftrue.name.name=='__VERIFIER_assume':
                                            new_statement=None
                                            for parameter in parameters:
                                                    if new_statement is None:
                                                            assume_count=assume_count+1
                                                            new_statement= c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(assume_count)+'_'+'ASSUME'), rvalue=parameter)
                                                            new_variable['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                                            dec_map['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                                    else:
                                                            assume_count=assume_count+1
                                                            new_statement=c_ast.BinaryOp(op='&&', left=c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(assume_count)+'_'+'ASSUME'), rvalue=parameter), right=new_statement)
                                                            new_variable['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                                            dec_map['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                            new_iftrue=new_statement
                    elif statement.name.name=='__VERIFIER_error':
                                            fail_count=fail_count+1
                                            new_block_items1=[]
                                            #new_block_items1.append(c_ast.Label(name=statement.iftrue.name, stmt=[]))
                                            new_block_items1.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(fail_count)+'_'+'FAILED'), rvalue=c_ast.Constant(type='int', value='1')))
                                            new_iftrue=c_ast.Compound(block_items=new_block_items1)
                                            new_variable['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                                            dec_map['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                    else:
                                            new_iftrue=statement.iftrue
                                
        elif type(statement.iftrue) is c_ast.Compound:
                    
                        #degree=degree+1
                        
            new_block_items=getPreDefinedFun(statement.iftrue.block_items,degree,dec_map)
                        
                        #degree=degree-1
                        
            new_iftrue=c_ast.Compound(block_items=new_block_items)
        else:
            new_iftrue=statement.iftrue
			
    if type(statement.iffalse) is c_ast.Label:
                    #if statement.iffalse.name=='ERROR':
                    #        fail_count=fail_count+1
                    #        new_block_items1=[]
                    #        #new_block_items1.append(statement.iffalse)
                    #        new_block_items1.append(c_ast.Label(name=statement.iftrue.name, stmt=[]))
                    #        new_block_items1.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(fail_count)+'_'+'FAILED'), rvalue=c_ast.Constant(type='int', value='1')))
                    #        new_iffalse=c_ast.Compound(block_items=new_block_items1)
                    #        new_variable['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                    #        dec_map['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                    if type(statement.iffalse) is c_ast.FuncCall:
                            parameters=[]
                            if statement.iffalse.args is not None:
                                    for param in statement.iftrue.args.exprs:
                                            if type(param) is c_ast.ID:
                                                    parameters.append(param)
                                            elif type(param) is c_ast.Constant:
                                                    parameters.append(param)
                                            elif type(param) is c_ast.BinaryOp:
                                                    parameters.append(param)
                                    if statement.name.name=='__VERIFIER_assert':
                                            new_statement=None
                                            for parameter in parameters:
                                                    if new_statement is None:
                                                            assert_count=assert_count+1
                                                            new_statement= c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(assert_count)+'_'+'PROVE'), rvalue=parameter)
                                                            new_variable['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                            dec_map['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                    else:
                                                            assert_count=assert_count+1
                                                            new_statement=c_ast.BinaryOp(op='&&', left=c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(assert_count)+'_'+'PROVE'), rvalue=parameter), right=new_statement)
                                                            new_variable['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                                            dec_map['_'+str(assert_count)+'_'+'PROVE']='_'+str(assert_count)+'_'+'PROVE'
                                            new_iffalse=new_statement
                                    elif statement.name.name=='__VERIFIER_assume':
                                            new_statement=None
                                            for parameter in parameters:
                                                    if new_statement is None:
                                                            assume_count=assume_count+1
                                                            new_statement= c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(assume_count)+'_'+'ASSUME'), rvalue=parameter)
                                                            new_variable['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                                            dec_map['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                                    else:
                                                            assume_count=assume_count+1
                                                            new_statement=c_ast.BinaryOp(op='&&', left=c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(assume_count)+'_'+'ASSUME'), rvalue=parameter), right=new_statement)
                                                            new_variable['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                                            dec_map['_'+str(assume_count)+'_'+'ASSUME']='_'+str(assume_count)+'_'+'ASSUME'
                                            new_iffalse=new_statement
                                    elif statement.name.name=='__VERIFIER_error':
                                            fail_count=fail_count+1
                                            new_block_items1=[]
                                            #new_block_items1.append(c_ast.Label(name=statement.iftrue.name, stmt=[]))
                                            new_block_items1.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name='_'+str(fail_count)+'_'+'FAILED'), rvalue=c_ast.Constant(type='int', value='1')))
                                            new_iftrue=c_ast.Compound(block_items=new_block_items1)
                                            new_variable['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                                            dec_map['_'+str(fail_count)+'_'+'FAILED']='_'+str(fail_count)+'_'+'FAILED'
                                    else:
                                        new_iffalse=statement.iffalse
    elif type(statement.iffalse) is c_ast.Compound:
                    
                #degree=degree+1
                        
                new_block_items=getPreDefinedFun(statement.iffalse.block_items,degree,dec_map)
                        
                #degree=degree-1
                        
                new_iffalse=c_ast.Compound(block_items=new_block_items)
    else:
                if type(statement.iffalse) is c_ast.If:
                    new_iffalse=getPreDefinedFunIf(statement.iffalse,degree,dec_map)
                else:
                        new_iffalse=statement.iffalse
				
    if new_iftrue is not None and new_iffalse is None:
        return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=None)
    elif new_iftrue is not None and new_iffalse is not None:
        return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
    elif new_iffalse is not None and type(new_iffalse) is c_ast.Compound:
        return c_ast.If(cond=c_ast.UnaryOp(op='!', expr=statement.cond), iftrue=new_iffalse, iffalse=None)
    elif new_iffalse is not None and type(new_iffalse) is c_ast.If:
        return new_iffalse
    else:
        return None


#
#Convert Initiation to assignments   
#

def construct_program(statements):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Decl:
            if type(statement.type) is c_ast.ArrayDecl:
                        if statement.init is not None:
                            program=''                        	
                            d_list=[]
                            a_list=[]
			        
                            if statement.type.dim is None:
                                d_list_update,a_list_update=getDimesnion4Init(statement.init)
                                for x1 in d_list_update:
                                    d_list.append('initial_value'+x1)
                                for x1 in a_list_update:
                                    a_list.append(x1)
                            else:
                                for x in range(0, int(statement.type.dim.value)):
                                    d_list.append('initial_value.exprs['+str(x)+']')
                                    a_list.append('['+str(x)+']') 
                                d_list,a_list=getDimesnion(statement.type,d_list,a_list)
                                initial_value=statement.init
                                for x1 in range(0, len(d_list)):
                                        stmt_value=eval(d_list[x1])
                                        if type(stmt_value) is c_ast.Constant:
                                            program=program+statement.name+a_list[x1]+'='+str(eval(d_list[x1]+'.value'))+';'
                                        else:
                                            if type(stmt_value) is c_ast.UnaryOp: 
                                                program=program+statement.name+a_list[x1]+'= '+stmt_value.op+str(eval(d_list[x1]+'.expr.value'))+';'
                        	
                                program='int main{'+program+'}'
                                parser = c_parser.CParser()
                                ast1 = parser.parse(program)
                                function_body = ast1.ext[0].body                        	
                                statement.init=None
                                update_statements.append(statement)
                                for new_statement in function_body.block_items:
                                    update_statements.append(new_statement)
                        else:
                        	update_statements.append(statement)
                        
            else:
                update_statements.append(statement)
        else:
        	update_statements.append(statement)
    return update_statements


def getDimesnion(statement,d_list,a_list):
    if type(statement.type) is c_ast.ArrayDecl:
        d_list_update=[]
        a_list_update=[]
        for x1 in range(0, len(d_list)):
            for x2 in range(0, int(statement.type.dim.value)):
                d_list_update.append(d_list[x1]+'.exprs['+str(x2)+']')
                a_list_update.append(a_list[x1]+'['+str(x2)+']')
        return getDimesnion(statement.type,d_list_update,a_list_update)
    else:
        return d_list,a_list
        

def getDimesnion4Init(statement):
    d_list_update=[]
    a_list_update=[]
    if type(statement) is c_ast.InitList:
        count=0
        for x in statement.exprs:
            if type(x) is c_ast.InitList:
                new_d_list_update,new_a_list_update=getDimesnion4Init(x)
                for x1 in new_d_list_update:
                    d_list_update.append('.exprs['+str(count)+']'+x1)
                for x1 in new_a_list_update:
                    a_list_update.append('['+str(count)+']'+x1)
            else:
                d_list_update.append('.exprs['+str(count)+']')
                a_list_update.append('['+str(count)+']')
            count=count+1
    return d_list_update,a_list_update

			


#
#Remove C and C++ comments
# 
#

text='a=a+1;// test test'

def comment_remover(text):
    text=text.replace('extern void __VERIFIER_error() __attribute__ ((__noreturn__));','')
    def replacer(match):
        s = match.group(0)
        if s.startswith('/'):
            return " " # note: a space and not an empty string
        else:
            return s
    pattern = regex.compile(
        r'//.*?$|/\*.*?\*/|\'(?:\\.|[^\\\'])*\'|"(?:\\.|[^\\"])*"',
        regex.DOTALL | regex.MULTILINE
    )
    return regex.sub(pattern, replacer, text)
    

#
#text='#include "assert.h"'
#

def include_remover(text):
	status=False
	find=regex.compile(r'\#(\s+)include|\#include')
	group = find.search(text)
	if group is not None:
		status=True
	return status
    
#
#content='   /**   * Constructor, which takes the output of a toStringFull() and converts it back   * into an Id.  Should not normally be used.   *   * @param hex The hexadeciaml representation from the toStringFull()   *//*  public static Id build(char[] chars, int offset, int length) {    int[] array = new int[nlen];        for (int i=0; i<nlen; i++)       for (int j=0; j<8; j++)         array[nlen-1-i] =(array[nlen-1-i] << 4) | trans(chars[offset + 8*i + j]);        return build(array);  }  */int main() {  int offset, length, nlen = __VERIFIER_nondet_int();  i'
#
def comment_remover_file(content):
	new_content=content.replace('/*','\n/*').replace('*/','\n*/')        
	lines = new_content.splitlines()
	new_lines=[]
	for line in lines:
		if line is not None and include_remover( line )==False:
			new_lines.append(comment_remover(line))
	content = ''.join(new_lines)
	content=comment_remover_update(content)
	return content


def comment_remover_update(text):
    for x in regex.findall(r'("[^\n]*"(?!\\))|(//[^\n]*$|/(?!\\)\*[\s\S]*?\*(?!\\)/)',text,8):text=text.replace(x[1],'')
    return text


#
#Pre-Processig of Pre-Processor
#content='#include "assert.h #define LIMIT 1000000 #define LIMIT1 1000000'
#

def preProcessorHandling(content):
    
	new_content=content.replace(';',';\n').replace('}','}\n').replace('#','\n#').replace('int','\nint').replace('void','\nvoid').replace('void','\nvoid').replace('extern','\nextern ').replace('unsigned','\nunsigned').replace('Char','\nChar')   
	lines = new_content.splitlines()
	new_lines=[]
	defineMap={}
	for line in lines:
		definematch = regex.match("#define\\s+(\\w+)\\s+(.*)",line)
		if definematch:
			#deal with define statements by saving it in a dict
			#definedict[match.group(1)] = definedict[match.group(2)]
			defineMap[definematch.group(1)]=str(simplify(definematch.group(2)))
			new_lines.append(line)
	for line in new_lines:
		content=content.replace(line,'')
	return content,defineMap







#text='_PROVE'

def isAssertion(text):
	status=False
	find=regex.compile(r'\_PROVE')
	#find=regex.compile(r'(.+?)PROVE1')
	group = find.search(text)
	if group is not None:
		status=True
	return status



#text='A1'

def isArrayFinal(text):
	status=False
	if text is not None and (text.endswith('1') or text.endswith('_')):
		status=True
	return status


#text="'\0'"

def isChar(text):
    simple_escape = r"""([a-zA-Z._~!=&\^\-\\?'"])"""
    decimal_escape = r"""(\d+)"""
    hex_escape = r"""(x[0-9a-fA-F]+)"""
    escape_sequence = r"""(\\("""+simple_escape+'|'+decimal_escape+'|'+hex_escape+'))'
    cconst_char = r"""([^'\\\n]|"""+escape_sequence+')'
    char_const = "'"+cconst_char+"'"
    status=False
    find=regex.compile(char_const)
    #find=regex.compile(r'([\'][0-9a-fA-F\\]*[\'])')
	#find=regex.compile(r'(.+?)PROVE1')
    group = find.search(text)
    if group is not None:
        status=True
    return status






def getAssertAssume(f,o,a,cm):
    new_o={}
    new_a=[]
    new_f={}
    assert_list=[]
    assume_list=[]
    key_value=None
    assert_key_map={}
    for x in f:
        if x.find('_PROVE')<0 and x.find('_ASSUME')<0:
            new_f[x]=f[x]

    for x in o:
        if x.find('_PROVE')>0:
                key_value=x
                if key_value is not None:
                    assert_key_map[key_value]=o[x]
                assert_list.append(o[x])
        elif x.find('_ASSUME')>0:
            assume_list.append(o[x])
        elif x.find('_FAILED')>0:
                    #assert_list.append(o[x])

                    key_value=x
                    new_assert=[]
                    arg_list=expr_args(o[x][1])
                    if len(arg_list)>0:
                        new_assert.append('R')
                        parameterlist=[]
                        for para in arg_list:
                            parameterlist.append(para[0])
                        new_assert.append(parameterlist)
                        new_assert.append(o[x][1])
                        new_assert.append('0')
                        assert_list.append(new_assert)
                        if key_value is not None:
                            assert_key_map[key_value]=new_assert
                    else:
                        new_assert.append('c1')
                        new_assert.append(['==',o[x][1],['0']])
                        assert_list.append(new_assert)
                        if key_value is not None:
                            assert_key_map[key_value]=new_assert
                    new_o[x]=o[x]
        else:
            new_o[x]=o[x]


        
    update_new_a=[]
    for x in a:
                if x[0]=='i1':
                    if x[3][0].find('array')>0:
                        map_var={}
                        getAll_PROVE_ASSUME(x[4],map_var)
                        if len(map_var.keys())>0:
                            for e_array in map_var.keys():
                                new_e1 = copy.deepcopy(x)
                                var_array=eval("['"+e_array+"']")
                                var_e1=eval("['_x1']")
                                new_e1[3]=expr_replace(new_e1[3],var_e1,var_array)
                                new_e1[4]=expr_replace(new_e1[4],var_e1,var_array)
                                new_e1[4]=simplify_ind_equation(new_e1[4],map_var.keys())
                                update_new_a.append(new_e1)
                            x[4]=x[4][3]
                            x[4]=getEndElse(x[4])
                            update_new_a.append(x)
                        else:
                            update_new_a.append(x)
                    else:
                        if x[3][1][0]=='_s1':
                            map_var={}
                            getAll_PROVE_ASSUME(x[4],map_var)
                            x[4]=simplify_ind_equation(x[4],map_var.keys())
                            update_new_a.append(x) 
                        else:
                            update_new_a.append(x) 
                else:
                   update_new_a.append(x) 
        
        
        
        
       
        
    #for x in a:
        
    for x in update_new_a:
            if x[0]=='i1':
                if x[3][0].find('array')>0:
                    if '_PROVE' in expr2string1(x[4]):
                                        key_value=x[3][1][0]
                                        
                                        #new_word,const_var=getPrimeAssert(a,cm,x[2],cm[x[2]])
                                        new_word,const_var=getPrimeAssert(update_new_a,cm,x[2],cm[x[2]])

                                        if new_word is not None and const_var is not None:
                                            new_word=copy.deepcopy(new_word)
                                            new_word[-1]=eval("['"+const_var+"']")
                                        #list_conditin=getConditions(o,a,new_word)

                                        list_conditin=getConditions(o,update_new_a,new_word)
                                        print 
                                        con_stmt=None
                                        if list_conditin is not None:
                                            con_stmt=constructAndOrlist(list_conditin,'and')
                                        new_x = copy.deepcopy(x)
                                        #print '----------------------'
                                        #print expr2string1(x[4])
                                        #print '----------------------'
                                        x[4]=assert_filter1(x[4])
                                        var_e1=eval("['_x1']")
                                        x[3][1]=var_e1
                                        x[4]=assert_filter(x[4],x[3],new_word,cm)
                                        #x[4][2]=assert_filter(x[4][2],x[3],new_word,cm)  
                                        if  con_stmt is not None:
                                            new_stmt=[]
                                            new_stmt.append('implies')
                                            new_stmt.append(con_stmt)
                                            #new_stmt.append(x[4][2])
                                            #print '----------------------'
                                            #print expr2string1(con_stmt)
                                            #print expr2string1(x[4])
                                            #print '----------------------'
                                            new_stmt.append(x[4])
                                            #x[4][2]=new_stmt
                                            x[4]=new_stmt
                                        assert_list.append(x)
                                        if key_value is not None:
                                            assert_key_map[key_value]=x
                                        new_w = copy.deepcopy(new_x)
                                        new_w[4]=copy.deepcopy(new_x[4][3])
                                        #new_w[4]=copy.deepcopy(x[4])
                                        #new_a.append(new_w)
                    elif '_ASSUME' in expr2string1(x[4]):
                                        #new_word,const_var=getPrimeAssert(a,cm,x[2],cm[x[2]])
                                        new_word,const_var=getPrimeAssert(update_new_a,cm,x[2],cm[x[2]])
                                        if new_word is not None and const_var is not None:
                                            new_word=copy.deepcopy(new_word)
                                            new_word[-1]=eval("['"+const_var+"']")
                                        #list_conditin=getConditions(o,a,new_word)
                                        list_conditin=getConditions(o,update_new_a,new_word)
                                        con_stmt=None
                                        if list_conditin is not None:
                                            con_stmt=constructAndOrlist(list_conditin,'and')
                                        new_x = copy.deepcopy(x)
                                        x[4]=assert_filter1(x[4])
                                        var_e1=eval("['_x1']")
                                        x[3][1]=var_e1
                                        x[4]=assert_filter(x[4],x[3],new_word,cm)
                                        #x[4][2]=assert_filter(x[4][2],x[3],new_word,cm)  
                                        if  con_stmt is not None:
                                            new_stmt=[]
                                            new_stmt.append('implies')
                                            new_stmt.append(con_stmt)
                                            #new_stmt.append(x[4][2])
                                            new_stmt.append(x[4])
                                            #x[4][2]=new_stmt
                                            x[4]=new_stmt
                                        assume_list.append(x)
                                        new_w = copy.deepcopy(new_x)
                                        new_w[4]=copy.deepcopy(new_x[4][3])
                                        #new_w[4]=copy.deepcopy(x[4])
                                        #new_a.append(new_w)
                    else:
                        new_a.append(x)
        		
                elif x[3][0].find('_PROVE')>0:
        			#for var in cm.keys():
        			#	x[4]=expr_sub(x[4],cm[var],var)
                                if x[4][0].find('_PROVE')<0:
                                    assert_list.append(x)
                elif x[3][0].find('_ASSUME')>0:
                                assume_list.append(x)
                else:
                    new_a.append(x)
            elif x[0]=='i0':
                if x[2][0].find('_PROVE')>0:
                                if x[3][0].find('_PROVE')<0:
                                    assert_list.append(x)
                elif x[2][0].find('_ASSUME')>0:
                                assume_list.append(x)
                else:
                    new_a.append(x)
            else:
                new_a.append(x)

    return new_f,new_o,new_a,extractAssert(assert_list,cm),extractAssume(assume_list,cm),extractAssertMap(assert_key_map,cm)
        

def getPrimeAssert(a,cm,var,constant):
    pime_eq=None
    constant_var=None
    for x in a:
        if x[0]=='i1':
            if x[3][0].find('array')>0:
                if x[2]==var:
                    pime_eq=x[3]
                    constant_var=cm[x[2]]
                else :
                    if x[2] in constant:
                        pime_eq=x[3]
                        constant_var=cm[x[2]]
    return pime_eq,constant_var
            




        
def extractAssert(assert_list,cm):
    update_assert_stmts=[]
    for stmt in assert_list:
        if stmt[0]=='e':
            update_stmt=[]
            update_stmt.append('s0')
            update_stmt.append(stmt[2])
            key=wff2string1(update_stmt)
            for iteam in cm:
                key=key.replace(cm[iteam],iteam+'+1')
            flag=False
            for temp_stmt in assert_list:
                if temp_stmt[0]=='i1':
                    lefthandstmt=expr2string1(temp_stmt[3])
                    if 'and' not in str(key) and 'or' not in str(key):
                        if simplify(key)==simplify(lefthandstmt):
                            flag=True
            if flag==False:
                if update_stmt[0]=='s0':
                    temp=expr2string1(update_stmt[1])
                    if '_PROVE' not in temp:
                        if '<' in temp or '>' in temp or '=' in temp:
                            update_assert_stmts.append(update_stmt)
                else:
                    update_assert_stmts.append(update_stmt)
        else:
            if stmt[0]=='s0':
                temp=expr2string1(stmt[1])
                if '<' in temp or '>' in temp or '=' in temp:
                    update_assert_stmts.append(stmt)
            else:
                if stmt[0]=='i1':
                    stmt_assert=[]
                    stmt_assert.append('c1')
					#stmt_assert.append(stmt[4][2])
                    if stmt[4][0]=='ite':
                        stmt[4] = assert_filter1(stmt[4])
                    stmt_assert.append(stmt[4])
                    update_assert_stmts.append(stmt_assert)
                else:
                    update_assert_stmts.append(stmt)
			
    return update_assert_stmts
    

def extractAssertMap(assert_list_map,cm):
    update_assert_stmts_map={}
    for key_val in assert_list_map.keys():
        stmt=assert_list_map[key_val]
        if stmt[0]=='e':
            update_stmt=[]
            update_stmt.append('s0')
            update_stmt.append(stmt[2])
            key=wff2string1(update_stmt)
            for iteam in cm:
                key=key.replace(cm[iteam],iteam+'+1')
            flag=False
            for temp_stmt in assert_list_map.keys():
                if temp_stmt[0]=='i1':
                    lefthandstmt=expr2string1(temp_stmt[3])
                    if 'and' not in str(key) and 'or' not in str(key):
                        if simplify(key)==simplify(lefthandstmt):
                            flag=True
            if flag==False:
                if update_stmt[0]=='s0':
                    temp=expr2string1(update_stmt[1])
                    if '_PROVE' not in temp:
                        if '<' in temp or '>' in temp or '=' in temp:
                            update_assert_stmts_map[key_val]=update_stmt
                else:
                    update_assert_stmts_map[key_val]=update_stmt
        else:
            if stmt[0]=='s0':
                temp=expr2string1(stmt[1])
                if '<' in temp or '>' in temp or '=' in temp:
                    update_assert_stmts_map[key_val]=stmt
            else:
                if stmt[0]=='i1':
                    stmt_assert=[]
                    stmt_assert.append('c1')
                    #stmt_assert.append(stmt[4][2])
                    if stmt[4][0]=='ite':
                        stmt[4] = assert_filter1(stmt[4])
                    stmt_assert.append(stmt[4])
                    update_assert_stmts_map[key_val]=stmt_assert
                else:
                    update_assert_stmts_map[key_val]=stmt	
    return update_assert_stmts_map



def extractAssume(assume_list,cm):
    update_assume_stmts=[]
    for stmt in assume_list:
        if stmt[0]=='e':
            update_stmt=[]
            update_stmt.append('s0')
            update_stmt.append(stmt[2])
            key=wff2string1(update_stmt)
            for iteam in cm:
                key=key.replace(cm[iteam],iteam+'+1')
            flag=False
            for temp_stmt in assume_list:
                if temp_stmt[0]=='i1':
                    lefthandstmt=expr2string1(temp_stmt[3])
                    if 'and' not in str(key) and 'or' not in str(key):
                        if simplify(key)==simplify(lefthandstmt):
                            flag=True
            if flag==False:
                if update_stmt[0]=='s0':
                    temp=expr2string1(update_stmt[1])
                    if '_PROVE' not in temp:
                        if '<' in temp or '>' in temp or '=' in temp:
                            update_assume_stmts.append(update_stmt)
                else:
                    update_assume_stmts.append(update_stmt)
        else:
            if stmt[0]=='s0':
                temp=expr2string1(stmt[1])
                if '<' in temp or '>' in temp or '=' in temp:
                    update_assume_stmts.append(stmt)
            else:

                if stmt[0]=='i1':
                    stmt_assume=[]
                    stmt_assume.append('c1')
					#stmt_assert.append(stmt[4][2])
                    stmt_assume.append(stmt[4])
                    update_assume_stmts.append(stmt_assume)
                else:
                    update_assume_stmts.append(stmt)
			
    return update_assume_stmts






	


def assert_filter1(e):
    if e[:1]==['ite']:
        arg_list=expr_args(e)
        #print '---------@@@@@@@@@@@@@@@1'
        #print arg_list[0]
        #print '---------@@@@@@@@@@@@@@@1'
        new_cond=conditionFilter(arg_list[0])
        #print '---------@@@@@@@@@@@@@@@2'
        #print new_cond
        #print '---------@@@@@@@@@@@@@@@2'
        if new_cond==None:
            return arg_list[1]
        else:
            new_stmt1=assert_filter1(arg_list[1])
            new_cond1=conditionFilter(arg_list[1])
            new_stmt2=assert_filter1(arg_list[2])
            new_cond2=conditionFilter(arg_list[2])
            if new_cond==None:
                return e
            else:
                if isArrayFunction(new_cond1[0])==True and '_PROVE' in new_cond1[1][0]:
                    if isArrayFunction(new_cond2[0])==True and '_PROVE' in new_cond2[1][0]:
                        return new_cond 
                    else:
                        new_stmt=[]
                        new_stmt.append('implies')
                        new_stmt.append(expr_complement(new_cond))
                        new_stmt.append(new_cond2)
                        return new_stmt
                else:
                    if '_PROVE' in new_cond1[0]:
                        new_stmt=[]
                        new_stmt.append('implies')
                        new_stmt.append(expr_complement(new_cond))
                        new_stmt.append(new_cond2)
                        return new_stmt
                    else:
                        new_stmt=[]
                        new_stmt.append('implies')
                        new_stmt.append(new_cond)
                        new_stmt.append(new_cond1)
                        return new_stmt
                
                



def getEndElse(e):
    if e[:1]==['ite']:
        arg_list=expr_args(e)
        if arg_list[2][:1]==['ite']:
            return getEndElse(arg_list[2])
        else:
            return arg_list[2]
    else:
        return e


def getAll_PROVE_ASSUME(e,map_var):
    arg_list=expr_args(e)
    op=expr_op(e)
    if len(arg_list)==0:
        if op.find('_PROVE')>0 or op.find('_ASSUME')>0:
            map_var[op]=op
    elif op=='ite':
        for x in arg_list:
            getAll_PROVE_ASSUME(x,map_var)
    elif op=='and':
        for x in arg_list:
            getAll_PROVE_ASSUME(x,map_var)
    else:
        for x in arg_list:
            getAll_PROVE_ASSUME(x,map_var)




def conditionFilter(e):
    if e[0]=='and':
        arg_list=expr_args(e)
        temp=[]
        for i in range(1,len(arg_list)):
            if conditionFilter(arg_list[i]) is not None:
                temp.append(arg_list[i])
        if len(temp)==0:
            return None
        elif len(temp)==1:
            return  temp[0]
        else:
            return e2[0]+temp
    elif e[0]=='=':
        if '_x1' in e[1][0]:
            return None
    elif e[0]=='ite':
        arg_list=expr_args(e)
        new_cond=conditionFilter(arg_list[1])
        if new_cond==None:
            return None
        else:
            return new_cond
    else:
        return e







def assert_filter(e,e1,e2,cm): #e,e1,e2: expr
    if isArrayFunction(e[:1][0])==True:
        if e1[0][1]==e[:1][0][1]:
            temp=[]
            count=0
            arg_list=expr_args(e)
            for x in expr_args(e2):
                            if count<len(expr_args(e2))-1:
                                temp.append(arg_list[count])
                            else:
                                temp.append(x)
                            count=count+1
            return e2[:1]+temp
        else:
            return e
    else:
        return e[:1]+list(assert_filter(x,e1,e2,cm) for x in expr_args(e))


def getConditions(o,a,e):
    for x in o:
        list_condition=[]
        get_conditions(o[x],e,list_condition)
        if len(list_condition) >0:
            return list_condition
    for x in a:
        if x[0]=='i0':
            list_condition=[]
            get_conditions(x[3],e,list_condition)
            if len(list_condition) >0:
                return list_condition
    return None

        
def get_conditions(e,e_el,list_condition):
        if e[:1]==['ite']:
            temp=[]
            count=0
            cond=None
            for x in expr_args(e):
                get_conditions(x,e_el,list_condition)
                if count==0:
                    cond=x
                elif count==1:
                    if x==e_el and cond is not None:
                        list_condition.append(cond) 
                elif count==2:
                    if x==e_el and cond is not None:
                            con=[]
                            con.append('not')
                            con.append(cond)
                            list_condition.append(cond) 
                count=count+1
        else:
        	for x in expr_args(e):
                    get_conditions(x,e_el,list_condition)       


def constructAndOrlist(e_array,operator):
	if len(e_array)>2:
                cond=[]
                cond.append(operator)
                cond.append(e_array[0])
                cond.append(constructAndOrlist(e_array[1:],operator))
                return cond
	if len(e_array)==2:
                cond=[]
                cond.append(operator)
                cond.append(e_array[0])
                cond.append(constructAndOrlist(e_array[1:],operator))
                return cond
	else:
		return e_array[0]


#
#Module to handle pointer 
#


def handlingPointer(statements):
    update_statements=[]
    for statement in statements:
            if type(statement) is c_ast.Decl:
                dimesnsion=0
                d_map={}
                flag_pointer=False
                type_name,dimesnsion,flag_pointer=getTypeNameDimension(statement,dimesnsion,flag_pointer)
                if flag_pointer==True:
                    getDimension4mMalloc(statement,d_map)
                    temp_program=type_name+' '+statement.name
                    for x in range(0, len(d_map.keys())):
                        if 'parameter'+str(x) in d_map.keys():
                            temp_program+='['+d_map['parameter'+str(x)]+']'
                    temp_program+=';'
                    parser = c_parser.CParser()
                    print ('@@@@@@@')
                    print(temp_program)
                    print ('@@@@@@@')
                    ast = parser.parse(temp_program)
                    update_statements.append(ast.ext[0])
                else:
                    update_statements.append(statement)
            else:
                update_statements.append(statement)
    return update_statements



def getTypeNameDimension(statement,dimesnsion,flag_pointer):
	if type(statement.type) is c_ast.PtrDecl:
		dimesnsion=dimesnsion+1;
		flag_pointer=True
		return getTypeNameDimension(statement.type,dimesnsion,flag_pointer)
	elif type(statement.type) is c_ast.ArrayDecl:
		dimesnsion=dimesnsion+1;
		return getTypeNameDimension(statement.type,dimesnsion,flag_pointer)
	else:
		if type(statement.type) is c_ast.TypeDecl:
			if type(statement.type.type) is c_ast.IdentifierType:
				if len(statement.type.type.names)>1:
					return statement.type.type.names[1],dimesnsion,flag_pointer
				else:
					return statement.type.type.names[0],dimesnsion,flag_pointer
				

def getDimension4mMalloc(statement,d_map):
	for child in statement.children():
		if type(child[1]) is c_ast.FuncCall:
			for param in child[1].args.exprs:
				extractDimesion(param,d_map)
		else:
			getDimension4mMalloc(child[1],d_map)


def extractDimesion(param,d_map):
	if type(param) is c_ast.BinaryOp:
		if type(param.left) is c_ast.ID and  type(param.right) is c_ast.UnaryOp:
			d_map['parameter'+str(len(d_map.keys()))]=param.left.name
		elif type(param.right) is c_ast.ID and  type(param.left) is c_ast.UnaryOp:
			d_map['parameter'+str(len(d_map.keys()))]=param.right.name
		elif type(param.left) is c_ast.ID and  type(param.right) is c_ast.BinaryOp:
			d_map['parameter'+str(len(d_map.keys()))]=param.left.name
		elif type(param.right) is c_ast.ID and  type(param.left) is c_ast.BinaryOp:
			d_map['parameter'+str(len(d_map.keys()))]=param.right.name
		elif type(param.right) is c_ast.BinaryOp and  type(param.left) is c_ast.BinaryOp:
			extractDimesion(param.right,d_map)
			extractDimesion(param.left,d_map)


def pointerToArray(statement):
    if type(statement) is c_ast.Decl:
            dimesnsion=0
            d_map={}
            flag_pointer=False
            type_name,dimesnsion,flag_pointer=getTypeNameDimension(statement,dimesnsion,flag_pointer)
            if flag_pointer==True:
                getDimension4mMalloc(statement,d_map)
                temp_program=type_name+' '+statement.name
                for x in range(0, len(d_map.keys())):
                    if 'parameter'+str(x) in d_map.keys():
                        temp_program+='['+d_map['parameter'+str(x)]+']'
                temp_program+=';'
                parser = c_parser.CParser()
                ast = parser.parse(temp_program)
                return ast.ext[0]
            else:
                return statement
  			



def arrangeEmptyStatement(statements):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.If:
            stmt=arrangeEmptyStatementIf(statement)
            if stmt is not None:
            	update_statements.append(stmt)
        elif type(statement) is c_ast.While:
            if type(statement.stmt) is c_ast.EmptyStatement:
                update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=[])))
            elif statement.stmt.block_items is not None:
                stmt=arrangeEmptyStatement(statement.stmt.block_items)
                if stmt is not None:
                    update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=stmt)))
                else:
                	update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=[])))
            else:
                update_statements.append(statement)
        else:
            update_statements.append(statement)
    return update_statements
           

    


def arrangeEmptyStatementIf(statement):
    new_iftrue=None
    new_iffalse=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.EmptyStatement:
            if type(statement.iffalse) is c_ast.Compound:
                return c_ast.If(cond=c_ast.UnaryOp(op='!', expr=statement.cond), iftrue=statement.iffalse, iffalse=None)
            else:
                return c_ast.If(cond=c_ast.UnaryOp(op='!', expr=statement.cond), iftrue=statement.iffalse, iffalse=None)
        elif type(statement.iftrue) is c_ast.Compound:
            if statement.iftrue.block_items is not None:
                new_block_items=arrangeEmptyStatement(statement.iftrue.block_items)
                new_iftrue=c_ast.Compound(block_items=new_block_items)
            else:
                new_iftrue=statement.iftrue
        else:
            new_iftrue=statement.iftrue
            
        if type(statement.iffalse) is c_ast.Compound:
            if statement.iffalse.block_items is not None:
                new_block_items=arrangeEmptyStatement(statement.iffalse.block_items)
                new_iffalse=c_ast.Compound(block_items=new_block_items)
            else:
                new_iffalse=statement.iffalse
        elif type(statement.iffalse) is c_ast.If:
            new_iffalse=arrangeEmptyStatementIf(statement.iffalse)
        else:
            new_iffalse=statement.iffalse
            
    if new_iftrue is not None and new_iffalse is None:
        return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=None)
    elif new_iftrue is not None and new_iffalse is not None:
        return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
    elif new_iffalse is not None and type(new_iffalse) is c_ast.Compound:
        return c_ast.If(cond=c_ast.UnaryOp(op='!', expr=statement.cond), iftrue=new_iffalse, iffalse=None)
    elif new_iffalse is not None and type(new_iffalse) is c_ast.If:
        return new_iffalse
    else:
        return None







#filename='gototest.c'

def remove_empty_statement(filename):
    content=None
    with open(filename) as f:
        content = f.read()
    content=content.replace('\r','')
    text = r""" """+content
    parser = c_parser.CParser()
    ast = parser.parse(text)
    #print ast.show()
    function_decl = ast.ext[0].decl
    function_param = function_decl
    function_body = ast.ext[0].body
    statements=function_body.block_items
    
    statements=programTransformation(function_body)
    
    
    body_comp = c_ast.Compound(block_items=statements)
    generator = c_generator.CGenerator()   
    print(generator.visit(body_comp))

    


	
	
	
	
def removeMultipleLabel(statements,label,labelMap):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Goto:
                        if statement.name==label:
                        	new_label=label+str(len(labelMap.keys())+1)
                        	labelMap[new_label]=new_label
                        	update_statements.append(c_ast.Goto(name=new_label)) 
                        else:
                        	update_statements.append(statement) 
        elif type(statement) is c_ast.If:
            update_statements.append(removeMultipleLabelIf(statement,label,labelMap))
        elif type(statement) is c_ast.While:
            if statement.stmt.block_items is not None:
                update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=removeMultipleLabel(statement.stmt.block_items,label,labelMap))))
            elif type(statement.stmt) is c_ast.Goto:
                if statement.stmt.name==label:
                        new_label=label+str(len(labelMap.keys())+1)
                        labelMap[new_label]=new_label
                        new_block=[]
                        new_block.append(c_ast.Goto(name=new_label))
                        update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=new_block)))
                else:
                        new_block=[]
                        new_block.append(statement.stmt)
                        update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=new_block)))
            else:
                update_statements.append(statement)	
		                	
        else:
                	update_statements.append(statement)
        return update_statements




def removeMultipleLabelIf(statement,label,labelMap):
    new_iftrue=None
    new_iffalse=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Goto:
            if statement.iftrue.name==label:
                new_label=label+str(len(labelMap.keys())+1)
                labelMap[new_label]=new_label
                new_iftrue=c_ast.Goto(name=new_label)
            else:
                new_iftrue=statement.iftrue
        elif type(statement.iftrue) is c_ast.Compound:
            if statement.iftrue.block_items is not None:
                new_block_items=removeMultipleLabel(statement.iftrue.block_items,label,labelMap)
                new_iftrue=c_ast.Compound(block_items=new_block_items)
            else:
                new_iftrue=statement.iftrue
        else:
            new_iftrue=statement.iftrue
       
       
        if type(statement.iffalse) is c_ast.Goto:
            if statement.iffalse.name==label:
                new_label=label+str(len(labelMap.keys())+1)
                labelMap[new_label]=new_label
                new_iffalse=c_ast.Goto(name=new_label)
            else:
                new_iffalse=statement.iffalse
        elif type(statement.iffalse) is c_ast.Compound:
            if statement.iffalse.block_items is not None:
                new_block_items=removeMultipleLabel(statement.iffalse.block_items,label,labelMap)
                new_iffalse=c_ast.Compound(block_items=new_block_items)
            else:
                new_iffalse=statement.iffalse
    elif type(statement.iffalse) is c_ast.If:
        new_iffalse=removeMultipleLabelIf(statement.iffalse,label,labelMap)
    else:
            new_iffalse=statement.iffalse
        	
    return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)


    



def addMultipleLabel(statements,label,labelMap):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Label:
                        if statement.name==label:
                        	for item in labelMap.keys():
                        		update_statements.append(c_ast.Label(name=item, stmt=None))
                        	if statement.stmt is not None:
                        		update_statements.append(statement.stmt)
                        else:
                        	update_statements.append(statement) 
        elif type(statement) is c_ast.If:
            update_statements.append(addMultipleLabelIf(statement,label,labelMap))
        elif type(statement) is c_ast.While:
            if statement.stmt.block_items is not None:
                update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=addMultipleLabel(statement.stmt.block_items,label,labelMap))))
            elif type(statement.stmt) is c_ast.Goto:
                if statement.stmt.name==label:
                    new_block=[]
                    for item in labelMap.keys():
                        new_block.append(c_ast.Label(name=item, stmt=None))
                    if statement.stmt is not None:
                        new_block.append(statement.stmt)
                        update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=new_block)))
                else:
                        new_block=[]
                        new_block.append(statement.stmt)
                        update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=new_block)))
            else:
                update_statements.append(statement)	
		                	
        else:
            update_statements.append(statement)
        return update_statements




def addMultipleLabelIf(statement,label,labelMap):
    new_iftrue=None
    new_iffalse=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Label:
            if statement.iftrue.name==label:
                new_block=[]
                for item in labelMap.keys():
                    new_block.append(c_ast.Label(name=item, stmt=None))
                if statement.iftrue.stmt is not None:
                    new_block.append(statement.stmt)
                new_iftrue=c_ast.Compound(block_items=new_block)
            else:
                new_iftrue=statement.iftrue
        elif type(statement.iftrue) is c_ast.Compound:
            if statement.iftrue.block_items is not None:
                new_block_items=addMultipleLabel(statement.iftrue.block_items,label,labelMap)
                new_iftrue=c_ast.Compound(block_items=new_block_items)
            else:
                new_iftrue=statement.iftrue
        else:
            new_iftrue=statement.iftrue
       
       
        if type(statement.iffalse) is c_ast.Label:
            if statement.iffalse.name==label:
                new_block=[]
                for item in labelMap.keys():
                    new_block.append(c_ast.Label(name=item, stmt=None))
                if statement.iffalse.stmt is not None:
                    new_block.append(statement.stmt)
                new_iffalse=c_ast.Compound(block_items=new_block)
            else:
                new_iffalse=statement.iffalse
        elif type(statement.iffalse) is c_ast.Compound:
            if statement.iffalse.block_items is not None:
                new_block_items=addMultipleLabel(statement.iffalse.block_items,label,labelMap)
                new_iffalse=c_ast.Compound(block_items=new_block_items)
            else:
                new_iffalse=statement.iffalse
        elif type(statement.iffalse) is c_ast.If:
            new_iffalse=addMultipleLabelIf(statement.iffalse,label,labelMap)
        else:
            new_iffalse=statement.iffalse
        	
    return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)







def removeOrphanLabel(statements,label):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Label:
            if statement.name!=label:
                update_statements.append(statement) 
        elif type(statement) is c_ast.If:
            update_statements.append(removeOrphanLabelIf(statement,label))
        elif type(statement) is c_ast.While:
                    if statement.stmt.block_items is not None:
                        update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=removeOrphanLabel(statement.stmt.block_items,label))))
                    elif type(statement.stmt) is c_ast.Goto:
                        if statement.stmt.name!=label:
                            new_block=[]
                            update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=new_block)))
                        else:
                            new_block=[]
                            new_block.append(statement.stmt)
                            update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=new_block)))
                    else:
                        	update_statements.append(statement)	
		                	
        else:
            update_statements.append(statement)
    return update_statements




def removeOrphanLabelIf(statement,label):
    new_iftrue=None
    new_iffalse=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Label:
            if statement.iftrue.name==label:
                new_block=[]
                if statement.iftrue.stmt is not None:
                    new_block.append(statement.stmt)
                new_iftrue=c_ast.Compound(block_items=new_block)
            else:
                new_iftrue=statement.iftrue
        elif type(statement.iftrue) is c_ast.Compound:
            if statement.iftrue.block_items is not None:
                new_block_items=removeOrphanLabel(statement.iftrue.block_items,label)
                new_iftrue=c_ast.Compound(block_items=new_block_items)
            else:
                new_iftrue=statement.iftrue
        else:
            new_iftrue=statement.iftrue
       
       
        if type(statement.iffalse) is c_ast.Label:
            if statement.iffalse.name==label:
                new_block=[]
                if statement.iffalse.stmt is not None:
                    new_block.append(statement.stmt)
                new_iffalse=c_ast.Compound(block_items=new_block)
            else:
                new_iffalse=statement.iffalse
        elif type(statement.iffalse) is c_ast.Compound:
            if statement.iffalse.block_items is not None:
                new_block_items=removeOrphanLabel(statement.iffalse.block_items,label)
                new_iffalse=c_ast.Compound(block_items=new_block_items)
            else:
                new_iffalse=statement.iffalse
        elif type(statement.iffalse) is c_ast.If:
            new_iffalse=removeOrphanLabelIf(statement.iffalse,label)
        else:
        	new_iffalse=statement.iffalse
        	
    return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
    
   
 
dummyCount=0
    
def functionToAssignment(statements,functionMap):
    global dummyCount
    update_statements=[]
    for statement in statements:
        
        if type(statement) is c_ast.FuncCall:
            if  '__VERIFIER' not in statement.name.name:
                dummyCount=dummyCount+1
                update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name='_'+str(dummyCount)+'DUMMY'), rvalue=statement))
            else:
                update_statements.append(statement)
        elif type(statement) is c_ast.If:
            update_statements.append(functionToAssignmentIf(statement,functionMap))
        elif type(statement) is c_ast.While:
            if type(statement.stmt) is c_ast.Compound:
                update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=functionToAssignment(statement.stmt.block_items,functionMap))))
            else:
                if statement.stmt is not None:
                    if type(statement) is c_ast.EmptyStatement:
                        new_block=[]
                        update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=new_block)))	
                    else:
                        new_block=[]
                        new_block.append(statement.stmt)
                        update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=functionToAssignment(new_block,functionMap))))
                else:
                    update_statements.append(statement)
        else:
            update_statements.append(statement)
    return update_statements
                	
                	
                	
def functionToAssignmentIf(statement,functionMap):
      new_iftrue=None
      new_iffalse=None
      global dummyCount
      if type(statement) is c_ast.If:
          if type(statement.iftrue) is c_ast.Compound:
                new_block_items=functionToAssignment(statement.iftrue.block_items,functionMap)
                new_iftrue=c_ast.Compound(block_items=new_block_items)
          elif type(statement.iftrue) is c_ast.FuncCall:
            if  '__VERIFIER' not in statement.iftrue.name.name:
                dummyCount=dummyCount+1
                new_iftrue=c_ast.Assignment(op='=',lvalue=c_ast.ID(name='_'+str(dummyCount)+'DUMMY'), rvalue=statement.iftrue)
            else:
                new_iftrue=statement.iftrue
          else:
               new_iftrue=statement.iftrue
              
          if type(statement.iffalse) is c_ast.Compound:
              if statement.iffalse.block_items is not None:
                  new_block_items=functionToAssignment(statement.iffalse.block_items,functionMap)
                  new_iffalse=c_ast.Compound(block_items=new_block_items)
              else:
                  new_iffalse=statement.iffalse
          elif type(statement.iffalse) is c_ast.FuncCall:
            if  '__VERIFIER' not in statement.iffalse.name.name:
                dummyCount=dummyCount+1
                new_iffalse=c_ast.Assignment(op='=',lvalue=c_ast.ID(name='_'+str(dummyCount)+'DUMMY'), rvalue=statement.iffalse)
            else:
                new_iffalse=statement.iffalse
          elif type(statement.iffalse) is c_ast.If:
              new_iffalse=functionToAssignmentIf(statement.iffalse,functionMap)
          else:
              new_iffalse=statement.iffalse
      return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
      
      


def getDummyFunction(f,o,a,cm):
	new_o={}
	for eq in o.keys():
		if o[eq][0]=='e':
			lefthandstmt=expr2string1(o[eq][1])
			if 'DUMMY' in lefthandstmt:
				new_eq=[]
				new_eq.append('s0')
				new_eq.append(o[eq][2])
				new_o[eq]=new_eq
			else:
				new_o[eq]=o[eq]
		else:
			new_o[eq]=o[eq]
	#return f,new_o,a,cm
	return f,o,a,cm


#def update__VERIFIER_nondet(f,o,a,cm):
#    for eq in a:
#        if eq[0]=='i1':
#            var_cstr_map={}
#            lhs=expr2z3(eq[3],var_cstr_map)
#            eq[4]=update__VERIFIER_nondet_stmt(eq[4],var_cstr_map)
#    return f,o,a,cm




def update__VERIFIER_nondet_stmt(e,var_map):
    args=expr_args(e)
    if '__VERIFIER_nondet' in e[0] and len(args)==0:
        if e[0] in var_map.keys():
            VC=var_map[e[0]]
            VC=VC+1
            key=e[0]
            var_map[key]=VC
            e[0] = e[0]+str(VC)
            return e
        else:
            key=e[0]
            var_map[key]=2
            e[0] = e[0]+str(2)
            return e
    else:
        return e[:1]+list(update__VERIFIER_nondet_stmt(x,var_map) for x in expr_args(e))




#Get all typedefination

typedef_map={}

def getAllTypeDef(ast):
	global typedef_map
	typedef_map={}
	generator = c_generator.CGenerator()
	for element in ast.ext:
		if type(element) is c_ast.Typedef: 
			if type(element.type.type) is c_ast.Struct:
				program_temp="struct "+ast.ext[0].type.type.name+";"
				temp_ast = parser.parse(program_temp)
				typedef_map[element.name]=generator.visit(temp_ast.ext[0])
			else:
				typedef_map[element.name]=generator.visit(element.type)	
				
				
				
				
				
def updateTypeDef(statement):
    global typedef_map
    parser = c_parser.CParser()
    pointer=None
    array=None
    if type(statement) is c_ast.Decl:
        if type(statement.type) is c_ast.PtrDecl:
            degree=0
            type_stmt,degree,structType=getArrayDetails(statement,degree)
    			#if degree==1:
    			#	if type_stmt in typedef_map.keys():
    			#		type_stmt=typedef_map[type_stmt]
    			#	program_temp=type_stmt+' '+ statement.name
    			#	pointer=statement.name
    			#else:
    			#    	if type_stmt in typedef_map.keys():
			#    		type_stmt=typedef_map[type_stmt]
			#    	program_temp=type_stmt+' '+ statement.name
			#    	for x in range(0,degree):
    			#		program_temp+='[]'
    			#	pointer=statement.name
    			# commented on 16/11/2016
            if type_stmt in typedef_map.keys():
                type_stmt=typedef_map[type_stmt]
            program_temp=type_stmt+' '+ statement.name
            for x in range(0,degree):
                program_temp+='[]'
            pointer=statement.name
            program_temp+=';'
            temp_ast = parser.parse(program_temp)
            return temp_ast.ext[0],pointer,array
        elif type(statement.type) is c_ast.ArrayDecl:
            degree=0
            dimensionmap={}
            type_stmt,degree,structType=getArrayDetails(statement,degree,dimensionmap)
            if type_stmt in typedef_map.keys():
                type_stmt=typedef_map[type_stmt]
            program_temp=type_stmt+' '+statement.name
            for x in range(0,degree):
                program_temp+='[]'
            program_temp+=';'
            array=statement.name
            temp_ast = parser.parse(program_temp)
    			#return temp_ast.ext[0],pointer,array
            return statement,pointer,array
        else:
            type_stmt= statement.type.type.names[0]
            if type_stmt in typedef_map.keys():
                type_stmt=typedef_map[type_stmt]
            program_temp=type_stmt+' '+ statement.name
            generator = c_generator.CGenerator()
            if statement.init is not None:
                value=generator.visit(statement.init)
                if value is not None:
                    program_temp+='='+value
            program_temp+=';'
            temp_ast = parser.parse(program_temp)
            return temp_ast.ext[0],pointer,array
    return None,pointer,array


def pointerHandlingParameter(ast):

    if type(ast) is c_ast.FuncDef:
        pointer_list=[]
        array_list=[]
        new_stmts=[]
        new_parameters=''
        generator = c_generator.CGenerator()
        parser = c_parser.CParser()
        if ast.decl.type.args is not None:
            parameters=ast.decl.type.args.params
            if parameters is not None:
                for parameter in parameters:
                    if new_parameters=='':
                        type_decl,pointer,array=updateTypeDef(parameter)
                        if pointer is not None:
                            pointer_list.append(pointer)
                        if array is not None:
                            array_list.append(array)
                        new_parameters=generator.visit(type_decl)
                    else:
                        type_decl,pointer,array=updateTypeDef(parameter)
                        if pointer is not None:
                            pointer_list.append(pointer)
                        if array is not None:
                            array_list.append(array)
                        new_parameters+=','+generator.visit(type_decl)
        return_type=generator.visit(ast.decl.type.type)
        function_name=ast.decl.name
        new_fun=return_type+' '+ function_name+'('+ new_parameters +'){}'
        new_fun=parser.parse(new_fun)
        return new_fun.ext[0].decl,pointer_list,array_list
    else:
        return None,[],[]


def pointerHandlingDecl(function_body,pointer_list,array_list):
	update_statements=[]
	statements=function_body.block_items
	for statement in statements:
		if type(statement) is c_ast.Decl:
			new_statement,pointer,array=updateTypeDef(statement)
			new_stmt=None
			if pointer is not None:
				if statement.init is not None:
					if type(statement.init) is c_ast.InitList:
						new_statement=None
						new_stmt=None
					else:
						new_stmt=c_ast.Assignment(op='=', lvalue=c_ast.ID(name=pointer), rvalue=ref2function(statement.init))
				pointer_list.append(pointer)
			if array is not None:
				array_list.append(array)
			if new_statement is not None:
				update_statements.append(new_statement)
				if new_stmt is not None:
					update_statements.append(new_stmt)
			else:
				update_statements.append(statement)
		else:
			update_statements.append(statement)
	fun_body=c_ast.Compound(block_items=update_statements)
	return fun_body
	




def pointerHandling(statements,pointer_list,array_list):
	update_statements=[]
	for statement in statements:
		if type(statement) is c_ast.Decl:
			new_statement,pointer,array=updateTypeDef(statement)
			if pointer is not None:
				pointer_list.append(pointer)
			if array is not None:
				array_list.append(array)
			if new_statement is not None:
				update_statements.append(new_statement)
			else:
				update_statements.append(statement)
		elif type(statement) is c_ast.If:
			update_statements.append(pointerHandlingIf(statement,pointer_list,array_list))
		elif type(statement) is c_ast.While:
			if statement.stmt.block_items is not None:
                		update_statements.append(c_ast.While(cond=statement.cond,stmt=c_ast.Compound(block_items=pointerHandling(statement.stmt.block_items,pointer_list,array_list))))
		elif type(statement) is c_ast.Assignment:
			update_statements.append(c_ast.Assignment(op=statement.op,lvalue=defref2function(statement.lvalue,pointer_list,array_list),rvalue=defref2function(statement.rvalue,pointer_list,array_list)))
		else:
			update_statements.append(statement)
	return update_statements
	


	
def pointerHandlingIf(statement,pointer_list,array_list):
    new_iftrue=None
    new_iffalse=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Assignment:
        	new_iftrue=c_ast.Assignment(op=statement.iftrue.op,lvalue=defref2function(statement.iftrue.lvalue,pointer_list,array_list),rvalue=defref2function(statement.iftrue.rvalue,pointer_list,array_list))
        elif type(statement.iftrue) is c_ast.Compound:
            if statement.iftrue.block_items is not None:
                new_block_items=pointerHandling(statement.iftrue.block_items,pointer_list,array_list)
                new_iftrue=c_ast.Compound(block_items=new_block_items)
            else:
                new_iftrue=statement.iftrue
        else:
            new_iftrue=statement.iftrue
       
       
        if type(statement.iffalse) is c_ast.Assignment:
            new_iftrue=c_ast.Assignment(op=statement.iffalse.op,lvalue=defref2function(statement.iffalse.lvalue,pointer_list,array_list),rvalue=defref2function(statement.iffalse.rvalue,pointer_list,array_list))
        elif type(statement.iffalse) is c_ast.Compound:
            if statement.iffalse.block_items is not None:
                new_block_items=pointerHandling(statement.iffalse.block_items,pointer_list,array_list)
                new_iffalse=c_ast.Compound(block_items=new_block_items)
            else:
                new_iffalse=statement.iffalse
        elif type(statement.iffalse) is c_ast.If:
            new_iffalse=pointerHandlingIf(statement.iffalse,pointer_list,array_list)
        else:
        	new_iffalse=statement.iffalse
        	
    return c_ast.If(cond=statement.cond, iftrue=new_iftrue, iffalse=new_iffalse)
    
    
#def defref2function(statement,pointer_list,array_list):
#	if type(statement) is c_ast.UnaryOp:
#		parameter=[]
#		if statement.op=='*' and statement.expr.name in pointer_list:
#			parameter.append(statement.expr)
#			return c_ast.FuncCall(name=c_ast.ID(name='_data'), args=c_ast.ExprList(exprs=parameter))
#		elif statement.op=='*' and statement.expr.name in array_list:
#
#			return c_ast.ArrayRef(name=statement.expr, subscript=c_ast.Constant(type='int', value='0'))
#			#return c_ast.FuncCall(name=c_ast.ID(name='_data'), args=c_ast.ExprList(exprs=parameter))
#		elif statement.op=='&' and statement.expr.name in pointer_list:
#			parameter.append(statement.expr)
#			return c_ast.FuncCall(name=c_ast.ID(name='_address'), args=c_ast.ExprList(exprs=parameter))
#		else:
#			return c_ast.UnaryOp(op=statement.op, expr=defref2function(statement.expr,pointer_list,array_list))
#	elif type(statement) is c_ast.BinaryOp:
#		return c_ast.BinaryOp(op=statement.op,left=defref2function(statement.left,pointer_list,array_list),right=defref2function(statement.right,pointer_list,array_list))
#	else:
#		return statement





def defref2function(statement,pointer_list,array_list):
	if type(statement) is c_ast.UnaryOp:
		parameter=[]
		if statement.op=='*':
			stmt=defref2array(statement,pointer_list,array_list)
			if stmt is not None:
				return stmt
			else:
				return statement
		elif statement.op=='&' and statement.expr.name in pointer_list:
			parameter.append(statement.expr)
			return c_ast.FuncCall(name=c_ast.ID(name='_address'), args=c_ast.ExprList(exprs=parameter))
		else:
			return c_ast.UnaryOp(op=statement.op, expr=defref2function(statement.expr,pointer_list,array_list))
	elif type(statement) is c_ast.BinaryOp:
		return c_ast.BinaryOp(op=statement.op,left=defref2function(statement.left,pointer_list,array_list),right=defref2function(statement.right,pointer_list,array_list))
	else:
		return statement





		
		
def ref2function(statement):
	if type(statement) is c_ast.UnaryOp:
		parameter=[]
		if statement.op=='&':
			parameter.append(statement.expr)
			return c_ast.FuncCall(name=c_ast.ID(name='_address'), args=c_ast.ExprList(exprs=parameter))
		else:
			return c_ast.UnaryOp(op=statement.op, expr=ref2function(statement.expr))
	elif type(statement) is c_ast.BinaryOp:
		return c_ast.BinaryOp(op=statement.op,left=ref2function(statement.left),right=ref2function(statement.right))
	else:
		return statement


def defref2array(statement,pointer_list,array_list):
    if statement.op=='*' and type(statement.expr) is c_ast.UnaryOp :
        stmt=defref2array(statement.expr,pointer_list,array_list)
        if stmt is not None:
            return c_ast.ArrayRef(name=stmt, subscript=c_ast.Constant(type='int', value='0'))
        else:
            return None
    elif statement.op=='*' and type(statement.expr) is c_ast.BinaryOp :
            if type(statement.expr.left) is c_ast.ID and type(statement.expr.right) is c_ast.UnaryOp:
                stmt=defref2array(statement.expr.right,pointer_list,array_list)
                if stmt is not None:
                    return c_ast.ArrayRef(name=stmt, subscript=statement.expr.left)
                else:
                    return None
            elif type(statement.expr.right) is c_ast.ID and type(statement.expr.left) is c_ast.UnaryOp:
                stmt=defref2array(statement.expr.left,pointer_list,array_list)
                if stmt is not None:
                    return c_ast.ArrayRef(name=stmt, subscript=statement.expr.right)
                else:
                    return None
            elif type(statement.expr.left) is c_ast.Constant and type(statement.expr.right) is c_ast.UnaryOp:
                stmt=defref2array(statement.expr.right,pointer_list,array_list)
                if stmt is not None:
                    return c_ast.ArrayRef(name=stmt, subscript=statement.expr.left)
                else:
                    return None
            elif type(statement.expr.right) is c_ast.Constant and type(statement.expr.left) is c_ast.UnaryOp:
                stmt=defref2array(statement.expr.left,pointer_list,array_list)
                if stmt is not None:
                    return c_ast.ArrayRef(name=stmt, subscript=statement.expr.right)
                else:
                    return None
            elif type(statement.expr.left) is c_ast.ID and type(statement.expr.right) is c_ast.ID and statement.expr.right.name in pointer_list:
                return c_ast.ArrayRef(name=statement.expr.right, subscript=statement.expr.left)
            elif type(statement.expr.right) is c_ast.ID and type(statement.expr.left) is c_ast.ID and statement.expr.left.name in pointer_list:
                return c_ast.ArrayRef(name=statement.expr.left, subscript=statement.expr.right)
            elif type(statement.expr.left) is c_ast.ID and type(statement.expr.right) is c_ast.ID and statement.expr.right.name in array_list:
                return c_ast.ArrayRef(name=statement.expr.right, subscript=statement.expr.left)
            elif type(statement.expr.right) is c_ast.ID and type(statement.expr.left) is c_ast.ID and statement.expr.left.name in array_list:
                return c_ast.ArrayRef(name=statement.expr.left, subscript=statement.expr.right)
            #if type(statement.expr.left) is c_ast.ID and statement.expr.left.name in pointer_list:
             #   return c_ast.ArrayRef(name=stmt, subscript=statement.expr.right)
            #elif type(statement.expr.left) is c_ast.ID and statement.expr.left.name in array_list:
             #   return c_ast.ArrayRef(name=stmt, subscript=statement.expr.right)
            #if type(statement.expr.right) is c_ast.ID and statement.expr.right.name in pointer_list:
             #   return c_ast.ArrayRef(name=stmt, subscript=statement.expr.left)
            #elif type(statement.expr.right) is c_ast.ID and statement.expr.right.name in array_list:
             #   return c_ast.ArrayRef(name=stmt, subscript=statement.expr.left)
    elif statement.op=='*' and statement.expr.name in pointer_list:
        return c_ast.ArrayRef(name=statement.expr, subscript=c_ast.Constant(type='int', value='0'))
    elif statement.op=='*' and statement.expr.name in array_list:
        return c_ast.ArrayRef(name=statement.expr, subscript=c_ast.Constant(type='int', value='0'))
	
    else:
        return None



def change_var_name(statements):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Decl:
            if type(statement.type) is c_ast.ArrayDecl:
                                if checkingArrayName(statement.type)==True:
                                    statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=renameArrayName(statement.type), init=statement.init, bitsize=statement.bitsize)
                                statement.type.dim=change_var_name_stmt(statement.type.dim)
            else:
                if type(statement.type) is not c_ast.PtrDecl:
                    if is_number(statement.type.declname[-1])==True:
                        statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.TypeDecl(declname=statement.type.declname+'_var', quals=statement.type.quals, type=statement.type.type), init=statement.init, bitsize=statement.bitsize)
                    elif statement.type.declname in ['S','Q','N','in','is','limit']:
                        statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.TypeDecl(declname=statement.type.declname+'_var', quals=statement.type.quals, type=statement.type.type), init=statement.init, bitsize=statement.bitsize)
            update_statements.append(statement)
        elif type(statement) is c_ast.If:
            update_statements.append(change_var_nameIf(statement))
        elif type(statement) is c_ast.While:
                        if type(statement.stmt) is c_ast.Assignment:
                                new_block=[]
                                new_block.append(statement.stmt)
                                update_statements.append(c_ast.While(cond=change_var_name_stmt(statement.cond),stmt=c_ast.Compound(block_items=change_var_name(new_block))))
                        elif type(statement.stmt) is c_ast.UnaryOp:
                                new_block=[]
                                new_block.append(statement.stmt)
                                update_statements.append(c_ast.While(cond=change_var_name_stmt(statement.cond),stmt=c_ast.Compound(block_items=change_var_name(new_block))))
                        elif statement.stmt.block_items is not None:
                                update_statements.append(c_ast.While(cond=change_var_name_stmt(statement.cond),stmt=c_ast.Compound(block_items=change_var_name(statement.stmt.block_items))))	
                        else:
                                update_statements.append(c_ast.While(cond=change_var_name_stmt(statement.cond),stmt=c_ast.Compound(block_items=statement.stmt.block_items)))	
        elif type(statement) is c_ast.Assignment:
            update_statements.append(c_ast.Assignment(op=statement.op,lvalue=change_var_name_stmt(statement.lvalue),rvalue=change_var_name_stmt(statement.rvalue)))
        elif type(statement) is c_ast.Return:
                    statement.expr=change_var_name_stmt(statement.expr)
                    update_statements.append(statement)
                    #Return: [expr*]
        else:
            update_statements.append(statement)
    return update_statements
	


	
def change_var_nameIf(statement):
    new_iftrue=None
    new_iffalse=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Assignment:
        	new_iftrue=c_ast.Assignment(op=statement.iftrue.op,lvalue=change_var_name_stmt(statement.iftrue.lvalue),rvalue=change_var_name_stmt(statement.iftrue.rvalue))
        elif type(statement.iftrue) is c_ast.Compound:
            if statement.iftrue.block_items is not None:
                new_block_items=change_var_name(statement.iftrue.block_items)
                new_iftrue=c_ast.Compound(block_items=new_block_items)
            else:
                new_iftrue=statement.iftrue
        else:
            new_iftrue=statement.iftrue
       
       
        if type(statement.iffalse) is c_ast.Assignment:
            new_iffalse=c_ast.Assignment(op=statement.iffalse.op,lvalue=change_var_name_stmt(statement.iffalse.lvalue),rvalue=change_var_name_stmt(statement.iffalse.rvalue))
        elif type(statement.iffalse) is c_ast.Compound:
            if statement.iffalse.block_items is not None:
                new_block_items=change_var_name(statement.iffalse.block_items)
                new_iffalse=c_ast.Compound(block_items=new_block_items)
            else:
                new_iffalse=statement.iffalse
        elif type(statement.iffalse) is c_ast.If:
            new_iffalse=change_var_nameIf(statement.iffalse)
        else:
        	new_iffalse=statement.iffalse
        	
    return c_ast.If(cond= change_var_name_stmt(statement.cond), iftrue=new_iftrue, iffalse=new_iffalse)


def change_var_name_stmt(statement):
    if type(statement) is c_ast.BinaryOp:
        if type(statement.left) is c_ast.ID:
            if is_number(statement.left.name[-1])==True:
                stmt_left=c_ast.ID(name=statement.left.name+'_var')
            elif statement.left.name in ['S','Q','N','in','is','limit']:
                stmt_left=c_ast.ID(name=statement.left.name+'_var')
            else:
                stmt_left=change_var_name_stmt(statement.left)
        else:
            stmt_left=change_var_name_stmt(statement.left)
		
        if type(statement.right) is c_ast.ID:
            if is_number(statement.right.name[-1])==True:
                stmt_right=c_ast.ID(name=statement.right.name+'_var')
            elif statement.right.name in ['S','Q','N','in','is','limit']:
                stmt_right=c_ast.ID(name=statement.right.name+'_var')
            else:
                stmt_right=change_var_name_stmt(statement.right)
        else:
            stmt_right=change_var_name_stmt(statement.right)
        return c_ast.BinaryOp(op=statement.op, left=stmt_left, right=stmt_right)
    elif type(statement) is c_ast.UnaryOp:
        if type(statement.expr) is c_ast.ID:
            if is_number(statement.expr.name[-1])==True:
                stmt=c_ast.ID(name=statement.expr.name+'_var')
            elif statement.expr.name in ['S','Q','N','in','is','limit']:
                stmt=c_ast.ID(name=statement.expr.name+'_var')
            else:
                stmt=change_var_name_stmt(statement.expr)
        else:
            stmt=change_var_name_stmt(statement.expr)
        return c_ast.UnaryOp(op=statement.op, expr=stmt)
    elif type(statement) is c_ast.ID:
        if is_number(statement.name[-1])==True:
            return c_ast.ID(name=statement.name+'_var')
        elif statement.name in ['S','Q','N','in','is','limit']:
            return c_ast.ID(name=statement.name+'_var')
        else:
            return statement
    elif type(statement) is c_ast.FuncCall:
            if statement.args is not None:
                new_expr=[]
                for exp in statement.args.exprs:
                    new_expr.append(change_var_name_stmt(exp))
                return c_ast.FuncCall(name=statement.name,args=c_ast.ExprList(exprs=new_expr))
            else:
                return statement
	
    else:
        if type(statement) is c_ast.ArrayRef:
            return renameArrayName(statement)
                    #if checkingArrayName(statement)==True:
                    #    return renameArrayName(statement)
                    #else:
                    #    return statement
        elif type(statement) is c_ast.StructRef:
            return c_ast.StructRef(name=change_var_name_stmt(statement.name),type=change_var_name_stmt(statement.type),field=statement.field)
        else:
            return statement


def change_var_name_stmt1(statement,count,var_map,in_var_map,fun_count,all_var_int):
    if type(statement) is c_ast.BinaryOp:
        if type(statement.left) is c_ast.ID:
            if statement.left.name in var_map.keys() or statement.left.name in in_var_map.keys():
                                if statement.left.name in all_var_int:
                                    stmt_left=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.left.name)
                                else:
                                    stmt_left=statement.left
            else:
                stmt_left=statement.left
        else:
            stmt_left=change_var_name_stmt1(statement.left)
            
        if type(tatement.right) is c_ast.ID:
            if statement.right.name in var_map.keys() or statement.right.name in in_var_map.keys():
                                if statement.right.name in all_var_int:
                                    stmt_right=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.right.name)
                                else:
                                    stmt_right=statement.right
            else:
                stmt_right=statement.right
        else:
            stmt_right=change_var_name_stmt1(statement.right)
            
        return c_ast.BinaryOp(op=statement.op, left=stmt_left, right=stmt_right)
    elif type(statement) is c_ast.UnaryOp:
        if type(statement.expr) is c_ast.ID:
            if statement.expr.name in var_map.keys() or statement.expr.name in in_var_map.keys():
                    if statement.expr.name in all_var_int:
                        stmt=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.expr.name)
                    else:
                        stmt=statement.expr
            else:
                stmt=statement.expr
        else:
            stmt=change_var_name_stmt1(statement.expr)
        return c_ast.UnaryOp(op=statement.op, expr=stmt)
    elif type(statement) is c_ast.ID:
        if statement.name in var_map.keys() or statement.name in in_var_map.keys():
            if statement.name in all_var_int:
                    return c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.name)
            else:
                    return statement
        else:
            return statement
    elif type(statement) is c_ast.FuncCall:
            if statement.args is not None:
                new_expr=[]
                for exp in statement.args.exprs:
                    new_expr.append(change_var_name_stmt1(exp))
                return c_ast.FuncCall(name=statement.name,args=c_ast.ExprList(exprs=new_expr))
            else:
                return statement
    else:
        if type(statement) is c_ast.ArrayRef:
                    return renameArrayName1(statement)
                    #if checkingArrayName(statement)==True:
                    #    return renameArrayName(statement)
                    #else:
                    #    return statement
        else:
                    return statement









def change_var_name_decl(statement):
    if type(statement) is c_ast.Decl:
        if type(statement.type) is c_ast.ArrayDecl:
            if is_number(statement.name[-1])==True:
                statement.name=statement.name+'_var'
                renameArrayName(statement.type)
            elif statement.name in ['S','Q','N','in','is','limit']:
                statement.name=statement.name+'_var'
                renameArrayName(statement.type)
            else:
                statement.type.dim=change_var_name_stmt(statement.type.dim)
        else:
            if is_number(statement.type.declname[-1])==True:
                statement.name=statement.name+'_var' 
                statement.type=c_ast.TypeDecl(declname=statement.type.declname+'_var', quals=statement.type.quals, type=statement.type.type)
            elif statement.type.declname in ['S','Q','N','in','is','limit']:
                statement.name=statement.name+'_var'  
                statement.type=c_ast.TypeDecl(declname=statement.type.declname+'_var', quals=statement.type.quals, type=statement.type.type)
        return statement
    return statement









count__VERIFIER_nondet=0


def organize__VERIFIER_nondet(statements):
    global count__VERIFIER_nondet
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Decl:
            if type(statement.type) is c_ast.ArrayDecl:
                                update_statements.append(statement)
            else:
                                init_values=None
                                if statement.init is not None:
                                    init_values=copy.deepcopy(statement.init)
                                statement=c_ast.Decl(name=statement.name, quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.TypeDecl(declname=statement.type.declname, quals=statement.type.quals, type=statement.type.type), init=None, bitsize=statement.bitsize)
                                update_statements.append(statement)
                                if init_values is not None:
                                        update_statements.append(c_ast.Assignment(op='=',lvalue=c_ast.ID(name=statement.name),rvalue=organize__VERIFIER_nondet_stmt(init_values)))
        elif type(statement) is c_ast.If:
            update_statements.append(organize__VERIFIER_nondetIf(statement))
        elif type(statement) is c_ast.While:
            if statement.stmt.block_items is not None:
                update_statements.append(c_ast.While(cond=organize__VERIFIER_nondet_stmt(statement.cond),stmt=c_ast.Compound(block_items=organize__VERIFIER_nondet(statement.stmt.block_items))))	
            else:
                update_statements.append(c_ast.While(cond=organize__VERIFIER_nondet_stmt(statement.cond),stmt=c_ast.Compound(block_items=statement.stmt.block_items)))	
        elif type(statement) is c_ast.Assignment:
            update_statements.append(c_ast.Assignment(op=statement.op,lvalue=organize__VERIFIER_nondet_stmt(statement.lvalue),rvalue=organize__VERIFIER_nondet_stmt(statement.rvalue)))
        else:
            update_statements.append(statement)
    return update_statements
	


	
def organize__VERIFIER_nondetIf(statement):
    global count__VERIFIER_nondet
    new_iftrue=None
    new_iffalse=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Assignment:
        	new_iftrue=c_ast.Assignment(op=statement.iftrue.op,lvalue=organize__VERIFIER_nondet_stmt(statement.iftrue.lvalue),rvalue=organize__VERIFIER_nondet_stmt(statement.iftrue.rvalue))
        elif type(statement.iftrue) is c_ast.Compound:
            if statement.iftrue.block_items is not None:
                new_block_items=change_var_name(statement.iftrue.block_items)
                new_iftrue=c_ast.Compound(block_items=new_block_items)
            else:
                new_iftrue=statement.iftrue
        else:
            new_iftrue=statement.iftrue
       
       
        if type(statement.iffalse) is c_ast.Assignment:
            new_iftrue=c_ast.Assignment(op=statement.iffalse.op,lvalue=organize__VERIFIER_nondet_stmt(statement.iffalse.lvalue),rvalue=organize__VERIFIER_nondet_stmt(statement.iffalse.rvalue))
        elif type(statement.iffalse) is c_ast.Compound:
            if statement.iffalse.block_items is not None:
                new_block_items=change_var_name(statement.iffalse.block_items)
                new_iffalse=c_ast.Compound(block_items=new_block_items)
            else:
                new_iffalse=statement.iffalse
    elif type(statement.iffalse) is c_ast.If:
        new_iffalse=organize__VERIFIER_nondetIf(statement.iffalse)
    else:
        new_iffalse=statement.iffalse
        	
    return c_ast.If(cond= organize__VERIFIER_nondet_stmt(statement.cond), iftrue=new_iftrue, iffalse=new_iffalse)


def organize__VERIFIER_nondet_stmt(statement):
    global count__VERIFIER_nondet
    if type(statement) is c_ast.BinaryOp:
        if type(statement.left) is c_ast.ID:
            stmt_left=organize__VERIFIER_nondet_stmt(statement.left)
        else:
            stmt_left=organize__VERIFIER_nondet_stmt(statement.left)
		
        if type(statement.right) is c_ast.ID:
            stmt_right=organize__VERIFIER_nondet_stmt(statement.right)
        else:
            stmt_right=organize__VERIFIER_nondet_stmt(statement.right)
        return c_ast.BinaryOp(op=statement.op, left=stmt_left, right=stmt_right)
    elif type(statement) is c_ast.UnaryOp:
        if type(statement.expr) is c_ast.ID:
            stmt=organize__VERIFIER_nondet_stmt(statement.expr)
        else:
            stmt=organize__VERIFIER_nondet_stmt(statement.expr)
        return c_ast.UnaryOp(op=statement.op, expr=stmt)
    elif type(statement) is c_ast.ID:
        if '__VERIFIER_nondet' in statement.name:
            count__VERIFIER_nondet=count__VERIFIER_nondet+1
            return c_ast.ID(name=statement.name+str(count__VERIFIER_nondet))
        else:
            return statement
    elif type(statement) is c_ast.FuncCall:
        if '__VERIFIER_nondet' in statement.name.name:
            count__VERIFIER_nondet=count__VERIFIER_nondet+1
            statement.name=c_ast.ID(name=statement.name.name+str(count__VERIFIER_nondet))
        return statement
    else:
        return statement








#filename='veris.c_NetBSD-libc__loop_true-unreach-call_true-termination.c'
filename='sv-benchmarks/loops/trex04_true-unreach-call_false-termination1.i'
def changeTest(filename):
    content=None
    global new_variable
    with open(filename) as f:
        content = f.read()
    content=content.replace('\r','')
    text = r""" """+content
    parser = c_parser.CParser()
    ast = parser.parse(text)
    stmts=ast.ext[0].body.block_items
    statements=change_var_name(stmts)
    body=c_ast.Compound(block_items=statements)
    #body.show()
    generator = c_generator.CGenerator()
    print(generator.visit(body))
    
		

#Add External Variables


def addAllExtVariables(statements,externalvariables,localvarmap):
	update_statements=[]
	for var in externalvariables.keys():
		variable=externalvariables[var]
		temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=[variable.getVariableType()])), init=None, bitsize=None)
		update_statements.append(temp)
		localvarmap[var]=variable
		if variable.getInitialvalue() is not None:
			update_statements.append(c_ast.Assignment(op='=', lvalue=c_ast.ID(name=var), rvalue=c_ast.Constant(type=variable.getVariableType(), value=variable.getInitialvalue())))
	for element in statements:
		update_statements.append(element)
	return update_statements,localvarmap
	

def getWitness(filename,functionname,resultfunction):
	witnessXml=[]
	#witnessXml1='<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n'+'<graphml xmlns="http:\/\/graphml.graphdrawing.org\/xmlns" xmlns:xsi="http:\/\/www.w3.org\/2001\/XMLSchema-instance">'+'\t<key attr.name="isEntryNode" attr.type="boolean" for="node" id="entry">\n'+'\t\t<default>false<\/default>\n'+'\t<\/key>\n'+'\t<key attr.name="witness-type" attr.type="string" for="graph" id="witness-type"\/>\n'+'\t<key attr.name="sourcecodelang" attr.type="string" for="graph" id="sourcecodelang"\/>'+'\t<key attr.name="producer" attr.type="string" for="graph" id="producer"\/>\n'+'\t<key attr.name="specification" attr.type="string" for="graph" id="specification"\/>\n'+'\t<key attr.name="programFile" attr.type="string" for="graph" id="programfile"\/>\n'+'\t<key attr.name="programHash" attr.type="string" for="graph" id="programhash"\/>\n'+'\t<key attr.name="memoryModel" attr.type="string" for="graph" id="memorymodel"\/>\n'+'\t<key attr.name="architecture" attr.type="string" for="graph" id="architecture"\/>\n'+'\t<key attr.name="startline" attr.type="int" for="edge" id="startline"\/>\n'+'\t<key attr.name="assumption" attr.type="string" for="edge" id="assumption"\/>\n'+'\t<key attr.name="assumption.scope" attr.type="string" for="edge" id="assumption.scope"\/>\n'+'\t<key attr.name="assumption.resultfunction" attr.type="string" for="edge" id="assumption.resultfunction"\/>\n'+'\t<graph edgedefault="directed">\n'+'\t\t<data key="witness-type">violation_witness<\/data>\n'+'\t\t<data key="sourcecodelang">C<\/data>\n'+'\t\t<data key="producer">CPAchecker 1.6.1-svn<\/data>\n'+'\t\t<data key="specification">CHECK( init(main()), LTL(G ! call(__VERIFIER_assume)) )<\/data>\n'+'\t\t<data key="programfile">'+filename+'<\/data>\n'+'\t\t<data key="programhash">1776ed2413d170f227b69d8c79ba700d31db6f75<\/data>\n'+'\t\t<data key="memorymodel">precise<\/data>\n'+'\t\t<data key="memorymodel">precise<\/data>\n'+'\t\t<node id="entry">\n'+'\t\t\t<data key="entry">true<\/data>\n'+'\t\t</node>\n'+'\t\t<node id="error">\n'+'\t\t\t<data key="violation">true<\/data>\n'+'\t\t<\/node>\n'+'\t\t<edge source="entry" target="error">\n'+'\t\t\t<data key="startline">5<\/data>\n'+'\t\t\t<data key="assumption">\\result == 0<\/data>\n'
	#witnessXml1='<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n'+'<graphml xmlns="http:\/\/graphml.graphdrawing.org\/xmlns" xmlns:xsi="http:\/\/www.w3.org\/2001\/XMLSchema-instance">'+'\t<key attr.name="isEntryNode" attr.type="boolean" for="node" id="entry">\n'+'\t\t<default>false<\/default>\n'+'\t<\/key>\n'+'\t<key attr.name="witness-type" attr.type="string" for="graph" id="witness-type"\/>\n'+'\t<key attr.name="sourcecodelang" attr.type="string" for="graph" id="sourcecodelang"\/>'+'\t<key attr.name="producer" attr.type="string" for="graph" id="producer"\/>\n'+'\t<key attr.name="specification" attr.type="string" for="graph" id="specification"\/>\n'+'\t<key attr.name="programFile" attr.type="string" for="graph" id="programfile"\/>\n'+'\t<key attr.name="programHash" attr.type="string" for="graph" id="programhash"\/>\n'+'\t<key attr.name="memoryModel" attr.type="string" for="graph" id="memorymodel"\/>\n'+'\t<key attr.name="architecture" attr.type="string" for="graph" id="architecture"\/>\n'+'\t<key attr.name="startline" attr.type="int" for="edge" id="startline"\/>\n'+'\t<key attr.name="assumption" attr.type="string" for="edge" id="assumption"\/>\n'+'\t<key attr.name="assumption.scope" attr.type="string" for="edge" id="assumption.scope"\/>\n'+'\t<key attr.name="assumption.resultfunction" attr.type="string" for="edge" id="assumption.resultfunction"\/>\n'+'\t<graph edgedefault="directed">\n'+'\t\t<data key="witness-type">violation_witness<\/data>\n'+'\t\t<data key="sourcecodelang">C<\/data>\n'+'\t\t<data key="producer">CPAchecker 1.6.1-svn<\/data>\n'+'\t\t<data key="specification">CHECK( init(main()), LTL(G ! call(__VERIFIER_assume)) )<\/data>\n'+'\t\t<data key="programfile">'+filename+'<\/data>\n'+'\t\t<data key="programhash">1776ed2413d170f227b69d8c79ba700d31db6f75<\/data>\n'+'\t\t<data key="memorymodel">precise<\/data>\n'+'\t\t<data key="memorymodel">precise<\/data>\n'+'\t\t<node id="entry">\n'+'\t\t\t<data key="entry">true<\/data>\n'+'\t\t</node>\n'+'\t\t<node id="error">\n'+'\t\t\t<data key="violation">true<\/data>\n'+'\t\t<\/node>\n'+'\t\t<edge source="entry" target="error">\n'
	witnessXml1='<?xml version="1.0" encoding="UTF-8" standalone="no"?>'+'<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><key attr.name="isEntryNode" attr.type="boolean" for="node" id="entry"><default>false</default></key><key attr.name="isViolationNode" attr.type="boolean" for="node" id="violation"><default>false</default></key><key attr.name="witness-type" attr.type="string" for="graph" id="witness-type"/><key attr.name="sourcecodelang" attr.type="string" for="graph" id="sourcecodelang"/><key attr.name="producer" attr.type="string" for="graph" id="producer"/><key attr.name="specification" attr.type="string" for="graph" id="specification"/><key attr.name="programFile" attr.type="string" for="graph" id="programfile"/><key attr.name="programHash" attr.type="string" for="graph" id="programhash"/><key attr.name="memoryModel" attr.type="string" for="graph" id="memorymodel"/><key attr.name="architecture" attr.type="string" for="graph" id="architecture"/><key attr.name="startline" attr.type="int" for="edge" id="startline"/><key attr.name="assumption" attr.type="string" for="edge" id="assumption"/><key attr.name="assumption.scope" attr.type="string" for="edge" id="assumption.scope"/><key attr.name="assumption.resultfunction" attr.type="string" for="edge" id="assumption.resultfunction"/><graph edgedefault="directed"><data key="witness-type">violation_witness</data><data key="sourcecodelang">C</data><data key="producer">CPAchecker 1.6.1-svn</data><data key="specification">CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )</data><data key="programfile">'+filename+'</data><data key="programhash">1776ed2413d170f227b69d8c79ba700d31db6f75</data><data key="memorymodel">precise</data><data key="architecture">32bit</data><node id="entry"><data key="entry">true</data></node><node id="error"><data key="violation">true</data></node><edge source="entry" target="error">'
	witnessXml.append(witnessXml1)
	#witnessXml2='\t\t\t<data key="assumption.scope">'+functionname+'<\/data>\n'+'\t\t\t<data key="assumption.resultfunction">'+resultfunction+'<\/data>\n'+'\t\t</edge>\n'+'\t</graph>\n'+'</graphml>\n'
	witnessXml2='<data key="assumption.scope">'+functionname+'</data><data key="assumption.resultfunction">'+resultfunction+'</data></edge></graph></graphml>'
	witnessXml.append(witnessXml2)
	witnessXml.append(functionname)
	witnessXml.append(filename)
	return witnessXml
	
def checkingArrayName(statement):
    if type(statement) is c_ast.ArrayDecl:
        if type(statement.type) is c_ast.TypeDecl:
            if is_number(statement.type.declname[-1])==True:
                #statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.type.declname+'_var', quals=statement.type.type.quals, type=statement.type.type.type), dim=statement.type.dim, dim_quals=statement.type.dim_quals), init=statement.init, bitsize=statement.bitsize)
                return True
            elif statement.type.declname in ['S','Q','N','in','is']:
                #statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.type.declname+'_var', quals=statement.type.type.quals, type=statement.type.type.type), dim=statement.type.dim, dim_quals=statement.type.dim_quals), init=statement.init, bitsize=statement.bitsize)
                return True
            else:
                #if type(statement.dim) is c_ast.ID:
                #    if is_number(statement.dim.name[-1])==True:
                #        #statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.type.declname+'_var', quals=statement.type.type.quals, type=statement.type.type.type), dim=statement.type.dim, dim_quals=statement.type.dim_quals), init=statement.init, bitsize=statement.bitsize)
                #        return True
                #    elif statement.dim.name in ['S','Q','N','in','is']:
                #        #statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.type.declname+'_var', quals=statement.type.type.quals, type=statement.type.type.type), dim=statement.type.dim, dim_quals=statement.type.dim_quals), init=statement.init, bitsize=statement.bitsize)
                #        return True
                #    else:
                return False
        elif type(statement.type) is c_ast.ArrayDecl:
            return checkingArrayName(statement.type)
        else:
            return False
    elif type(statement) is c_ast.ArrayRef:
        if type(statement.name) is c_ast.ID:
            if is_number(statement.name.name[-1])==True:
                return True
            elif statement.name.name in ['S','Q','N','in','is']:
                return True
            else:
                return False
        elif type(statement.name) is c_ast.ArrayRef:
            return checkingArrayName(statement.name)
        else:
            return False





def checkingArrayIndexName(statement):
    if type(statement) is c_ast.ArrayDecl:
        if type(statement.type) is c_ast.TypeDecl:
            if is_number(statement.type.declname[-1])==True:
                #statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.type.declname+'_var', quals=statement.type.type.quals, type=statement.type.type.type), dim=statement.type.dim, dim_quals=statement.type.dim_quals), init=statement.init, bitsize=statement.bitsize)
                return True
            elif statement.type.declname in ['S','Q','N','in','is']:
                #statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.type.declname+'_var', quals=statement.type.type.quals, type=statement.type.type.type), dim=statement.type.dim, dim_quals=statement.type.dim_quals), init=statement.init, bitsize=statement.bitsize)
                return True
            else:
                if type(statement.dim) is c_ast.ID:
                    if is_number(statement.dim.name[-1])==True:
                        #statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.type.declname+'_var', quals=statement.type.type.quals, type=statement.type.type.type), dim=statement.type.dim, dim_quals=statement.type.dim_quals), init=statement.init, bitsize=statement.bitsize)
                        return True
                    elif statement.dim.name in ['S','Q','N','in','is']:
                        #statement=c_ast.Decl(name=statement.name+'_var', quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.type.declname+'_var', quals=statement.type.type.quals, type=statement.type.type.type), dim=statement.type.dim, dim_quals=statement.type.dim_quals), init=statement.init, bitsize=statement.bitsize)
                        return True
                    else:
                        return False
        elif type(statement.type) is c_ast.ArrayDecl:
            return checkingArrayIndexName(statement.type)
        else:
            return False
    elif type(statement) is c_ast.ArrayRef:
        if type(statement.name) is c_ast.ID:
            if type(statement.subscript) is c_ast.ID:
                if is_number(statement.subscript.name[-1])==True:
                    return True
                elif statement.subscript in ['S','Q','N','in','is']:
                    return True
                elif type(statement.subscript) is c_ast.BinaryOp:
                    if checkingArrayNameStmt(statement.subscript)==True:
                        return True
                elif type(statement.subscript) is c_ast.UnaryOp:
                    if checkingArrayNameStmt(statement.subscript.expr)==True:
                        return True
        elif type(statement.name) is c_ast.ArrayRef:
            return checkingArrayIndexName(statement.name)
        else:
            return False





def checkingArrayNameStmt(statement):
    if type(statement) is c_ast.BinaryOp:
        if checkingArrayNameStmt(statement.left)==True:
            return True
        if checkingArrayNameStmt(statement.right)==True:
            return True
    elif type(statement) is c_ast.UnaryOp:
        if checkingArrayNameStmt(statement.expr)==True:
            return True
    elif type(statement) is c_ast.ID:
        if is_number(statement.name[-1])==True:
            return True
        elif statement.name in ['S','Q','N','in','is']:
            return True
    else:
        return True


            
def renameArrayName(statement):
    if type(statement) is c_ast.ArrayDecl:
        if type(statement.type) is c_ast.TypeDecl:
            if is_number(statement.type.declname[-1])==True:
                statement=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.declname+'_var', quals=statement.type.quals, type=statement.type.type),dim=change_var_name_stmt(statement.dim), dim_quals=statement.dim_quals)
                return statement
            elif statement.type.declname in ['S','Q','N','in','is']:
                statement=c_ast.ArrayDecl(type=c_ast.TypeDecl(declname=statement.type.declname+'_var', quals=statement.type.quals, type=statement.type.type),dim=change_var_name_stmt(statement.dim), dim_quals=statement.dim_quals)
                return statement
            else:
                return statement
        elif type(statement.type) is c_ast.ArrayDecl:
            statement=c_ast.ArrayDecl(type=renameArrayName(statement.type),dim=change_var_name_stmt(statement.type.dim), dim_quals=statement.type.dim_quals)
            return statement
    elif type(statement) is c_ast.ArrayRef:
        if type(statement.name) is c_ast.ID:
            if is_number(statement.name.name[-1])==True:
                return c_ast.ArrayRef(name=c_ast.ID(name=statement.name.name+'_var'),subscript=change_var_name_stmt(statement.subscript))
            elif statement.name.name in ['S','Q','N','in','is']:
                return c_ast.ArrayRef(name=c_ast.ID(name=statement.name.name+'_var'),subscript=change_var_name_stmt(statement.subscript))
            else:
                return c_ast.ArrayRef(name=c_ast.ID(name=statement.name.name),subscript=change_var_name_stmt(statement.subscript))
        elif type(statement.name) is c_ast.ArrayRef:
            return c_ast.ArrayRef(name=renameArrayName(statement.name),subscript=change_var_name_stmt(statement.subscript))
        


def renameArrayName1(statement,count,var_map,in_var_map,fun_count,all_var_int):
    if type(statement) is c_ast.ArrayDecl:
        if type(statement.type) is c_ast.TypeDecl:
            if statement.name in var_map.keys() or statement.name in in_var_map.keys():
                return c_ast.Decl(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.name, quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=renameArrayName1(statement.type,count,var_map,in_var_map,fun_count,all_var_int), init=statement.init, bitsize=statement.bitsize)
            else:
                return c_ast.Decl(name=statement.name, quals=statement.quals, storage=statement.storage, funcspec=statement.funcspec, type=renameArrayName1(statement.type,count,var_map,in_var_map,fun_count,all_var_int), init=statement.init, bitsize=statement.bitsize)
        elif type(statement.type) is c_ast.ArrayDecl:
            statement=c_ast.ArrayDecl(type=renameArrayName1(statement.type,count,var_map,in_var_map,fun_count,all_var_int),dim=change_var_name_stmt1(statement.type.dim,count,var_map,in_var_map,fun_count,all_var_int), dim_quals=statement.type.dim_quals)
            return statement
    elif type(statement) is c_ast.ArrayRef:
        if type(statement.name) is c_ast.ID:
            if statement.name in var_map.keys() or statement.name in in_var_map.keys():
                return c_ast.ArrayRef(name=c_ast.ID(name='f'+str(fun_count)+'_'+str(count)+'_'+statement.name.name),subscript=change_var_name_stmt1(statement.subscript,count,var_map,in_var_map,fun_count,all_var_int))
            else:
                return c_ast.ArrayRef(name=statement.name,subscript=change_var_name_stmt1(statement.subscript,count,var_map,in_var_map,fun_count,all_var_int))
        elif type(statement.name) is c_ast.ArrayRef:
            return c_ast.ArrayRef(name=renameArrayName1(statement.name,count,var_map,in_var_map,fun_count,all_var_int),subscript=change_var_name_stmt1(statement.subscript,count,var_map,in_var_map,fun_count,all_var_int))

 
 
 #statement='ForAll(x,ForAll(y,x==y))'
 
def createWFF(statement):
    updated_statement='int main(){'+statement+';}'
    parser = c_parser.CParser()
    ast1 = parser.parse(updated_statement)
    function_body = ast1.ext[0].body 
    expression=organizeStatementToObject_C(function_body.block_items)
    primeStatement(expression)
    allvariable={}
    str_program=programToinductiveDefination_C(expression , allvariable)
    program=eval(str_program+']')
    return expr2string1(program[2])

 
 


 

   


        	








#
#
#

def expr_subsitute_fun(e,e1,e2,functions): #e,e1,e2: expr
    args=expr_args(e)
    op=expr_op(e)
    if op!='and' and op!='or' and op!='not' and op!='implies' and op!='ite' and op not in _infix_op and op in functions.keys():
        for parameter in args:
        	print(parameter)
    if e==e1:
        return e2
    else:
        return e[:1]+list(expr_subsitute_fun(x,e1,e2,functions) for x in expr_args(e))
        
        
        
#filename='sv-benchmarks-master/sv-benchmarks-master/c/array-industry-pattern/array_of_struct_single_elem_init_true-unreach-call.i'
        
def main_struct(filename):
    content=None
    struct_map={}
    global new_variable
    with open(filename) as f:
        content = f.read()
    content=content.replace('\r','')
    text = r""" """+content
    parser = GnuCParser()
    ast = parser.parse(text)  
    generator = c_generator.CGenerator()
    var_list=getVariables(ast.ext[1].body)
    for var in var_list.keys():
    	variable=var_list[var]
    	if variable.getStructType() is not None:
    		struct_map[var]=variable.getStructType()
    statements=ast.ext[1].body.block_items
    print(generator.visit(c_ast.Compound(block_items=struct_transfer_block(statements,struct_map))))


    		
    		
def struct_transfer_block(statements,struct_map):
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Assignment:
            update_statements.append(c_ast.Assignment(op=statement.op, lvalue=struct_transfer(statement.lvalue,struct_map), rvalue=struct_transfer(statement.rvalue,struct_map))) 
        elif type(statement) is c_ast.While:
            update_statements.append(c_ast.While(cond=c_ast.BinaryOp(op=struct_transfer(statement.cond.op,struct_map), left=struct_transfer(statement.cond.left,struct_map), right=struct_transfer(statement.cond.right,struct_map)),stmt=c_ast.Compound(block_items=struct_transfer_block(statement.stmt.block_items,struct_map))))
        elif type(statement) is c_ast.If:
            update_statements.append(struct_transferIf(statement,struct_map))
        else:
            update_statements.append(statement)
    return update_statements
 
 
def struct_transfer(statement,struct_map):
    if type(statement) is c_ast.StructRef:
        parameter=[]
        parameter.append(statement.name)
        if type(statement.name) is c_ast.ArrayRef:
            struct_name=struct_map[getArrayName(statement.name)]
            field_name=statement.field.name
            return c_ast.FuncCall(name=c_ast.ID(name=struct_name+'_'+field_name), args=c_ast.ExprList(exprs=parameter))
        else:
            struct_name=struct_map[statement.name.name]
            field_name=statement.field.name
            return c_ast.FuncCall(name=c_ast.ID(name=struct_name+'_'+field_name), args=c_ast.ExprList(exprs=parameter))
    elif type(statement) is c_ast.BinaryOp:
        return c_ast.BinaryOp(op=statement.op,left=struct_transfer(statement.left,struct_map),right=struct_transfer(statement.right,struct_map))
    elif type(statement) is c_ast.UnaryOp:
        return c_ast.UnaryOp(op=statement.op, expr=struct_transfer(statement.expr,struct_map))
    elif type(statement) is c_ast.While:
        return c_ast.While(cond=c_ast.BinaryOp(op=struct_transfer(statement.cond.op,struct_map), left=struct_transfer(statement.cond.left,struct_map), right=struct_transfer(statement.cond.right,struct_map)),stmt=c_ast.Compound(block_items=struct_transfer_block(statement.stmt.block_items,struct_map)))
    elif type(statement) is c_ast.If:
        return struct_transferIf(statement,struct_map)
    elif type(statement) is c_ast.Cast:
        typename=getStructType(statement.to_type.type)
        if typename in struct_map:
            return c_ast.ID(name='NOTNULL')
        else:
            return statement	
    else:
        return statement
		
		
def struct_transferIf(statement,struct_map):
	new_iftrue=None
	new_iffalse=None
	if type(statement) is c_ast.If:
		if type(statement.iftrue) is c_ast.Compound:
			if statement.iftrue.block_items is not None:
				new_iftrue=c_ast.Compound(block_items=struct_transfer_block(statement.iftrue.block_items,struct_map))
			else:
				new_iftrue=c_ast.Compound(block_items=[])
		else:
			if type(statement) is c_ast.UnaryOp:
				new_iftrue=struct_transfer(statement.iftrue,struct_map)
			elif type(statement) is c_ast.BinaryOp:
				new_iftrue=struct_transfer(statement.iftrue,struct_map)
			else:
				new_blocks=[]
				new_blocks.append(statement.iftrue)
				new_iftrue=c_ast.Compound(block_items=struct_transfer_block(new_blocks,struct_map))
		if type(statement.iffalse) is c_ast.Compound:
			if statement.iffalse.block_items is not None:
				new_iffalse=c_ast.Compound(block_items=struct_transfer_block(statement.iffalse.block_items,struct_map))
			else:
				new_iffalse=c_ast.Compound(block_items=[])
		else:
			if type(statement.iffalse) is c_ast.If:
				new_iffalse=struct_transfer_block(statement.iffalse,struct_map)
			else:
				if type(statement) is c_ast.UnaryOp:
					new_iffalse=struct_transfer(statement.iffalse,struct_map)
				elif type(statement) is c_ast.BinaryOp:
					new_iffalse=struct_transfer(statement.iffalse,struct_map)
				else:
					if statement.iffalse is not None:
						new_blocks=[]
						new_blocks.append(statement.iffalse)
						new_iffalse=c_ast.Compound(block_items=struct_transfer_block(new_blocks,struct_map))
	return c_ast.If(cond=struct_transfer(statement.cond,struct_map), iftrue=new_iftrue, iffalse=new_iffalse)
	
def getArrayName(statement):
	if type(statement) is c_ast.ArrayRef:
		return getArrayName(statement.name)
	else:
		return statement.name
            
            
def getArrayNameDecl(statement):
	if type(statement) is c_ast.ArrayDecl:
		return getArrayNameDecl(statement.type)
	else:
		return statement.declname
		

#filename='sv-benchmarks/loop-lit/gr2006_true-unreach-call_true-termination-i.c'

#filename='sv-benchmarks/loop-invgen/apache-escape-absolute_true-unreach-call_true-termination.i'

#filename='syntax_test.py'

#filename='sv-benchmarks/loops/ludcmp_false-unreach-call.i'

#file_name='sv-benchmarks/loops/nec20_false-unreach-call_true-termination.i'

def main_test(filename):
    content=None
    try:
        fd = open(filename)
        text = "".join(fd.readlines())
        text=replaceAddOperator(text)
        filtered_program = SyntaxFilter.SLexer(text)
        filtered_program.build()
        content=filtered_program.filterSyntax()
    except SyntaxFilter.SLexerError as e:
    	print(e)
    sys.exit(1)
    text = r""" """+content
    parser = GnuCParser()
    ast = parser.parse(text)
    ast.show()
   
   
#file_name='benchmark(c)/sqrt.c'
#file_name='benchmark(c)/potSumm3.c' 
def cacheConstruct():
    try:
            #fd = open(file_name)
            text = "T(n+1)=(i + n + 1)*_N1(n) + T(n)"
            text=replaceAddOperator(text)
            filtered_program = SyntaxFilter.SLexer(text)
            filtered_program.build()
            counter=0
            variable_const_map={}
            print(filtered_program.createCommonEquation(variable_const_map,counter))
    except SyntaxFilter.SLexerError as e:
        print(e)
        sys.exit(1)

def wolframalphaConstruct():
    try:
		#fd = open(file_name)
		#text = " 1/4 n**2 (n + 1)**2"
		#text = "4 (-(n)+1)"
        text = '1/4 n^2 (n + 1)^2'
        text=replaceAddOperator(text)
        filtered_program = SyntaxFilter.SLexer(text)
        filtered_program.build()
        print(filtered_program.wolframalphaConstruct())
    except SyntaxFilter.SLexerError as e:
        print(e)
        sys.exit(1)
		

def getWolframalphaCacheTest():
	cache_map={'(n + 1)**3 + T(n)':['0','(n**2*(n + 1)**2)/2'],'(i + n + 1)**3 + T(n)':['N_1','N_1 + (n (n + (1 + 2*i) )*(- (2 - 2*i)  + n*(n + (1 + 2*i) )))/4']}
	expression='(n + i + 1)**3 + T(n)'
	base_expression='N_1'
	for element in cache_map.keys():
		if simplify(element)==simplify(expression):
			if simplify(cache_map[element][0])==simplify(base_expression):
				print('Result')
				print(cache_map[element][1])








#def constrauctTrace4Test(ite_no):
def constrauctTrace4Test(file_name):
    data = [line.strip() for line in open(file_name, 'r')]
    
    equations = eval(data[0])
    
    assumptions = eval(data[1])
    
    vfact = eval(data[2])
    

    #Example1
    #equations = [['i1', 0, '_n1', ['y8', ['+', ['_n1'], ['1']]], ['ite', ['<', ['x8', ['_n1']], ['50']], ['+', ['y8', ['_n1']], ['1']], ['-', ['y8', ['_n1']], ['1']]]], ['i1', 0, '_n1', ['x8', ['+', ['_n1'], ['1']]], ['ite', ['==', ['ite', ['<', ['ite', ['<', ['x8', ['_n1']], ['50']], ['+', ['y8', ['_n1']], ['1']], ['-', ['y8', ['_n1']], ['1']]], ['0']], ['1'], ['0']], ['0']], ['+', ['x8', ['_n1']], ['1']], ['x8', ['_n1']]]], ['i1', 0, '_n1', ['break_1_flag8', ['+', ['_n1'], ['1']]], ['ite', ['<', ['ite', ['<', ['x8', ['_n1']], ['50']], ['+', ['y8', ['_n1']], ['1']], ['-', ['y8', ['_n1']], ['1']]], ['0']], ['1'], ['0']]], ['i0', 0, ['y8', ['0']], ['0']], ['i0', 0, ['x8', ['0']], ['0']], ['i0', 0, ['break_1_flag8', ['0']], ['0']], ['s0', ['or', ['<=', ['1'], ['0']], ['!=', ['break_1_flag8', ['_N1']], ['0']]]], ['s1', ['implies', ['<', ['_n1'], ['_N1']], ['and', ['>', ['1'], ['0']], ['==', ['break_1_flag8', ['_n1']], ['0']]]]]]
    #equations = [['i1', 0, '_n1', ['n4', ['+', ['_n1'], ['1']]], ['ite', ['==', ['%', ['+', ['_n1'], ['0']], ['2']], ['0']], ['+', ['n4', ['_n1']], ['1']], ['n4', ['_n1']]]], ['i0', 0, ['n4', ['0']], ['0']]]
    #Example2
    #equations = [['i1', 0, '_n1', ['x8', ['+', ['_n1'], ['1']]], ['ite', ['==', ['%', ['_n1'],['2']],['0']], ['+', ['x8', ['_n1']], ['1']], ['**', ['x8', ['_n1']], ['2']]]], ['i0', 0, ['x8', ['0']], ['0']]]
    #for equation in equations:
    #    print wff2string1(equation)
    #constrauctTrace4Main(equations,ite_no)
    #equations = [['i1', 0, '_n1', ['x8', ['+', ['_n1'], ['1']]], ['ite', ['>=', ['C'],['0']], ['+', ['x8', ['_n1']], ['1']], ['+', ['x8', ['_n1']], ['2']]]], ['i0', 0, ['x8', ['0']], ['0']]]
    
    #equations = [['i1', 0, '_n1', ['x8', ['+', ['_n1'], ['1']]], ['ite', ['>=', ['C'],['0']], ['+', ['x8', ['_n1']], ['1']], ['ite', ['>=', ['x8',['_n1']],['0']], ['+', ['x8', ['_n1']], ['2']], ['+', ['x8', ['_n1']], ['2']]]]], ['i0', 0, ['x8', ['0']], ['0']]]

    #equations = [['i1', 0, '_n1', ['x8', ['+', ['_n1'], ['1']]], ['ite', ['>=', ['C'],['0']], ['+', ['x8', ['_n1']], ['1']], ['ite', ['>=', ['B'],['0']], ['+', ['x8', ['_n1']], ['2']], ['+', ['x8', ['_n1']], ['3']]]]], ['i0', 0, ['x8', ['0']], ['0']]]

    #equations = [['i1', 0, '_n1', ['x8', ['+', ['_n1'], ['1']]], ['ite', ['<=', ['x8',['_n1']],['C']], ['+', ['x8', ['_n1']], ['1']], ['ite', ['<=', ['x8',['_n1']],['B']], ['+', ['x8', ['_n1']], ['2']], ['+', ['x8', ['_n1']], ['3']]]]], ['i0', 0, ['x8', ['0']], ['A']]]

    
    #equations = [['i1', 0, '_n1', ['x8', ['+', ['_n1'], ['1']]], ['ite', ['>=', ['+',['_n1'],['*',['2'],['_n1']]],['0']], ['+', ['x8', ['_n1']], ['1']], ['ite', ['>=', ['_n1'],['0']], ['+', ['x8', ['_n1']], ['2']], ['+', ['x8', ['_n1']], ['3']]]]], ['i0', 0, ['x8', ['0']], ['0']]]

    #equations = [['i1', 0, '_n1', ['x8', ['+', ['_n1'], ['1']]], ['ite', ['<=', ['x8',['_n1']],['C']], ['+', ['x8', ['_n1']], ['1']], ['ite', ['<=', ['x8',['_n1']],['B']], ['x8', ['_n1']], ['-',['+', ['x8', ['_n1']], ['3']],['3']]]]], ['i0', 0, ['x8', ['0']], ['A']]]


    #assumptions =['A>=0','B>=0','C>=0']
    #assumptions =[]
    
    #vfact = [['A', 0, ['int']],['C', 0, ['int']],['B', 0, ['int']],['_n1', 0, ['int']],['x8', 1, ['int', 'int']]]
    #vfact = []
    
    conditionalCloseFormSoln(equations,assumptions,vfact)

#Close form solution of conditional equation
def conditionalCloseFormSoln(equations,assumptions,vfact):
    equation_map={}
    equation_base_map={}
    print('Recurrence:')
    for equation in equations:
        if equation[0]=='i0':
            left_expr=expr2string1(equation[2])
            equation_base_map[left_expr]=equation
            right_expr=expr2string1(equation[3])
            print(left_expr+' = '+right_expr)
            
        elif equation[0]=='i1':
            left_expr=expr2string1(equation[3])
            equation_map[left_expr]=equation
            right_expr=expr2string1(equation[4])
            print(left_expr+' = '+right_expr)
    constCondExpression(equation_map,equation_base_map,assumptions,vfact)
        



def constCondExpression(equation_map,equation_base_map,assumptions,vfact):
    for equation in equation_map:
        e1 = equation_map[equation]
        equation_base=str(simplify(equation).subs(simplify(str(e1[2])+"+1"),0))
        e2 = equation_base_map[equation_base]
        
        #print '--------------@@@@@@@@@@@@@@'
        #check_term=expr_replace(copy.deepcopy(e1[3]),eval("['+',['"+e1[2]+"'],['1']]"),eval("['"+e1[2]+"']"))
        #print isOneCaseChange(e1[4],check_term,0)
        #print '--------------@@@@@@@@@@@@@@'
        #return
    
        map_con_expression={}
        
        conditionChecking(e1,map_con_expression)
        
        Type_Rec=None
        
        Detect_Type=None
        
        const=str(e1[2]).replace('_n','_k')
        
        iter_const=str(e1[2]).replace('_n','_X')
        
        incr_query_base=eval("['>=',"+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['0']")))+","+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['-',['1']]")))+"]")
        
        decr_query_base=eval("['<=',"+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['0']")))+","+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['-',['1']]")))+"]")

        
        incr_query=eval("['Implies',['>=',"+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['+',['"+const+"'],['1']]")))+","+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['"+const+"']")))+"],"+"['>=',"+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['+',['"+const+"'],['2']]")))+","+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['+',['"+const+"'],['1']]")))+"]"+"]")
        
        decr_query=eval("['Implies',['<=',"+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['+',['"+const+"'],['1']]")))+","+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['"+const+"']")))+"],"+"['<=',"+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['+',['"+const+"'],['2']]")))+","+str(expr_replace(copy.deepcopy(e1[3]),eval("['"+e1[2]+"']"),eval("['+',['"+const+"'],['1']]")))+"]"+"]")
        
        
        if Type_Rec is None:
        
            conclusion=[]
            conclusion.append('s0')
            conclusion.append(incr_query_base)

        
            temp_frame=[]
            temp_output=[]
            temp_other=[]
        
            temp_other.append(e1)
            temp_other.append(e2)
        
            temp_constraint=[]
            witnessXml=''
        
            temp_post_condition=[]
            temp_post_condition.append(wff2z3_update(conclusion))

        
            status=tactic1_update(temp_frame,temp_output,temp_other,assumptions,temp_post_condition,vfact,[],temp_constraint,witnessXml)
            
        
            if 'Successfully Proved' in status:
                conclusion=[]
                conclusion.append('s0')
                conclusion.append(incr_query)
            
                temp_post_condition=[]
                temp_post_condition.append(wff2z3_update(conclusion))
            
                vfact.append(eval("['"+const+"', 0, ['int']]"))
            
                temp_constraint.append(const+">=0")
            
                status=tactic1_update(temp_frame,temp_output,temp_other,assumptions,temp_post_condition,vfact,[],temp_constraint,witnessXml)
                
                if 'Successfully Proved' in status:
                    Type_Rec='INCREMENTING'
            

        if Type_Rec is None:
        
            conclusion=[]
            conclusion.append('s0')
            conclusion.append(decr_query_base)

        
            temp_frame=[]
            temp_output=[]
            temp_other=[]
        
            temp_other.append(e1)
            temp_other.append(e2)
        
            temp_constraint=[]
            witnessXml=''
        
            temp_post_condition=[]
            temp_post_condition.append(wff2z3_update(conclusion))

        
            status=tactic1_update(temp_frame,temp_output,temp_other,assumptions,temp_post_condition,vfact,[],temp_constraint,witnessXml)
        
            if 'Successfully Proved' in status:
                conclusion=[]
                conclusion.append('s0')
                conclusion.append(decr_query)
            
                temp_post_condition=[]
                temp_post_condition.append(wff2z3_update(conclusion))
            
                #vfact.append(eval("['"+const+"', 0, ['int']]"))
            
                #temp_constraint.append(const+">=0")
            
                status=tactic1_update(temp_frame,temp_output,temp_other,assumptions,temp_post_condition,vfact,[],temp_constraint,witnessXml)
            
                if 'Successfully Proved' in status:
                    Type_Rec='DECREMENTING'






        
        for e_cond in map_con_expression:
            result_e = map_con_expression[e_cond]
            if len(result_e[0])==0:
                new_e1=copy.deepcopy(e1)
                new_e1[4]=result_e[3]
                result_sol = solve_rec(new_e1,e2)
                if result_sol is not None:
                    result_e.append(result_sol)
                if result_e[4] is not None:
                    new_e2=copy.deepcopy(e1)
                    new_e2[4]=result_e[4]
                    result_sol = solve_rec(new_e2,e2)
                    if result_sol is not None:
                        result_e[4]=result_sol
        
        cond_solution=[]
        cond_solution.append('i2')
        cond_solution.append('0')
        cond_solution.append(e1[2])
        cond_solution.append(expr_replace(copy.deepcopy(e1[3]),eval("['+',['"+e1[2]+"'],['1']]"),eval("['"+e1[2]+"']")))
        
        additional_axioms=[]
        
        for e_cond in map_con_expression:
            result_e = map_con_expression[e_cond]
            if len(result_e[0])==0 and len(result_e[1])==0:
                Detect_Type='Constant'
                if len(cond_solution)==4:
                    e_4th=[]
                    if result_e[4] is not None:
                        e_4th.append('ite')
                        e_4th.append(result_e[2])
                        e_4th.append(result_e[5][4])
                        e_4th.append(result_e[4][4])
                    else:
                        e_4th.append(result_e[5][4])
                    cond_solution.append(e_4th)
                else:
                    e_4th=[]
                    e_3th=cond_solution[4]
                    e_4th.append('ite')
                    e_4th.append(result_e[2])
                    e_4th.append(result_e[5][4])
                    e_4th.append(e_3th)
                    cond_solution[4]=e_4th
            elif len(result_e[0])==0 and len(result_e[1])>=0:
                Detect_Type='Variable'
                if len(cond_solution)==4:
                    e_4th=[]
                    if result_e[4] is not None:
                        e_4th.append('ite')
                        e_4th.append(result_e[2])
                        e_4th.append(result_e[5][4])
                        e_4th.append(result_e[4][4])
                    else:
                        e_4th.append('ite')
                        e_4th.append(result_e[2])
                        e_4th.append(result_e[5][4])
                        e_4th.append(None)
                    cond_solution.append(e_4th)
                else:
                    e_4th=[]
                    e_3th=cond_solution[4]
                    if e_3th[0]=='ite' and e_3th[3] is None:
                        if result_e[4][4] is not None:
                            e_4th.append('ite')
                            e_4th.append(result_e[2])
                            e_4th.append(result_e[5][4])
                            e_4th.append(result_e[4][4])
                            e_3th[3]=e_4th
                        else:
                            e_4th.append('ite')
                            e_4th.append(result_e[2])
                            e_4th.append(result_e[5][4])
                            e_4th.append(None)
                            e_3th[3]=e_4th
                    else:
                        e_4th.append('ite')
                        e_4th.append(result_e[2])
                        e_4th.append(result_e[5][4])
                        e_4th.append(e_3th)
                        cond_solution[4]=e_4th
            elif len(result_e[0])>0:
                Detect_Type=Type_Rec
                #print 'No Close Form Solution'
                new_e1=copy.deepcopy(e1)
                new_e1[3] = expr_replace(new_e1[3],eval("['+',['"+new_e1[2]+"'],['1']]"),eval("['"+new_e1[2]+"']"))
                new_e1[4] = expr_replace(new_e1[4],new_e1[3],e2[3])
                list_con_expression=[]
                conditionCheckingVerify(new_e1[4],list_con_expression,[])
                Case_Analysis=False
                for expr_list in list_con_expression:
                    var_cstr_map={}
                    expr2z3(expr_list[1],var_cstr_map)
                    for x in var_cstr_map:
                        vfact.append(eval("['"+x+"', 0, ['int']]"))
                        assumptions.append(var_cstr_map[x])
                    conclusion=[]
                    conclusion.append('s0')
                    conclusion.append(expr_list[1])
                    status=query2z3_cond(assumptions,wff2z3_update(conclusion),vfact)
                    expr_list.append(status)
                    if 'Successfully Proved' in status:
                        Case_Analysis=True
                
                case_map={}
                
                if Case_Analysis==False:
                    count=0
                    for expr_list in list_con_expression:
                        if count<len(list_con_expression)-1:
                            for x in range(0,len(list_con_expression)-1):
                                if x in case_map:
                                    list_cond=case_map[x]
                                    if count==x:
                                        list_cond.append(expr_list[1])
                                    else:
                                        list_cond.append(expr_complement(copy.deepcopy(expr_list[1])))
                                    case_map[x] = list_cond

                                else:
                                    list_cond=[]
                                    if count==x:
                                        list_cond.append(expr_list[1])
                                    else:
                                        list_cond.append(expr_complement(copy.deepcopy(expr_list[1])))
                                    case_map[x] = list_cond
                        count=count+1
                
                list_con_expression=[]
                conditionCheckingVerify(e1[4],list_con_expression,[])
                
                list_of_close_form_solns=[]
                
                    
                iter_Count=0
                list_of_close_form_solns=None
                
                perm= permutations(list_con_expression,len(list_con_expression))
                
                for x in list(perm):
                    updated_base_value=e2
                    allow_flag=False
                    for i in range(0,len(x)):
                            if allow_flag==False:
                                new_e3 = copy.deepcopy(e1)
                                new_e3[4] = x[i][2]
                                result_sol = solve_rec(new_e3,updated_base_value)
                                iter_Count=iter_Count+1
                                iter_const='_X'+str(iter_Count)
                                new_cond=expr_replace(copy.deepcopy(x[i][1]),result_sol[3],copy.deepcopy(result_sol[4]))
                                new_cond_const=expr_complement(expr_replace(copy.deepcopy(new_cond),eval("['"+new_e3[2]+"']"),eval("['"+iter_const+"']")))
                                eq1=[]
                                eq1.append('s0')
                                eq1.append(new_cond_const)
                                eq2=[]
                                eq2.append('s1')
                                eq2_temp=[]
                                eq2_temp.append('implies')
                                eq2_temp.append(eval("['<',['"+new_e3[2]+"'],['"+iter_const+"']]"))
                                eq2_temp.append(new_cond)
                                eq2.append(eq2_temp)
                                
                                
                                new_sol_base=expr_complement(expr_replace(copy.deepcopy(result_sol[4]),eval("['"+new_e3[2]+"']"),eval("['-',['"+iter_const+"'],['1']]")))
                                updated_base_value=copy.deepcopy(e2)
                                updated_base_value[3]=new_sol_base
                                new_cond_update=expr_replace(copy.deepcopy(new_cond),eval("['"+new_e3[2]+"']"),eval("['-',['"+new_e3[2]+"'],['1']]"))

                                
                                
                                query_sol=constructSolnQuery(new_cond_const,eval("['"+iter_const+"']"))
                                
                                expression = expr2string1(query_sol)
                                if 'or' not in expression and 'and' not in expression and 'If' not in expression:
                                    expression=expression.replace('==','-')
                                
                                    query_sol_update=solve_for_constant(expression, iter_const)
                                
                                    if query_sol_update is not None:
                                        query_sol=eval("['==',['"+iter_const+"'],"+str(query_sol_update)+"]") 
                            
                                    conclusion=[]
                                    conclusion.append('s0')
                                    conclusion.append(query_sol)

        
                                    temp_frame=[]
                                    temp_output=[]
                                    temp_other=[]
        
                                    temp_other.append(eq1)
                                    temp_other.append(eq2)
        
                                    temp_constraint=[]
                                    witnessXml=''
        
                                    temp_post_condition=[]
                                    temp_post_condition.append(wff2z3_update(conclusion))
                            
                                    vfact.append(eval("['"+iter_const+"', 0, ['int']]"))
                                        
                                    temp_constraint.append(iter_const+">0")
        
                                    status=tactic1_update(temp_frame,temp_output,temp_other,assumptions,temp_post_condition,vfact,[],temp_constraint,witnessXml)
                                
                                    if 'Successfully Proved' in status:
                                        update_query_sol=eval("['-',"+str(query_sol[2])+",['1']]")
                                        updated_base_value[3] = expr_replace(updated_base_value[3],query_sol[1],update_query_sol)
                                else:
                                    if expr_find(eq1[1],eval("['"+iter_const+"']"))==True:
                                        additional_axioms.append(eq1)
                                        additional_axioms.append(eq2)

                            #print expr2string1(result_sol[4])
                            #print expr2string1(new_cond_update)
                            
                                var_cstr_map={}
                                expr2z3(new_cond_update,var_cstr_map)
                                conclusion=[]
                                conclusion.append('s0')
                                conclusion.append(new_cond_update)
                                final_query=wff2z3_update(conclusion)
                                for para_cont in range(1,iter_Count+1):
                                    if "_X"+str(para_cont) in final_query:
                                        vfact.append(eval("['_X"+str(para_cont)+"', 0, ['int']]"))
                                        assumptions.append('_X'+str(para_cont)+'>=0')
                                for para in var_cstr_map:
                                    vfact.append(eval("['"+para+"', 0, ['int']]"))
                                    assumptions.append(var_cstr_map[para])
                                status=query2z3_cond(assumptions,final_query,vfact)

                                if 'Successfully Proved' in status or len(var_cstr_map)==0:
                                    allow_flag=True
                            
                            
                                list_of_close_form_solns = construct_soln_ite(list_of_close_form_solns,new_cond_update,result_sol[4])
                            
                            #print expr2string1(list_of_close_form_solns)

                            #print '------------1'
                if list_of_close_form_solns is not None:
                    list_of_close_form_solns = reconstruct_soln_ite(list_of_close_form_solns)
                    if len(cond_solution)==4:
                        cond_solution.append(cond_solution)
                    else:
                        cond_solution[4]=list_of_close_form_solns

                #print expr2string1(cond_solution[4])
                #print Type_Rec
                #print Case_Analysis
                #return
                        
        list_con_expression=[]
    
        conditionCheckingVerify(cond_solution[4],list_con_expression,[])
                
        count=0
        for expr_list in list_con_expression:
            count=count+1
            if Detect_Type=='Variable' and Detect_Type=='Constant':
                var_cstr_map={}
                expr2z3(expr_list[1],var_cstr_map)
                for x in var_cstr_map:
                    vfact.append(eval("['"+x+"', 0, ['int']]"))
                    assumptions.append(var_cstr_map[x])
                conclusion=[]
                conclusion.append('s0')
                conclusion.append(expr_list[1])
                status=query2z3_cond(assumptions,wff2z3_update(conclusion),vfact)
                expr_list.append(status)
            else:
                if count!=len(list_con_expression):
                    var_cstr_map={}
                    expr2z3(expr_list[1],var_cstr_map)
                    for x in var_cstr_map:
                        vfact.append(eval("['"+x+"', 0, ['int']]"))
                        assumptions.append(var_cstr_map[x])
                    conclusion=[]
                    conclusion.append('s0')
                    conclusion.append(expr_list[1])
                    status=query2z3_cond(assumptions,wff2z3_update(conclusion),vfact)
                    expr_list.append(status)
        count=0
        if Detect_Type=='Variable' and Detect_Type=='Constant':
            for expr_list in list_con_expression:
                if 'Successfully Proved' in expr_list[3]:
                    cond_solution[4]=expr_list[2]
                    break

        else:
            for expr_list in list_con_expression:
                count=count+1
                if count!=len(list_con_expression):
                    if 'Successfully Proved' in expr_list[3]:
                        cond_solution[4]=expr_list[2]
                        break
        #print 'Detected Type'
        #print Detect_Type
        print('Close Form Solution')
        print(expr2string1(cond_solution[4]))
        map_add_equ={}
        if len(additional_axioms)>0:
            print("Additional Axioms")
            for x in additional_axioms:
                key=wff2string1(x)
                if key not in map_add_equ.keys():
                    map_add_equ[key]=key
                    print(key)

       


def isOneCaseChange(e1,e2,count):
    if e1[0]=='ite':
        arg_list=expr_args(e1)
        if arg_list[1][0]=='ite':
            count=isOneCaseChange(arg_list[1],e2,count)
        else:
            exp1=simplify(expr2string1(arg_list[1]))
            exp2=simplify(expr2string1(e2))
            if exp1!=exp2:
                count=count+1
        if arg_list[2][0]=='ite':
            count=isOneCaseChange(arg_list[2],e2,count)
        else:
            exp1=simplify(expr2string1(arg_list[2]))
            exp2=simplify(expr2string1(e2))
            if exp1!=exp2:
                count=count+1
    return count

    




def construct_soln_ite(stmt,cond,cond_stmt):
    if stmt is None:
        stmt=[]
        stmt.append('ite')
        stmt.append(cond)
        stmt.append(cond_stmt)
        return stmt
    else:
        if stmt[0]=='ite':
            arg_list=expr_args(stmt)
            if len(arg_list)==2:
                stmt1=[]
                stmt1.append('ite')
                stmt1.append(cond)
                stmt1.append(cond_stmt)
                stmt.append(stmt1)
            else:
                arg_list[2] = construct_soln_ite(arg_list[2],cond,cond_stmt)
            return stmt
        else:
            return None
        
def reconstruct_soln_ite(stmt):
        if stmt[0]=='ite':
            arg_list=expr_args(stmt)
            if len(arg_list)==2:
                return arg_list[1]
            else:
                arg_list[2] = reconstruct_soln_ite(arg_list[2])
                temp=[]
                temp.append('ite')
                temp.append(arg_list[0])
                temp.append(arg_list[1])
                temp.append(arg_list[2])
                return temp
        return stmt


 
    
    






def constructSolnQuery(e,variable):
    if e[0]=='or':
        temp=[]
        temp.append('or')
        temp.append(constructSolnQuery(e[1],variable))
        temp.append(constructSolnQuery(e[2],variable))
        return temp
    elif e[0]=='and':
        temp=[]
        temp.append('and')
        temp.append(constructSolnQuery(e[1],variable))
        temp.append(constructSolnQuery(e[2],variable))
    if e[0]=='Or':
        temp=[]
        temp.append('Or')
        temp.append(constructSolnQuery(e[1],variable))
        temp.append(constructSolnQuery(e[2],variable))
        return temp
    elif e[0]=='And':
        temp=[]
        temp.append('And')
        temp.append(constructSolnQuery(e[1],variable))
        temp.append(constructSolnQuery(e[2],variable))
    elif e[0]=='<':
        if expr_find(e,variable)==True:
            e=expr_replace(e,variable,eval("['-',"+str(variable)+",['1']]"))
            e[0]='=='
            return e
        else:
            return e
    elif e[0]=='>':
        if expr_find(e,variable)==True:
            e=expr_replace(e,variable,eval("['-',"+str(variable)+",['1']]"))
            e[0]='=='
            return e
        else:
            return e
    elif e[0]=='<=':
        if expr_find(e,variable)==True:
            e[0]='=='
            return e
        else:
            return e
    elif e[0]=='=':
        if expr_find(e,variable)==True:
            e[0]='=='
            return e
        else:
            return e
    else:
        return e
    





       
            
                

def conditionChecking(e1,map_con_expression):
    if (e1[0]=='i1' and e1[4][0]=='ite') :
        arg_list=expr_args(e1[4])
        map_fun={}
        map_var={}
        isFunInExpression(arg_list[0],map_fun,map_var)
        list_expr=[]
        list_expr.append(map_fun)
        list_expr.append(map_var)
        list_expr.append(arg_list[0])
        list_expr.append(arg_list[1])
        if arg_list[2][0]=='ite':
            conditionChecking(arg_list[2],map_con_expression)
            list_expr.append(None)
        else:
            list_expr.append(arg_list[2])
        map_con_expression[expr2string1(arg_list[0])]=list_expr
    elif e1[0]=='ite':
        arg_list=expr_args(e1)
        map_fun={}
        map_var={}
        isFunInExpression(arg_list[0],map_fun,map_var)
        list_expr=[]
        list_expr.append(map_fun)
        list_expr.append(map_var)
        list_expr.append(arg_list[0])
        list_expr.append(arg_list[1])
        if arg_list[2][0]=='ite':
            conditionChecking(arg_list[2],map_con_expression)
            list_expr.append(None)
        else:
            list_expr.append(arg_list[2])
        map_con_expression[expr2string1(arg_list[0])]=list_expr






def conditionCheckingVerify(e1,list_con_expression,cond_expr):
    if e1[0]=='ite':
        temp_list=[]
        arg_list=expr_args(e1)
        if cond_expr==[]:
            new_cond_expr=expr_complement(copy.deepcopy(arg_list[0]))
        else:
            new_cond_expr=[]
            new_cond_expr.append('or')
            new_cond_expr.append(expr_complement(copy.deepcopy(arg_list[0])))
            new_cond_expr.append(cond_expr)        
        temp_list.append(expr2string1(arg_list[0])) 
        temp_list.append(arg_list[0])  
        temp_list.append(arg_list[1])
        list_con_expression.append(temp_list)
        if arg_list[2][0]=='ite':
            conditionCheckingVerify(arg_list[2],list_con_expression,new_cond_expr)
        else:
            temp_list=[]
            temp_list.append(expr2string1(new_cond_expr)) 
            temp_list.append(new_cond_expr)  
            temp_list.append(arg_list[2])
            list_con_expression.append(temp_list)
            







def isFunInExpression(e,map_fun,map_var):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        if op.startswith('_n')==True or op.startswith('_x')==True:
            map_var[op]=op
    elif len(args)>0 and op!='and' and op!='or' and op!='not' and op!='implies' and op not in _infix_op:
        map_fun[op]=op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                return isFunInExpression(args[0],map_fun)
            else:
                for x in args:
                    isFunInExpression(x,map_fun,map_var)
        elif op=='not' and len(args)==1:
            isFunInExpression(args[0],map_fun,map_var)
        elif op=='implies' and len(args)==2:
            isFunInExpression(args[0],map_fun,map_var)
            isFunInExpression(args[1],map_fun,map_var)
        elif op in _infix_op and len(args)==2:
            isFunInExpression(args[0],map_fun,map_var)
            isFunInExpression(args[1],map_fun,map_var)
        else:
            for x in args:
                isFunInExpression(x,map_fun,map_var)





                    





def constrauctTrace4Rec(equation,value,subs_map):
    update_equ={}
    equa_trace_map={}
    if equation[0]=='i1':
        left_expr=expr2string1(equation[3])
        if 'break_' not in left_expr:
            new_e = copy.deepcopy(equation)
            new_e[3] = expr_replace(new_e[3],eval("['+',['"+equation[2]+"'],['1']]"),eval("['"+str(value+1)+"']"))
            new_e[4] = expr_replace(new_e[4],eval("['"+equation[2]+"']"),eval("['"+str(value)+"']"))
            update_equ[left_expr]=new_e
    for key in update_equ:
        e=update_equ[key]
        for sub in subs_map:
            e[3] = expr_replace(e[3],subs_map[sub][0],subs_map[sub][1])
            e[4] = expr_replace(e[4],subs_map[sub][0],subs_map[sub][1])
        if e[4][0]=='ite':
            ret_value = constrauctTrace4Cond(e[4])
            if ret_value is not None:
                final_exp=expr2string1(ret_value)
                if 'ite' not in final_exp and 'and' not in final_exp and 'or' not in final_exp:
                    equa_trace_map_temp = []
                    equa_trace_map_temp.append(e[3])
                    #equa_trace_map_temp.append(value)
                    equa_trace_map_temp.append(eval("['"+str(simplify(final_exp))+"']"))
                    equa_trace_map_temp.append(value)
                    equa_trace_map[key]=equa_trace_map_temp
        else:
            final_exp=expr2string1(e[4])
            if 'ite' not in final_exp and 'and' not in final_exp and 'or' not in final_exp:
                    equa_trace_map_temp = []
                    equa_trace_map_temp.append(e[3])
                    #equa_trace_map_temp.append(e[4])
                    equa_trace_map_temp.append(eval("['"+str(simplify(final_exp))+"']"))
                    equa_trace_map_temp.append(value)
                    equa_trace_map[key]=equa_trace_map_temp
    return equa_trace_map
    
        
def constrauctTrace4Cond(e):
    if e[0]=='ite':
        if e[1][0]=='ite':
            value=constrauctTrace4Cond(e[1])
            if value is not None:
                conclusion=[]
                conclusion.append('s0')
                conclusion.append(value)
                status=query2z3_cond([],wff2z3_update(conclusion),[])
                #print status
                if 'Successfully Proved' in status:
                    if e[2][0]=='ite':
                        return constrauctTrace4Cond(e[2])
                    else:
                        return e[2]
                elif 'Counter Example' in status:
                    if e[3][0]=='ite':
                        return constrauctTrace4Cond(e[3])
                    else:
                        return e[3]
                else:
                    return None
        else:
            conclusion=[]
            conclusion.append('s0')
            conclusion.append(e[1])
            status=query2z3_cond([],wff2z3_update(conclusion),[])
            #print status
            if 'Successfully Proved' in status:
                if e[2][0]=='ite':
                    return constrauctTrace4Cond(e[2])
                else:
                    return e[2]
            elif 'Counter Example' in status:
                if e[3][0]=='ite':
                    return constrauctTrace4Cond(e[3])
                else:
                    return e[3]
            else:
                return None
    else:
        return e
    
    
    
    
def constrauctTrace4Degree(e,d,domain):
    if e[0]=='ite':
        d = constrauctTrace4Degree(e[2],d,domain)
        d = constrauctTrace4Degree(e[3],d,domain)
        return d
    else:
        d_degree=degree(simplify(expr2string1(e)),gen=simplify(expr2string1(domain)))
        if d_degree>d:
            d=d_degree
        return d


# expr_find(e,e1): find subterm e1 in e 

def expr_find(e,e1): #e,e1,e2: expr
    if e==e1:
        return True
    else:
    	for x in expr_args(e):
    		flag=expr_find(x,e1)
    		if flag:
    			return flag
    	return False


                        

    
    	
    	
    



    
    
def prove_auto(file_name,property=None):
    if not(os.path.exists(file_name)): 
        print ("File not exits")
        return
    if os.path.exists(currentdirectory+'/errorWitness.graphml'):
        os.remove(currentdirectory+'/errorWitness.graphml')
    if os.path.exists(currentdirectory+'/correctnessWitness.graphml'):
        os.remove(currentdirectory+'/correctnessWitness.graphml')
            
            
    start_time=current_milli_time()
    content=None
    witness_path=None
    global new_variable
    global fail_count
    global error_count
    global assume_count
    global assert_count
    global defineMap
    global defineDetaillist
    global map___VERIFIER_nondet
    global new_variable_array
    global counter_variableMap
    global counter_variableMap_Conf
    global sub_vfact
    global external_var_map
    global fun_call_map
    global current_fun_call
    global fun_substitution_map
    global line_no_stmt_map
    global count_ast_line_no
    global main_count_ast_line_no
    global main_line_no_stmt_ast_map
        
    struct_map={}
    fail_count=0
    error_count=0
    assume_count=0
    assert_count=0
    count_ast_line_no=0
    main_count_ast_line_no=0
    map___VERIFIER_nondet={}
    new_variable_array={}
    counter_variableMap={}
    counter_variableMap_Conf={}
    fun_call_map={}
    fun_substitution_map={}
    line_no_stmt_map={}
    function_vfacts=[]
    program_analysis=''
    program_analysis2=''
    program_analysis3=''
    program_analysis_decl=''
    program_analysis_var_decl=''
    current_fun_call=None
    struct_list=None
    type_struct_list=None
    line_no_stmt_map=None
    original_program=None
    new_program=None
    main_line_no_stmt_ast_map={}

    displayInfoMap = None
        
    try:
        fd = open(file_name)
        text = "".join(fd.readlines())
        original_program=text
                
        defineMap={}
        content,defineMap=preProcessorHandling(text)
        text=replaceAddOperator(text)
        filtered_program = SyntaxFilter.SLexer(text)
        filtered_program.build()
                
        content,struct_list,type_struct_list=filtered_program.filterSyntax()
                #print '--------------'
                #print content
                #print '--------------'
                #print struct_list
                #print '--------------'
                #print type_struct_list
                #print '--------------'
    except SyntaxFilter.SLexerError as e:
        print('Error(Find Error in Input File)')
		#print(e)
        return
    text = r""" """+content
    parser = GnuCParser()
	#ast = parse_file(file_name, use_cpp=True)
    try:
            
            #print('##############')
            #print(struct_list)
            #print(text)
            #print('##############')
            try:
                new_program = text
                #line_no_stmt_map = constructLineStmtmap(original_program,text)
                line_no_stmt_map = {}
            except Exception as e:
                line_no_stmt_map=None
                print(str(e))
                print('=============')
            
            ast = parser.parse(text)
            for struct_str in struct_list:
                
                isCorrectSyn=False
                try:
                    ast_struct = parser.parse(struct_str)
                    isCorrectSyn=True
                except Exception as e:
                    isCorrectSyn=False
                
                if isCorrectSyn==True:
                
                    struct_name=ast_struct.ext[0].type.name
                
                    isPointer=False
                
                    isTypedef=False
                
                    defName=None
                
                    variable_map=getVariablesC(ast_struct.ext[0].type.decls)
                
                    structobject = structclass(struct_name, isTypedef,  variable_map , defName, isPointer)
                
                    struct_map[struct_name]=structobject

            for struct_str in type_struct_list:
                isCorrectSyn=False
                try:
                    ast_struct = parser.parse(struct_str)
                    isCorrectSyn=True
                except Exception as e:
                    isCorrectSyn=False
                
                if isCorrectSyn==True:
                
                    isPointer=False
                
                    isTypedef=False
                
                    struct_name = ast_struct.ext[0].name
                
                    if type(ast_struct.ext[0]) is c_ast.Typedef:
                        isTypedef=True
                    
                    if type(ast_struct.ext[0].type) is c_ast.PtrDecl:
                        isPointer=True
                    if isPointer==True:
                        struct_name = ast_struct.ext[0].type.type.type.name
                        defName = ast_struct.ext[0].type.type.declname
                        if struct_name is None and defName is not None:
                            struct_name=defName
                        variable_map=getVariablesC(ast_struct.ext[0].type.type.type.decls)
                        structobject = structclass(struct_name, isTypedef, variable_map , defName, isPointer)
                        struct_map[struct_name]=structobject
                    else:
                        struct_name = ast_struct.ext[0].type.declname
                        defName = ast_struct.ext[0].type.type.name
                        variable_map=getVariablesC(ast_struct.ext[0].type.type.decls)
                        structobject = structclass(struct_name, isTypedef, variable_map , defName, isPointer)
                        struct_map[struct_name]=structobject
                
    except Exception as e:
            #print 'Error(Find Error in Input File)'
            print ('Unknown')
            print(str(e))
            writeLogFile( "j2llogs.logs" ,str(e))
            return
        #ast.show()
    generator = c_generator.CGenerator()
    writeLogFile( "j2llogs.logs" , getTimeStamp()+"\nCommand--Translate \n"+"\nParameters--\n File Name--"+file_name+"\n")
    if ast is None:
        print("Error present in code. Please verify you input file")
        return
    if len(ast.ext)==0:
        print("Error present in code. Please verify you input file")
        return
    externalvarmap={}
    externalarraymap={}
    functionvarmap={}
    memberfunctionmap={}
    axiomeMap={}
    addition_array_map={}
    function_vfact_map={}
    witnessXml_map={}
	
    counter=0 
        

    try:
            for e in ast.ext:
                    if type(e) is c_ast.Decl:
                            if type(e.type) is c_ast.FuncDecl:
                                    parametermap={}
                                    structType=None
                                    new_e,pointer_list,array_list=pointerHandlingParameter(e)
                                    if new_e is None:
                                            function_decl=e
                                    else:
                                            function_decl=new_e
                                    if function_decl.type.args is not None:
                                            for param_decl in function_decl.type.args.params:
                                                    if param_decl.name is not None:
                                                            structType=None
                                                            if type(param_decl.type) is c_ast.ArrayDecl:
                                                                    degree=0
                                                                    dimensionmap={}
                                                                    data_type,degree,structType=getArrayDetails(param_decl,degree,dimensionmap)
                                                                    variable=variableclass(param_decl.name, data_type,None,dimensionmap,None,structType)
                                                            else:
                                                                    try:
                                                                        #variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                        variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                    except Exception as e:
                                                                        #print 'Error(Translation to Intermate Intermediate)'
                                                                        print('Unknown')
                                                                        writeLogFile( "j2llogs.logs" ,str(e))
                                                                        #print str(e)
                                                                        return
                                                            parametermap[param_decl.name]=variable

                                    membermethod=membermethodclass(function_decl.name,function_decl.type.type.type.names[0],parametermap,None,None,0,0,None,None,None)
                                    functionvarmap[membermethod.getMethodname()]=membermethod

                            elif type(e.type) is c_ast.TypeDecl:
                                    #e.type.show()
                                    var_type=None
                                    initial_value=None
                                    structType=None
                                    e=change_var_name_decl(e)
                                    for child in e.children():
                                            if type(child[1].type) is c_ast.IdentifierType:
                                                    var_type=child[1].type.names[0]
                                            else:
                    				
                                                    initial_value=child[1].value
                                    #variable=variableclass(e.name, var_type,None,None,initial_value,structType)
                                    variable=variableclass(e.name, var_type,None,None,initial_value,structType)
                                    program_analysis_var_decl=program_analysis_var_decl+str(generator.visit(e))+';\n'
                                    externalvarmap[e.name]=variable
                                    external_var_map[e.name]=e.name
                            elif type(e.type) is c_ast.ArrayDecl:
                                program_analysis_var_decl=program_analysis_var_decl+str(generator.visit(e))+';\n'
                                array_name=getArrayNameDecl(e.type)
                                externalarraymap[array_name]=change_var_name_decl(e)
                                external_var_map[array_name]=e.name
                    else:
                            if type(e) is c_ast.FuncDef:                          
                                    parametermap={}
                                    new_e,pointer_list,array_list=pointerHandlingParameter(e)
                                    if new_e is None:
                                            function_decl=e
                                    else:
                                            function_decl=new_e
    				
                                    function_decl=e.decl
                                
                                
                                    function_body = e.body
                                
                                    if function_body.block_items is not None:
                                        #function_body=pointerHandlingDecl(function_body,pointer_list,array_list)
                                        statements=function_body.block_items
                                        statements=change_var_name(statements)
                                        function_body= c_ast.Compound(block_items=statements)
                                        localvarmap=getVariables(function_body)
                                        counter=counter+1
                                        if function_decl.type.args is not None:
                                                for param_decl in function_decl.type.args.params:
                                                        new_param_decl=declarationModifying(param_decl)
                                                        if new_param_decl is not None:
                                                            param_decl=new_param_decl
                                                        param_decl=change_var_name_decl(param_decl)
                                                        if param_decl.name is not None:
                                                                structType=None
                                                                if type(param_decl.type) is c_ast.ArrayDecl:
                                                                        #print param_decl.show()
                                                                        degree=0
                                                                        dimensionmap={}
                                                                        data_type,degree,structType=getArrayDetails(param_decl,degree,dimensionmap)
                                                                        variable=variableclass(param_decl.name, data_type,None,dimensionmap,None,structType)
                                                                elif type(param_decl.type) is c_ast.PtrDecl:
                                                                        stmt=pointerToArray(param_decl)
                                                                        #print stmt.show()
                                                                        if stmt is not None and type(stmt.type) is c_ast.ArrayDecl:
                                                                                degree=0
                                                                                dimensionmap={}
                                                                                data_type,degree,structType=getArrayDetails(param_decl,degree,dimensionmap)
                                                                                variable=variableclass(stmt.name, data_type,None,dimensionmap,None,structType)
                                                                else:				
                                                                        try:
                                                                            variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                        except Exception as e:
                                                                            print('Error(Translation to Intermate Intermediate)')
                                                                            writeLogFile( "j2llogs.logs" ,str(e))
                                                                            #print str(e)
                                                                            return
                                                                parametermap[param_decl.name]=variable
                                    if function_decl.name in functionvarmap.keys():
                                            if function_decl.name!='__VERIFIER_assert':
                                                membermethod=membermethodclass(function_decl.name,function_decl.type.type.type.names[0],parametermap,localvarmap,function_body,0,counter,None,None,function_decl)
                                                functionvarmap[function_decl.name]=membermethod
                                    else:
                                            if function_decl.type.args is not None:
                                                    for param_decl in function_decl.type.args.params:
                                                            new_param_decl=declarationModifying(param_decl)
                                                            if new_param_decl is not None:
                                                                param_decl=new_param_decl
                                                                param_decl=change_var_name_decl(param_decl)
                                                            if param_decl.name is not None:
                                                                    structType=None
                                                                    if type(param_decl.type) is c_ast.ArrayDecl:
                                                                            degree=0
                                                                            dimensionmap={}
                                                                            data_type,degree,structType=getArrayDetails(param_decl,degree,dimensionmap)
                                                                            variable=variableclass(param_decl.name, data_type,None,dimensionmap,None,structType)
                                                                    elif type(param_decl.type) is c_ast.PtrDecl:
                                                                            stmt=pointerToArray(param_decl)
                                                                            if stmt is not None and type(stmt.type) is c_ast.ArrayDecl:
                                                                                    degree=0
                                                                                    dimensionmap={}
                                                                                    data_type,degree,structType=getArrayDetails(param_decl,degree,dimensionmap={})
                                                                                    variable=variableclass(stmt.name, data_type,None,dimensionmap,None,structType)
								
                                                                    else:	
                                                                            try:
                                                                               
                                                                                variable=variableclass(param_decl.name, param_decl.type.type.names[0],None,None,None,structType)
                                                                            except Exception as e:
                                                                                print('Error(Translation to Intermate Intermediate)')
                                                                                writeLogFile( "j2llogs.logs" ,str(e))
                                                                                #print str(e)
                                                                                return
                                                                    parametermap[param_decl.name]=variable
                                            if function_decl.name!='__VERIFIER_assert' and function_decl.name!='exit':
                                                membermethod=membermethodclass(function_decl.name,function_decl.type.type.type.names[0],parametermap,localvarmap,function_body,0,counter,None,copy.deepcopy(function_body),function_decl)
                                                functionvarmap[membermethod.getMethodname()]=membermethod
    except Exception as e:
            print('Unknown')
            #writeLogFile( "j2llogs.logs" ,str(e))
            print(str(e))
            print('================1')
            return

    for medthod in functionvarmap.keys():
            membermethod=functionvarmap[medthod]
            body=membermethod.getBody()
            if body is not None:
                    if body.block_items is not None: 
                        
                        try:

                            #print('===============1')

                            statements,pa_statements=programTransformation(body,functionvarmap,medthod)

                            #print('===============2')
                            #print(statements)
                            #print(pa_statements)
                            #print('===============2')
                        
                            statements = updatePointerStruct(statements,struct_map)

                            #print('===============3')
                            #print(statements)
                            #print('===============3')
                        
                            pa_statements = updatePointerStruct(pa_statements,struct_map)

                            #print('===============4')
                            
                            #pa_statements = organizeInnerDeclartionMain(pa_statements)
                            
                        
                        except Exception as e:
                            #print 'Error(Translation to Intermate Intermediate)'
                            print('Unknown')
                            writeLogFile( "j2llogs.logs" ,str(e))
                            print(str(e))
                            print('================')
                            return
                        
                        for temp_method in externalarraymap.keys():
                            if isVarPresnt(statements,temp_method)==True:
                                new_statements=[]
                                new_statements.append(externalarraymap[temp_method])
                                statements=construct_program(new_statements+statements)
                        body_comp = c_ast.Compound(block_items=statements)
                        localvarmap=getVariables(body_comp)
                        statements,localvarmap=addAllExtVariables(statements,externalvarmap,localvarmap)
                        statements = translateStruct(statements,localvarmap,struct_map)
                        line_count_ast_Block(pa_statements)
                        #statements=pointerHandling(statements,pointer_list,array_list)
                        body_comp = c_ast.Compound(block_items=statements)
                        membermethod.setBody(body_comp)
                        membermethod.setLocalvar(localvarmap)
                        membermethod.setAnalysis_module(c_ast.Compound(block_items=pa_statements))
                    else:
                        membermethod.setBody(None)
                        membermethod.setLocalvar(None)
            else:
                membermethod.setBody(None)
                membermethod.setLocalvar(None)
    
    temp_functionvarmap={}
    	
    for medthod in functionvarmap.keys():
                membermethod=functionvarmap[medthod]
                in_var_map=membermethod.getInputvar()
                if len(in_var_map)>0:
                    for x in in_var_map:
                        variable=in_var_map[x]
                        if variable.getDimensions() is not None and len(variable.getDimensions())>0:
                            temp_functionvarmap[medthod]=functionvarmap[medthod]
                elif medthod=='main':
                        temp_functionvarmap[medthod]=functionvarmap[medthod]
                
    	
    for medthod in functionvarmap.keys():
            membermethod=functionvarmap[medthod]
            body=membermethod.getBody()
            if body is not None:
                    if medthod=='main':
                        statements=body.block_items
                        statements = substituteFunBlock(statements,temp_functionvarmap,medthod,externalvarmap)
                        body_comp = c_ast.Compound(block_items=statements)
                        membermethod.setBody(body_comp)
                        #body_comp = c_ast.Compound(block_items=statements)
                        #generator = c_generator.CGenerator()
                        #print(generator.visit(body_comp))
                        if len(temp_functionvarmap)>0:
                            ret_body_comp,temp_status1,temp_status2 = reduceArraySize1("int main()"+generator.visit(body_comp))
                        
                            if ret_body_comp is not None and temp_status1==True and temp_status2:
                                body_comp = ret_body_comp.body
                                membermethod.setBody(body_comp)
                        

    
    	
    	
    
    	#program in intermediate form
    programeIF=[]

    programeIF.append('-1')
    			
    programeIF.append('prog')

    programe_array=[]

    variables_list_map={}
        
    for medthod in functionvarmap.keys():
        f_vfact=[]
        f_vfact_para=[]
        membermethod=functionvarmap[medthod]
        if membermethod.getreturnType() is not 'void':
                    f_vfact.append(medthod)
                    f_vfact_para.append(membermethod.getreturnType())
                    for iv in membermethod.getInputvar():
                        i_var=membermethod.getInputvar()[iv]
                        f_vfact_para.append(i_var.getVariableType())
                    f_vfact.append(len(f_vfact_para)-1)
                    f_vfact.append(f_vfact_para)
                    function_vfacts.append(f_vfact)

                
        body=membermethod.getBody()
                
        if body is not None:
            new_variable={}
            update_statements=[]
    			   		
            body_comp=body
	    		
            membermethod.setTempoary(body_comp)
	    		
            statements=body.block_items
	    		
            new_variable.clear()

            update_statements=[]
			
            for var in new_variable.keys():
                if isBoolVariable( var )==True:
			    	    	#temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['_Bool'])), init=c_ast.Constant(type='_Bool', value=None), bitsize=None)
                        temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
                        update_statements.append(temp)
                else:
                        if type(new_variable[var]) is tuple:
                                            type_stmt,t_degree=new_variable[var]
                                            program_temp=type_stmt+' '+var
                                            for x in range(0,t_degree):
                                                program_temp+='[]'
                                            program_temp+=';'
                                            temp_ast = parser.parse(program_temp)
                                            update_statements.append(temp_ast.ext[0])
                        else:
                                            if var in new_variable_array.keys():
                                                type_stmt='int'
                                                t_degree=new_variable_array[var]
                                                program_temp=type_stmt+' '+var
                                                for x in range(0,t_degree):
                                                    program_temp+='[]'
                                                program_temp+=';'
                                                temp_ast = parser.parse(program_temp)
                                                update_statements.append(temp_ast.ext[0])
                                            else:
                                                temp=c_ast.Decl(name=var, quals=[], storage=[], funcspec=[], type=c_ast.TypeDecl(declname=var, quals=[], type=c_ast.IdentifierType(names=['int'])), init=c_ast.Constant(type='int', value='0'), bitsize=None)
                                                update_statements.append(temp)
			        	
            for statement in statements:
                update_statements.append(statement)
                        
            body_comp=c_ast.Compound(block_items=update_statements)
	    		
            membermethod.setBody(body_comp)
   
    			
            localvarmap=getVariables(body_comp)
    			
            for var in externalvarmap.keys():
                variable=externalvarmap[var]
                localvarmap[var]=variable
    			
            membermethod.setLocalvar(localvarmap)
            membermethod=functionvarmap[medthod]
    			    			
            function=[]
    			
            function.append('-1')
    			
            function.append('fun')    			
    			
            functionName=[]
    			
            allvariable={}
    			
            for x in membermethod.getInputvar():
                allvariable[x]=membermethod.getInputvar()[x]
            for x in membermethod.getLocalvar():
                allvariable[x]=membermethod.getLocalvar()[x]
            if validationOfInput(allvariable)==True:
                print('Unkown')
				#print "Please Rename variable Name {S,Q,N,in,is} to other Name"
                return
    			

            try:
                            
                            program,variablesarray,fname,iputmap,opvariablesarray,module_analysis,module_analysis2=translate2IntForm(membermethod.getMethodname(),membermethod.getreturnType(),membermethod.getBody(),membermethod.getInputvar(),membermethod.getTempoary(),membermethod.getAnalysis_module(),struct_map)

            except Exception as e:
                            #print 'Error(error occurred during translation intermediate format)'
                print('Unknown')
                writeLogFile( "j2llogs.logs" ,str(e))
                print('================3')
                print(str(e))
                return
		

            functionName.append(fname)

                        
            if len(iputmap.keys())>0:
                for x_i in range(0,len(iputmap.keys())):
                    functionName.append(list(iputmap.keys())[len(iputmap.keys())-1-x_i])


            function.append(functionName)
                        
                        
			
            function.append(program)
                        

            programe_array.append(function)
		
            variables_list_map[fname]=variablesarray
			
            addition_array=[]
			
            addition_array.append(iputmap)
			
            addition_array.append(allvariable)
			
            addition_array.append(opvariablesarray)
			
            addition_array_map[fname]=addition_array
			
            memberfunctionmap[fname]=membermethod
                        
                        
			
            function_vfact_list=[]
            function_vfact=[]
            function_vfact.append(fname)
            function_vfact.append(len(iputmap))
            parameters_type=[]
            parameters_type.append(membermethod.getreturnType())
            for x in defineDetaillist:
                function_vfact_list.append(x)
					
			
            defineDetaillist=[]
            for element in iputmap.keys():
                variable=iputmap[element]
                if variable is not None:
                    parameters_type.append(variable.getVariableType())
            function_vfact.append(parameters_type)
            function_vfact_list.append(function_vfact)
            function_vfact_map[fname]=function_vfact_list	
                        
            resultfunction='__VERIFIER_nondet_int'
                        
            filename=file_name
            functionname=functionName
                        
            witnessXml=getWitness(filename,fname,resultfunction)
            witnessXml_map[fname]= witnessXml
            if program_analysis is not None:
                            #print '###########################3'
                            #print membermethod.getFun_decl().show()
                            #print '###########################3'
                            program_decl=programPrint(membermethod.getFun_decl())
                            #print '^^^^^^^^^^^^^^^^^^^'
                            #print membermethod.getMethodname()
                            #print membermethod.getreturnType()
                            #print program_decl
                            #print '^^^^^^^^^^^^^^^^^^^'
                            if 'main' not in program_decl:
                                program_analysis_decl+=programPrint(membermethod.getFun_decl())+';\n'
                            module_analysis_t1,module_analysis_t2=module_analysis2
                            program_analysis2=program_decl+programPrint(module_analysis_t1)+program_analysis2
                            program_analysis3=program_decl+programPrint(module_analysis_t2)+program_analysis3
                            program_analysis=program_decl+programPrint(module_analysis)+program_analysis
                            
        
        
        program_analysis=program_analysis_var_decl+program_analysis
        programeIF.append(programe_array)
        
        #print('--------------------------------')
        #print(programeIF)
        #print('--------------------------------')
        #print(variables_list_map)
        #print('--------------------------------')
        #return
        
        try:
            f_map,o_map,a_map,ff_map,oo_map,aa_map,fff_map,ooo_map,aaa_map,cm_map,assert_map,assume_map,assert_key_map,assert_list_mom_two, assume_list_mom_two, assert_key_mom_two, assert_list_mom_three, assume_list_mom_three, assert_key_mom_three,displayInfoMap=translate1(programeIF,variables_list_map,1)
            #print a_map
        except Exception as e:
            print('Error(Translation Failed)')
            writeLogFile( "j2llogs.logs" ,str(e))
            print (str(e))
            return

        #Comment me to use Z3
        #return
        f_list=f_map.keys()
        cycle_list=[]
        programgraph_map=construct_graph(f_map,o_map,a_map,f_list)
        programgraph = graphclass.Graph(programgraph_map)
        

        
        if programgraph.cyclic():
            cycle_list=list(itertools.chain.from_iterable(programgraph.getAllNodesInCycle()))
            

        f_list=removeCycles(f_list,cycle_list)
        

        
        for f_x in cycle_list:
            for x in o_map[f_x]:
                if o_map[f_x][x][0]=='e':
                    o_map[f_x][x][2] = reconstructRecurences(o_map[f_x][x][2],cycle_list)
                    
        for f_x in cycle_list:
            if f_x in fun_call_map.keys() and fun_call_map[f_x]==1:
                for x in o_map['main']:
                    if o_map['main'][x][0]=='e':
                        o_map['main'][x][2] = reconstructRecurences(o_map['main'][x][2],cycle_list)
        


        function_substitution_test('main',programgraph_map,f_map,o_map,a_map,assert_map,assume_map,cycle_list)
        
        
           
        #print '$$$$$$$$$$$$$$$$$$$$'
        
        #print cycle_list
        
        #print '$$$$$$$$$$$$$$$$$$$$'
        
        
        
        
        #for x in f_map.keys():
        #    f=f_map[x]
        #    o=o_map[x]
        #    a=a_map[x]
        #    f,o,a=updateAxoimsRecurrences(f,o,a,cycle_list)
        #    f_map[x]=f
        #    o_map[x]=o
        #    a_map[x]=a
        
        if type(f_map) is dict and type(o_map) is dict and type(a_map) is dict and type(cm_map) is dict and type(assert_key_map) is dict:
                for key in f_map.keys():
                        membermethod=functionvarmap[key]                        
                        #print membermethod.getreturnType()
                f=f_map[key]
                o=o_map[key]
                a=a_map[key]
                cm=cm_map[key]

                ff=ff_map[key]
                oo=oo_map[key]
                aa=aa_map[key]

                fff=fff_map[key]
                ooo=ooo_map[key]
                aaa=aaa_map[key]


                        
                assert_list=assert_map[key]
                assume_list=assume_map[key]

                assert_list_2=assert_list_mom_two[key]
                assume_list_2=assume_list_mom_two[key]

                assert_list_3=assert_list_mom_three[key]
                assume_list_3=assume_list_mom_three[key]



                        
                assert_list=function_substitution_main_Assert(assert_list,f_map,o_map,a_map,cycle_list)
                        
                        
                addition_array=addition_array_map[key]
        		
                vfacts,constraints=getVariFunDetails(f,o,a,addition_array[1],addition_array[2])
        		
                vfacts2=getVariFunDetails2(f,o,a,addition_array[1],constraints,assert_list,assume_list)

                    
                for x in a:
                    equ=getConstraints_Eq(x,addition_array[1],constraints)
                    if equ is not None:
                        constraints.append(equ)
                vfacts=[]
                for vfact in vfacts2:
                    vfacts.append(vfacts2[vfact])
                        
                for x in function_vfacts:
                    vfacts.append(x)
                    

        		#for element in function_vfact_map.keys():
        		#	function_vfact_list=function_vfact_map[element]
        		#	for x in function_vfact_list:
                        #                if x[0] not in vfacts2.keys():
                        #                    vfacts.append(x)
                f,o,a,cm,assert_list = rec_solver_tactic8(f,o,a,assert_list)
                 
                f,o,a,vfacts=organizeAxioms(f,o,a,vfacts)
                #output_axioms_fn(f,o,a)
                axiom=axiomclass(f,o,a,ff,oo,aaa,fff,ooo,aaa,membermethod.getInputvar(), vfacts, constraints,cm,assert_list,assume_list,assert_list_2, assume_list_2, assert_list_3, assume_list_3, addition_array[1])
                axiomeMap[key]=axiom

                #print('#######')
                #print(vfacts)
                #print('#######')
                #print external_var_map
                #print program_analysis
                #print '#######'
                end_time=current_milli_time()
                #print "Translation Time--"
		#print end_time-start_time
                #AssetionAnalysis2(program_analysis2,program_analysis_decl)
                #
                #return
                
                
                if len(f_list)==1 and 'main' in f_list:
                    axiommain=axiomeMap['main']
                    vfactsmain=axiommain.getVfact()
                    
                    a=axiommain.getOther_axioms()
                    assert_list_main=axiommain.getAsserts()
                    re_equations=[]
                    for fun in cycle_list:
                        axiom=axiomeMap[fun]
                        if axiom is not None:
                            equations=[]
                            list_exps={}
                            f=axiom.getFrame_axioms()
                            o=axiom.getOutput_equations()
                            witnessXml= witnessXml_map[fun]
                            assert_list=axiom.getAsserts()
                            vfacts=axiom.getVfact()
                            inputvar=axiom.getInputvariable()
                            
                            for x in o:
                                equation=[]
                                equation.append('R')
                                equation.append(list(inputvar.keys()))
                                equation.append(o[x][1])

                                
                                equation.append(o[x][2])

                                a.append(equation)
                                equations.append(copy.deepcopy(equation))
                                re_equations.append(copy.deepcopy(equation))
                            for x in axiommain.getOutput_equations():
                                e=axiommain.getOutput_equations()[x]
                                if '_FAILED' in x and e[0]=='e':
                                    getRecuresiveFunDef(e[2],cycle_list,list_exps)
                                    temp_condition_map={}
                                    getAllCondtion_tactic8(e,temp_condition_map)
                                    list_ConcreteValue = getConcreteValue(temp_condition_map)
                                    if len(list_ConcreteValue)==1:
                                        results=AssetionAnalysis5(program_analysis,program_analysis_decl,list_ConcreteValue[0])
                                        if type(results) is str and  'Termination Failed' in results:
                                            print('Termination Failed')
                                            return
                                        if results is not None and len(results.keys())>0:
                                            print('VIAP_STANDARD_OUTPUT_False')
                                            result=AssetionAnalysis3(program_analysis3,program_analysis_decl,file_name,property)
                                            if result is not None:
                                                #print "Error Witness Generated"
                                                writtingFile( "errorWitness.graphml" , result )
                                                writeLogFile( "j2llogs.logs" , "\nViolation \n"+str(result)+"\n" )
                                                return
                                            else:
                                                line_no,stmt2 = getLineNumber_terminate('__VERIFIER_error()','main')
                                            
                                                if property is None:
                                                    property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
                                                else:
                                                    if '=' in property:
                                                        value_names=property.split('=')
                                                        fd = open(value_names[1])
                                                        property = "".join(fd.readlines())
                                                    else:
                                                        property="CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )"
            
                                            
                                                violation_witness2=''
                    
                                                return
                    
                                    
                            for vfact in vfacts:
                                #if vfact[0][-1]!='1' and vfact[0]!=fun:
                                if vfact[0][0:len(vfact[0])-1] not in inputvar and vfact[0]!=fun:
                                    vfactsmain.append(vfact)
                                if vfact[0][-1]=='1' and '_FAILED1' in vfact[0]:
                                    vfactsmain.append(vfact)
                            for list_exp in list_exps:
                                status=prove_assert_tactic6(equations,list_exps[list_exp],cycle_list,vfactsmain,witnessXml)
                                if status is not None:
                                    a.append(status)
                            for tassert in assert_list:
                                assert_list_main.append(tassert)
                    
                    #print '--------------------'
                    #print re_equations
                    vfactsmain=axiommain.getVfact()
                    a=axiommain.getOther_axioms()
                    for x in axiommain.getOutput_equations():
                        if '_FAILED' in x:
                            e=axiommain.getOutput_equations()[x][2]
                            #print e
                            addition_equs = prove_assert_tactic7(e,re_equations,cycle_list,vfactsmain,witnessXml)
                            for addition_equ in addition_equs:
                                a.append(addition_equ)
                    
                    axiommain.setOther_axioms(a)
                    axiomeMap['main']=axiommain
                    #print '--------------------'
                program=programclass(file_name, memberfunctionmap , externalvarmap, axiomeMap, witnessXml_map, displayInfoMap) 
                return prove_auto_strategy1(program,property,program_analysis,program_analysis_decl)
                #return program
        else:
        	print('Error in  Translation')
            
            
            
def translate2IntForm(function_name,function_type,function_body,parametermap,tempory,function_body_pa,struct_map):
    global current_fun_call
    if function_body is None: 
        print ("Empty Body")
        return None
        
    start_time=current_milli_time()
    
    statements=function_body.block_items
       
    localvarmap=getVariables(function_body)
    
    
    print ('Program Body')
    
    generator = c_generator.CGenerator()
    
    
    print(generator.visit(tempory))
    #print(generator.visit(function_body))
    
    
    
    membermethod=membermethodclass(function_name,function_type,parametermap,localvarmap,function_body,0,0,tempory,function_body_pa,None)

    input_value_extract=constructProgAssertAnalysis2(copy.deepcopy(membermethod.getAnalysis_module()),localvarmap,membermethod.getInputvar(),membermethod.getMethodname())

    
    membermethod.setAnalysis_module(constructProgAssertAnalysis(membermethod.getAnalysis_module(),localvarmap,membermethod.getInputvar()))
    
    
    #print '!!!!!!!!!!!!!!!!!!'
    #print(generator.visit(membermethod.getAnalysis_module()))
    #print '!!!!!!!!!!!!!!!!!!'

    
    print ("Function Name:")
    print (membermethod.getMethodname())
    print ("Return Type:")
    print (membermethod.getreturnType())
    print ("Input Variables:")
    var_list="{"
    for x in membermethod.getInputvar():

        if membermethod.getInputvar()[x].getDimensions() is not None and len(membermethod.getInputvar()[x].getDimensions())>0:
            if membermethod.getInputvar()[x].getStructType() is None:
                var_list+=' '+x+':array'
            else:
                var_list+=' '+x+':array'
                #var_list+=' '+x+':'+membermethod.getInputvar()[x].getStructType()
        else:
            var_list+=' '+x+':'+membermethod.getInputvar()[x].getVariableType()
    var_list+='}'
    print (var_list)
    print( "Local Variables:")
    var_list="{"
    for x in membermethod.getLocalvar():
        if membermethod.getLocalvar()[x].getDimensions() is not None and len(membermethod.getLocalvar()[x].getDimensions())>0:
            if membermethod.getLocalvar()[x].getStructType() is None:
                var_list+=' '+x+':array'
            else:
                var_list+=' '+x+':array'
                #var_list+=' '+x+':'+membermethod.getLocalvar()[x].getStructType()
        else:
            var_list+=' '+x+':'+membermethod.getLocalvar()[x].getVariableType()
    var_list+='}'
    print (var_list)
    allvariable={}
    program_dec_start=""
    program_dec_end=""
    for lvap in localvarmap:
        var=localvarmap[lvap]
        if var is not None and var.getInitialvalue() is not None:
            #print var.getInitialvalue()
            #print type(var.getInitialvalue())
            #type(var.getInitialvalue()).show()
            
	    #if type(var.getInitialvalue()) is not c_ast.BinaryOp and '__VERIFIER_nondet' in var.getInitialvalue():
	    #	defineDetailtemp=[]
	    #	parameter_list=[]
	    #	parameter_list.append('int')
	    #	defineDetailtemp.append(var.getInitialvalue())
	    #	defineDetailtemp.append(0)
	    #	defineDetailtemp.append(parameter_list)
	    # 	defineDetaillist.append(defineDetailtemp)
            if program_dec_start=="":
            	if type(var.getInitialvalue()) is c_ast.BinaryOp:
                        program_dec_start="['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+expressionCreator_C(var.getInitialvalue())+"]"
                        program_dec_end="]"
            	else:
                    if is_hex(str(var.getInitialvalue())) is not None:
                        program_dec_start="['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+"expres('"+is_hex(str(var.getInitialvalue()))+"')]"
                    else:
                        program_dec_start="['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+"expres('"+str(var.getInitialvalue())+"')]"
                    program_dec_end="]"
            else:
            	if type(var.getInitialvalue()) is c_ast.BinaryOp:
                    program_dec_start+=",['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+expressionCreator_C(var.getInitialvalue())+"]"
                    program_dec_end+="]"
            	else:
                    if is_hex(str(var.getInitialvalue())) is not None:
                        program_dec_start+=",['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+"expres('"+is_hex(str(var.getInitialvalue()))+"')]"
                    else:
                        program_dec_start+=",['-1','seq',['-1','=',expres('"+str(var.getVariablename())+"'),"+"expres('"+str(var.getInitialvalue())+"')]"
                    program_dec_end+="]"

    #print('==========================')
    for x in membermethod.getInputvar():
        allvariable[x]=membermethod.getInputvar()[x]
    for x in membermethod.getLocalvar():
        allvariable[x]=membermethod.getLocalvar()[x]
    

    current_fun_call = membermethod.getMethodname()

    #print('==========================')
       
    expressions=organizeStatementToObject_C(statements)

    #print('==========================')
    
    primeStatement(expressions)
    variablesarray={}
    opvariablesarray={}
    count=0
    arrayFlag=False
    
    struct_var_def_map={}
    #print('==========================')
    
    
    for variable in allvariable:
        count+=1
        if allvariable[variable].getDimensions() is not None and len(allvariable[variable].getDimensions())>0:
            if allvariable[variable].getStructType() is None:
                variablesarray[variable]=eval("['_y"+str(count)+"','array']")
                opvariablesarray[variable+"1"]=eval("['_y"+str(count)+"','array']")
                list_parameter="'array'"
                for i in range(0, len(allvariable[variable].getDimensions())):
                    if list_parameter=='':
                        list_parameter="'int'"
                    else:
                        list_parameter+=",'int'"
                list_parameter+=",'"+allvariable[variable].getVariableType()+"'"
                #key1=str(allvariable[variable].getDimensions())+'array'
                key1='d'+str(len(allvariable[variable].getDimensions()))+'array'
                arrayFlag=True
                if key1 not in variablesarray.keys():
                    count+=1
                    variablesarray[key1]=eval("['_y"+str(count)+"',"+list_parameter+"]")
                    opvariablesarray[key1+"1"]=eval("['_y"+str(count)+"',"+list_parameter+"]")
            else:
                variablesarray[variable]=eval("['_y"+str(count)+"','array']")
                opvariablesarray[variable+"1"]=eval("['_y"+str(count)+"','array']")
                #variablesarray[variable]=eval("['_y"+str(count)+"','"+allvariable[variable].getStructType()+"']")
                #opvariablesarray[variable+"1"]=eval("['_y"+str(count)+"','"+allvariable[variable].getStructType()+"']")
                if allvariable[variable].getStructType() in struct_map.keys():
                    var_mem_list=struct_map[allvariable[variable].getStructType()]
                    print (var_mem_list.getName())
                    for var_mem in var_mem_list.getVariablemap().keys():
                        member_var=var_mem_list.getVariablemap()[var_mem]
                        struct_key=allvariable[variable].getStructType()+"_"+member_var.getVariablename()
                        if struct_key not in struct_var_def_map.keys():
                            count+=1
                            struct_var_def_map[struct_key]=eval("['_y"+str(count)+"',"+"'"+allvariable[variable].getStructType()+"','"+member_var.getVariableType()+"'"+"]")

                    #for var_men in var_mem_list:
                    #    print var_men
                    #    var_member=var_mem_list[var_men]
                    #    print '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
                    #    print var_member
                    #    print '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
                
        else:
            variablesarray[variable]=eval("['_y"+str(count)+"','"+allvariable[variable].getVariableType()+"']")
            opvariablesarray[variable+"1"]=eval("['_y"+str(count)+"','"+allvariable[variable].getVariableType()+"']")

    for element in struct_var_def_map.keys():
         variablesarray[element]=struct_var_def_map[element]
         opvariablesarray[element+"1"]=struct_var_def_map[element]
    if program_dec_start=="":
        #print('==========================##')  
        #expressionCheckTest(expressions)
        #print(expressions)  
        #print('==========================##') 
        str_program=programToinductiveDefination_C(expressions , allvariable)
        #print('==========================##')    

    else:
        try:
            str_program=program_dec_start+','+programToinductiveDefination_C(expressions , allvariable)+program_dec_end
        except Exception as e:
            print (e)
    program=eval(str_program)
    return program,variablesarray,membermethod.getMethodname(),membermethod.getInputvar(),opvariablesarray,membermethod.getAnalysis_module(),input_value_extract





def expressionCheckTest(expressions):
   for expression in expressions:
       if type(expression) is expressionclass:
          print(type(expression))
       elif type(expression) is blockclass:
          expressionCheckTest(expression.getExpression())
       elif type(expression) is Ifclass:
            if expression.getExpressionif() is not None:
               expressionCheckTest(expression.getExpressionif())
            if expression.getExpressionelse() is not None:
               if type(expression.getExpressionelse()) is Ifclass:
                  expressionCheckTestIf(expression.getExpressionelse())
               else:
                  expressionCheckTest(expression.getExpressionelse())

def expressionCheckTestIf(expression):
    if type(expression) is expressionclass:
       print(type(expression))
    elif type(expression) is blockclass:
       expressionCheckTest(expression.getExpression())
    elif type(expression) is Ifclass:
       if expression.getExpressionif() is not None:
          expressionCheckTest(expression.getExpressionif())
       if expression.getExpressionelse() is not None:
          if type(expression.getExpressionelse()) is Ifclass:
             expressionCheckTestIf(expression.getExpressionelse())
          else:
             expressionCheckTest(expression.getExpressionelse())








#Construct Program for Assetion Analysis

def constructProgAssertAnalysis(functionbody,localvariables,inputvariables):
    #arg_list=[]
    #arg_list.append(c_ast.Constant(type="string", value="\"j:%d\\n\""))
    #arg_list.append(c_ast.ID(name="j"))
    #print_function=c_ast.FuncCall(name=c_ast.ID(name="printf"), args=c_ast.ExprList(exprs=arg_list))
    temp_localvariables = getVariables(functionbody)
    functionbody=c_ast.Compound(block_items=addPrintStmt(functionbody.block_items,temp_localvariables,inputvariables))
    return functionbody


count_for__VERIFIER_nondet=0
count_for__insert_flag=0
count_for__function_flag=0
line_count_trace=0
new_program_trace_var={}
back_line_no_stmt_map={}
main_line_no_stmt_ast_map={}
count_ast_line_no=0





def constructProgAssertAnalysis2(functionbody,localvariables,inputvariables,methodname):
    global count_for__VERIFIER_nondet
    global count_for__insert_flag
    global count_for__function_flag
    global count_ast_line_no
    global new_program_trace_var
    global line_no_stmt_map
    global back_line_no_stmt_map
    global main_line_no_stmt_ast_map
    
    if line_no_stmt_map is None:
        
        return (functionbody,functionbody)
    
    
    back_line_no_stmt_map=copy.deepcopy(line_no_stmt_map)
    

    count_for__VERIFIER_nondet=0
    count_for__insert_flag=0
    count_for__function_flag=0
    new_program_trace_var={}
    all_variable_map={}
    update_statements=[]
    parser = c_parser.CParser()
    try:
        new_statements=copy.deepcopy(functionbody.block_items)
        
        statements = constructExcutionTraceBlock(copy.deepcopy(functionbody.block_items),all_variable_map,methodname,new_statements)
        
        for x in new_program_trace_var.keys():
            program_temp='int '+x+'=0;'
            temp_ast = parser.parse(program_temp)
            update_statements.append(temp_ast.ext[0])
        for x in statements:
             update_statements.append(x)
    except Exception as e:
        print (e)
    functionbody.block_items=modify__VERIFIER_nondet_block(functionbody.block_items)
    functionbody=c_ast.Compound(block_items=addPrintStmt2(functionbody.block_items,localvariables,inputvariables))
    functionbody1=c_ast.Compound(block_items=update_statements)
    return (functionbody,functionbody1)








def normalizeSmallest(left_list_exp,right_list_exp,const):
        
    remove_list=[]
    
    for x in  left_list_exp:
        
        if expr_find(x,const)!=True:
            args=expr_args(x)
            op=expr_op(x)
            if op=='-' and len(args)==1:
                
                right_list_exp.append(args[0])
                
                remove_list.append(x)
                
            else:
                
                right_list_exp.append(eval("['-',"+str(x)+"]"))
                
                remove_list.append(x)
                
    for x in remove_list:
        
        left_list_exp.remove(x)
        
    remove_list=[]
    
    for x in  right_list_exp:
        
        if expr_find(x,const)==True:
            args=expr_args(x)
            op=expr_op(x)
            if op=='-' and len(args)==1:
                
                left_list_exp.append(args[0])
                
                remove_list.append(x)
                
            else:
                
                left_list_exp.append(eval("['-',"+str(x)+"]"))
                
                remove_list.append(x)
                
    for x in remove_list:
        
        right_list_exp.remove(x)
            
    str_left_exps = None

        
    for x in left_list_exp:
        
        if str_left_exps is None:
            
            str_left_exps=str(x)
            
        else:
        
            if x[0]=='-':
                
                str_left_exps="['-',"+str_left_exps+","+str(x[1])+"]"
            
            else:
                
                str_left_exps="['+',"+ str_left_exps+","+str(x)+"]"
                
                
    str_right_exps = None
        
    for x in right_list_exp:
        
        if str_right_exps is None:
            
            str_right_exps=str(x)
            
        else:
        
            if x[0]=='-':
                
                str_right_exps="['-',"+str_right_exps+","+str(x[1])+"]"
            
            else:
                
                str_right_exps="['+',"+str_right_exps+","+str(x)+"]"

    if str_left_exps is not None and str_right_exps is not None:
        left_list_exp = eval(str_left_exps)
        right_list_exp = eval(str_right_exps)
        return left_list_exp, right_list_exp
    else:
        return None, None
        




def collectAllTermsProduct(e,list):
    
    args=expr_args(e)
    op=expr_op(e)

    if len(args)==0:
        if op != '0':
            list.append(e)
        
    else:
        if op in '*' and len(args)==2:
            
            collectAllTermsProduct(args[0],list)
            
            collectAllTermsProduct(args[1],list)
            
        elif op in '/' and len(args)==2:
            
            collectAllTermsProduct(args[0],list)
            
            collectAllTermsProduct(args[1],list)
            
        else:
            
            if e[0]!='0':
    
                list.append(e)





def collectAllTerms(e,list):
    
    args=expr_args(e)
    op=expr_op(e)

    if len(args)==0:
        if op != '0':
            list.append(e)
        
    else:
        if op in '+' and len(args)==2:
            
            collectAllTerms(args[0],list)
            
            collectAllTerms(args[1],list)
            
        elif op in '-' and len(args)==2:
            
            collectAllTerms(args[0],list)
            
            collectAllTerms_Neg(args[1],list)
            
        else:
            
            if e[0]!='0':
    
                list.append(e)



def collectAllTerms_Neg(e,list):
    
    args=expr_args(e)
    op=expr_op(e)

    if len(args)==0:
        if op != '0':
            list.append(eval("['-',"+str(e)+"]"))
    else:
        if op in '+' and len(args)==2:
            
            collectAllTerms_Neg(args[0],list)
            
            collectAllTerms_Neg(args[1],list)
            
        elif op in '-' and len(args)==2:
            
            collectAllTerms_Neg(args[0],list)
            
            collectAllTerms(args[1],list)
            
        else:
            
            if e[0]!='0':
        
                list.append(eval("['-',"+str(e)+"]"))









def isBigNPresent(e):
    args=expr_args(e)
    op=expr_op(e)
    if len(args)==0:
        if '_N' in op:
            return op
    else:
        if op=='and' or op=='or':
            if len(args)==1:
                result = isBigNPresent(args[0])
                if result is not None:
                    return result
            else:
                result = isBigNPresent(args[0])
                if result is not None:
                    return result
                result = isBigNPresent(args[1])
                if result is not None:
                    return result
        elif op=='not' and len(args)==1:
                result = isBigNPresent(args[0])
                if result is not None:
                    return result
        elif op=='implies' and len(args)==2:
                result = isBigNPresent(args[0])
                if result is not None:
                    return result
                result = isBigNPresent(args[1])
                if result is not None:
                    return result
        elif op == '-' and len(args)==1:
                result = isBigNPresent(args[0])
                if result is not None:
                    return result

        elif op in _infix_op and len(args)==2:
                result = isBigNPresent(args[0])
                if result is not None:
                    return result
                result = isBigNPresent(args[1])
                if result is not None:
                    return result

        else:
            if '_N' in op:
                
                return e
    return None     


#expression=['>', ['*', ['A'], ['+', ['-', ['_N1']], ['x']]], ['0']]
#variable = ['_N1']
def normalRearrange(expression, variable):

    global fun_call_map

    x_new = copy.deepcopy(expression)

    x_new[0] = '-'

    #print(simplify(expr2string1(x_new)))

    #print(simplify(expr2string1(variable)))

    solution = solve(simplify(expr2string1(x_new)), simplify(expr2string1(variable)))

    #print(solution)


    if len(solution)==1:

       result = solution[0]

       if "**" in str(result):
           result=translatepowerToFun(str(result))

       if 'log)' in  str(result):

           result = solution[0]

           result = str(result).replace('2**(_n3 + 1)','power(2,(_n3 + 1))')

       expression=str(str(expr2string1(variable))+"="+str(result))

       fun_call_map={}

       parser = c_parser.CParser()


       ast = parser.parse("void test(){"+expression+";}")

       statement_temp=ast.ext[0].body.block_items[0]   

       return expr_replace_power(eval(expressionCreator_C(statement_temp.lvalue))), expr_replace_power(eval(expressionCreator_C(statement_temp.rvalue)))
 
    elif len(solution)==2:

       #for soln in solution:

           result = solution[1]

           if "**" in str(result):
              result=translatepowerToFun(str(result))


           expression=str(str(expr2string1(variable))+"="+str(result))

           fun_call_map={}

           parser = c_parser.CParser()

           ast = parser.parse("void test(){"+expression+";}")

           statement_temp=ast.ext[0].body.block_items[0]   


           left_soln = expr_replace_power(eval(expressionCreator_C(statement_temp.lvalue)))

           right_soln = expr_replace_power(eval(expressionCreator_C(statement_temp.rvalue)))

           return left_soln, right_soln
           #return expr_replace_power(eval(expressionCreator_C(statement_temp.lvalue))), expr_replace_power(eval(expressionCreator_C(statement_temp.rvalue)))



    return None, None



def normalRearrangeWolfForm(expression, variable):

    global fun_call_map

    x_new = copy.deepcopy(expression)

    x_new[0] = '-'

    solutions = solve(simplify(expr2string1(x_new)), simplify(expr2string1(variable)))

    if len(solutions)==2:

       for solution in solutions:

           result = solution

           if "**" in str(result):
              result=translatepowerToFun(str(result))

           expression=str(str(expr2string1(variable))+"="+str(result))

           fun_call_map={}

           parser = c_parser.CParser()

           ast = parser.parse("void test(){"+expression+";}")

           statement_temp=ast.ext[0].body.block_items[0]

           expr_left = eval(expressionCreator_C(statement_temp.lvalue))

           expr_right = eval(expressionCreator_C(statement_temp.rvalue))

           if expr_right[0] is not '-':

              return expr_replace_power(expr_left), expr_replace_power(expr_right) 

    return None, None

   


def isNegValue(e):

    args=expr_args(e)

    op=expr_op(e)

    if op=='-':
       
       return True

    else:

       return False



def getDegree(e,degree):


    if len(e)>1:

       args=expr_args(e)

       op=expr_op(e)

       if op=='^' or op=='**':

          if is_number(expr2string1(args[1]))==False:

             degree = expr2string1(args[1])

          else:

             if is_number(degree)==True:

                if degree < int(expr2string1(args[1])):

                   degree = int(expr2string1(args[1]))

             for x in args:

                 getDegree(x,degree)

       else:

           for x in args:

               getDegree(x,degree)

    return degree




def isFunctionPresent_Sm(e):

    args=expr_args(e)
    op=expr_op(e)
    
    if op=='and' or op=='or':
        if len(args)==1:
            result = isFunctionPresent_Sm(args[0])
            if result is not None:
                return result
        else:
            result = isFunctionPresent_Sm(args[0])
            if result is not None:
                return result
            result = isFunctionPresent_Sm(args[1])
            if result is not None:
                return result
    elif op=='not' and len(args)==1:
            result = isFunctionPresent_Sm(args[0])
            if result is not None:
                return result
    elif op=='implies' and len(args)==2:
            result = isFunctionPresent_Sm(args[0])
            if result is not None:
                return result
            result = isFunctionPresent_Sm(args[1])
            if result is not None:
                return result
    elif op == '-' and len(args)==1:
            result = isFunctionPresent_Sm(args[0])
            if result is not None:
                return result

    elif op in _infix_op and len(args)==2:
            result = isFunctionPresent_Sm(args[0])
            if result is not None:
                return result
            result = isFunctionPresent_Sm(args[1])
            if result is not None:
                return result

    else:
        
        if '_N' not in op and len(args)==2:
            
            return e
        
    return None


def getPowerBase(e, constant):

    args=expr_args(e)

    op=expr_op(e)

    if op == '**':

       if args[1]==constant:

          return args[0]

    else:

       for x in args:
          
           ret = getPowerBase(x,constant)
          
           if ret is not None:

              return ret

    return None




def isFunOnlyBigN(e):  

    func_map = {}     

    isOnlyBigN(e,func_map)

    return func_map 


def isOnlyBigN(e,func_map):

    args=expr_args(e)

    op=expr_op(e)

    if '_N' not in op and '_n' not in op and len(args)>0 and op not in _infix_op:

       func_map[op] = e

       for x in args:
          
          isOnlyBigN(x,func_map)

    elif op in _infix_op and len(args)==2:

       for x in args:
          
           isOnlyBigN(x,func_map)

    else:

       for x in args:
          
           isOnlyBigN(x,func_map)



def tempateAbstarctSum(exp, constant, fun_map, a_axioms, final_bound_values):

    global fun_call_map

    fun_name = list(fun_map.keys())[0]

    fun_exp = fun_map[list(fun_map.keys())[0]]

    expr_stmt = None

    base_expr_stmr = None

    variable = None

    for axiom in a_axioms:

        if axiom[0]=='i1':

           if axiom[-2][0]== fun_name:

              expr_stmt = axiom

              variable = axiom[2]

        if axiom[0]=='i0':

           if axiom[-2][0]== fun_name:

              base_expr_stmr = axiom

    if expr_stmt is not None and base_expr_stmr is not None:



       ret_map = isFunOnlyBigN(expr_stmt[-1])

       if ret_map==fun_map:

          #x_new = expr_replace(x_new, fun_exp, base_expr_stmr)

          #smallest equation n = 0
          x_new_0 = copy.deepcopy(exp)



          constant_0 = copy.deepcopy(constant)

          constant_0 = expr_replace(constant_0, eval("['"+variable+"']"), ['0'])


          if expr_find(x_new_0, eval("['"+variable+"']"))==False:


             if expr_find(x_new_0, ['-',constant_0, ['1']])==True:

                x_new_0 = expr_replace(x_new_0, ['-',constant_0, ['1']], ['0'])

                x_new_0 = expr_replace(x_new_0, base_expr_stmr[-2], base_expr_stmr[-1])

                x_new_0[0]='-'

                #print('==========================')
                #print(final_bound_values)
                #print('==========================')


                result_l_0, result_r_0 = normalRearrange(x_new_0, constant_0)

             else:

                x_new_0 = expr_replace(x_new_0, constant_0, ['0'])

                x_new_0 = expr_replace(x_new_0, base_expr_stmr[-2], base_expr_stmr[-1])

                x_new_0[0]='-'

                result_l_0, result_r_0 = normalRearrange(x_new_0, constant_0)


          else:

             x_new_0 = expr_replace(x_new_0, eval("['"+variable+"']"), ['0'])

             x_new_0 = expr_replace(x_new_0, base_expr_stmr[-2], base_expr_stmr[-1])

             x_new_0[0]='-'

             result_l_0, result_r_0 = normalRearrange(x_new_0, constant_0)


          


          if result_r_0 is not None and 'log' not in  expr2string1(result_r_0):

              #equation 1
              equa_1 = copy.deepcopy(expr_stmt)

              equa_1[-1] = expr_replace(equa_1[-1], eval("['"+variable+"']"), ['0'])

              equa_1[-1] = expr_replace(equa_1[-1], base_expr_stmr[-2], base_expr_stmr[-1])

              equa_1[-1] = expr_replace(equa_1[-1], result_l_0, result_r_0)

              equa_1[-2] = expr_replace(equa_1[-2], eval("['+',['"+variable+"'],['1']]"), ['1'])


              #smallest equation n = 1
              x_new_1 = copy.deepcopy(exp)

              x_new_1 = expr_replace(x_new_1, eval("['"+variable+"']"), ['1'])

              x_new_1 = expr_replace(x_new_1, equa_1[-2], equa_1[-1])



              x_new_1[0]='-'

              constant_1 = copy.deepcopy(constant)

              constant_1 = expr_replace(constant_1, eval("['"+variable+"']"), ['1'])

              result_l_1, result_r_1 = normalRearrange(x_new_1, constant_1)


              #equation 2
              equa_2 = copy.deepcopy(expr_stmt)

              equa_2[-1] = expr_replace(equa_2[-1], eval("['"+variable+"']"), ['1'])

              equa_2[-1] = expr_replace(equa_2[-1], result_l_1, result_r_1)

              equa_2[-1] = expr_replace(equa_2[-1], equa_1[-2], equa_1[-1])

              equa_2[-2] = expr_replace(equa_2[-2], eval("['+',['"+variable+"'],['1']]"), ['2'])


              #smallest equation n = 2
              x_new_2 = copy.deepcopy(exp)

              x_new_2 = expr_replace(x_new_2, eval("['"+variable+"']"), ['2'])

              x_new_2 = expr_replace(x_new_2, equa_2[-2], equa_2[-1])

              x_new_2[0]='-'

              constant_2 = copy.deepcopy(constant)

              constant_2 = expr_replace(constant_2, eval("['"+variable+"']"), ['2'])

              result_l_2, result_r_2 = normalRearrange(x_new_2, constant_2)

              #equation 3
              equa_3 = copy.deepcopy(expr_stmt)

              equa_3[-1] = expr_replace(equa_3[-1], eval("['"+variable+"']"), ['2'])

              equa_3[-1] = expr_replace(equa_3[-1], result_l_2, result_r_2)

              equa_3[-1] = expr_replace(equa_3[-1], equa_2[-2], equa_2[-1])

              equa_3[-1] = expr_replace(equa_3[-1], equa_1[-2], equa_1[-1])



              equa_3[-2] = expr_replace(equa_3[-2], eval("['+',['"+variable+"'],['1']]"), ['3'])

              if result_r_0 == result_r_1:

                 return result_r_0

              elif result_r_0 != result_r_1 and result_r_1 == result_r_2:

                 #print([variable])

                 #print(result_r_0)

                 #print(result_r_1)

                 #print(expr_find(result_r_0, result_r_1))

                

                 #if is_number(str(simplify(expr2string1(result_r_0))))==True and simplify(expr2string1(result_r_0))<0:

                 #   return result_r_1

                 #elif is_number(str(simplify(expr2string1(result_r_1))))==True and simplify(expr2string1(result_r_1))<0:

                 #   return result_r_0

                 #else:

                 return ['or',result_r_0, result_r_1]

          elif result_r_0 is not None:


              x_new = copy.deepcopy(expr_stmt)

              result = simplify(expr2string1(expr_stmt[-1])+'-'+expr2string1(fun_exp))

              if "**" in str(result):

                 result=translatepowerToFun(str(result))

              expression=str(str('_SUM')+"="+str(result))

              fun_call_map={}

              parser = c_parser.CParser()

              ast = parser.parse("void test(){"+expression+";}")

              statement_temp=ast.ext[0].body.block_items[0]

              expr_left = expr_replace_power(eval(expressionCreator_C(statement_temp.lvalue)))

              expr_right = expr_replace_power(eval(expressionCreator_C(statement_temp.rvalue)))

              powerBase = getPowerBase(expr_right, constant)

              if powerBase is not None:

                 sum_val = eval("['-',"+str(base_expr_stmr[-1])+",['**',"+str(powerBase)+",['_Sum',['1'],['"+variable+"'],['_i'],['_C_i']]]]")

                 result_r_0 = expr_replace(result_r_0, base_expr_stmr[-1], sum_val)

                 #print(expr2string1(result_r_0))

                 return result_r_0
          else:
                 return None


def getRecForCondtion(e,condition):

    args=expr_args(e)

    op=expr_op(e)

    if op is not None:

       if op=='ite' and args[0]==condition:

          return args[1]

       if op in _infix_op and len(args)==2:

          return [op, getRecForCondtion(args[0],condition), getRecForCondtion(args[1],condition)]

       else:
       
          if len(args)==3:

             if 'ite' in args[1][0]:

                 return getRecForCondtion(args[1],condition)

             elif 'ite' in args[2][0]:

                 return getRecForCondtion(args[2],condition)

             else:
            
                 return args[2]
          else:
              return e
    else:

      return e


def isConditionalBody(axioms):

    for axiom in axioms:

        if axiom[0] == 'i1':
           
           if axiom[-1][0]=='ite':
              
              return True

    return False




def find_each_bound(x):

    isFunPrs = isFunctionPresent_Sm(x[-1][2])

    fun_map = isFunOnlyBigN(x[-1][2])

    if isFunPrs is None and len(fun_map)==0:


        if x[-1][2][0] == '<=' or x[-1][2][0] == '>=':

           x_new = copy.deepcopy(x[-1][2])
           x_new = expr_replace(x_new, x[-1][1][1], eval("['-'," + str(x[-1][1][2]) + ",['1']]"))
           x_new[1], x_new[2] = normalRearrange(x_new, x[-1][1][2])

           if x_new[2] is not None:

              temp_list = []
              #list_var_derived_val[x[-1][1][1][0]] = expr2string1(x_new[2])
              temp_list.append(x[-1][1][2])
              temp_list.append(x_new[1])
              temp_list.append(x_new[2])
              return temp_list

           else:

               x_new = copy.deepcopy(x[-1][2])
               x_new = expr_replace(x_new, x[-1][1][1], eval("['-'," + str(x[-1][1][2]) + ",['1']]"))
               x_new[1], x_new[2] = normalRearrangeWolfForm(x_new, x[-1][1][2])


               if x_new[2] is not None:

                  temp_list = []
                  #list_var_derived_val[x[-1][1][1][0]] = expr2string1(x_new[2])
                  temp_list.append(x[-1][1][2])
                  temp_list.append(x_new[1])
                  temp_list.append(x_new[2])
                  return temp_list


        elif x[-1][2][0] == '<' or x[-1][2][0] == '>':

             x_new = copy.deepcopy(x[-1][2])
             x_new = expr_replace(x_new, x[-1][1][1], x[-1][1][2])
             x_new[1], x_new[2] = normalRearrange(x_new, x[-1][1][2])

             if x_new[2] is not None:

                temp_list = []

                #list_var_derived_val[x[-1][1][1][0]] = expr2string1(x_new[2])
                temp_list.append(x[-1][1][2])
                temp_list.append(x_new[1])
                temp_list.append(x_new[2])
                return temp_list

             else:

                 x_new = copy.deepcopy(x[-1][2])
                 x_new = expr_replace(x_new, x[-1][1][1], x[-1][1][2])

                 x_new[1], x_new[2] = normalRearrangeWolfForm(x_new, x[-1][1][2])


                 if x_new[2] is not None:

                    temp_list = []
                    #list_var_derived_val[x[-1][1][1][0]] = expr2string1(x_new[2])
                    temp_list.append(x[-1][1][2])
                    temp_list.append(x_new[1])
                    temp_list.append(x_new[2])
                    return temp_list

    return None


def function_handling_nested(eq,axioms,final_bound_values):

             #fun_map = isFunOnlyBigN(eq[-1][2][1])
             fun_map = isFunOnlyBigN(eq[-1][2])

             temp_list=[]

             if isFunctionPresent_Sm(eq[-1][2][1]) is None and len(fun_map)>0:

                list_fun_axm=[] 

                list_fun_axm_base=[] 

                variable = None 

                for x in fun_map:
            
                    for y in axioms:

                       if y[0] == 'i0' and y[-2][0]==x:

                          list_fun_axm_base.append(y)

                       if y[0] == 'i1' and y[-2][0]==x:

                          y1 = copy.deepcopy(y)

                          variable=y1[2]

                          y1[-2] = expr_replace(y1[-2], ['+',[variable],['1']], ['1'])

                          y1[-1] = expr_replace(y1[-1], [variable], ['0'])

                          list_fun_axm.append(y1)

                          y2 = copy.deepcopy(y)

                          y2[-2] = expr_replace(y2[-2], ['+',[variable],['1']], ['2'])

                          y2[-1] = expr_replace(y2[-1], [variable], ['1'])

                          list_fun_axm.append(y2)

                          y3 = copy.deepcopy(y)

                          y3[-2] = expr_replace(y3[-2], ['+',[variable],['1']], ['3'])

                          y3[-1] = expr_replace(y3[-1], [variable], ['2'])

                          list_fun_axm.append(y3)


                if variable != eq[-1][-2][-2][0]:
                     
                   s1_new_0 = copy.deepcopy(eq)

                   s1_new_0[-1] = expr_replace(s1_new_0[-1], [variable], ['0'])

                   for x in reversed(list_fun_axm):

                      s1_new_0[-1] = expr_replace(s1_new_0[-1], x[-2], x[-1])

                   for x in list_fun_axm_base:

                      s1_new_0[-1] = expr_replace(s1_new_0[-1], x[-2], x[-1])

                   #print(wff2string1(s1_new_0))
                   temp = find_each_bound(s1_new_0)
                
                   if temp is not None:
                      #print(temp)
                      temp_list.append(temp)

                   s1_new_1 = copy.deepcopy(eq)

                   s1_new_1[-1] = expr_replace(s1_new_1[-1], [variable], ['1'])

                   for x in reversed(list_fun_axm):

                      s1_new_1[-1] = expr_replace(s1_new_1[-1], x[-2], x[-1])

                   for x in list_fun_axm_base:

                      s1_new_1[-1] = expr_replace(s1_new_1[-1], x[-2], x[-1])

                   for temp in temp_list:

                      s1_new_1[-1] = expr_replace(s1_new_1[-1], temp[-2], temp[-1])

                   #print(wff2string1(s1_new_1))
                   temp = find_each_bound(s1_new_1)
                
                   if temp is not None:
                      #print(temp)
                      temp_list.append(temp)


                   s1_new_2 = copy.deepcopy(eq)

                   s1_new_2[-1] = expr_replace(s1_new_2[-1], [variable], ['2'])

                   for x in reversed(list_fun_axm):

                      s1_new_2[-1] = expr_replace(s1_new_2[-1], x[-2], x[-1])

                   for x in list_fun_axm_base:

                      s1_new_2[-1] = expr_replace(s1_new_2[-1], x[-2], x[-1])

                   for temp in temp_list:

                      s1_new_2[-1] = expr_replace(s1_new_2[-1], temp[-2], temp[-1])

                   #print(wff2string1(s1_new_2))
                   temp = find_each_bound(s1_new_2)
                
                   if temp is not None:
                      #print(temp)
                      temp_list.append(temp)

                   if len(temp_list)==3:

                      if temp_list[0][-1]!=temp_list[1][-1] and temp_list[1][-1]==temp_list[2][-1]:

                         temp_list[0][-1]=['or', temp_list[0][-1], ['+', temp_list[1][-1],['1']]]

                         temp_list[0][0]=eq[-1][1][-1]

                         temp_list[0][1]=eq[-1][1][-1]

                         return temp_list[0]
                else:


                   if len(final_bound_values)==1:


                      if final_bound_values[0][-1][0]=='or':

                         s1_new_1 = copy.deepcopy(eq)

                         list_fun_axm_1 = copy.deepcopy(axioms)

                         list_fun_axm_1.append(s1_new_1)


                         f_axioms,o_axioms,a_axioms, const_map, closed_form = rec_solver_controlflow({},{},list_fun_axm_1)

                         for x in a_axioms:

                             if x[0]=='i1':

                                x[-1] = expr_replace(x[-1], final_bound_values[0][-2], final_bound_values[0][-1][-1])
                             


                         f_axioms,o_axioms,a_axioms, const_map, closed_form = rec_solver_controlflow({},{},a_axioms)

                         temp1 = find_each_bound(a_axioms[-1])

                         #if temp1 is not None:

                             #print('%%%%%%%%%%%%%%%%%%%%%%%%1')

                             #print(temp1)

                             #print('%%%%%%%%%%%%%%%%%%%%%%%%1')



                         s1_new_2 = copy.deepcopy(eq)

                         list_fun_axm_2 = copy.deepcopy(axioms)

                         list_fun_axm_2.append(s1_new_2)

                         for x in list_fun_axm_2:

                             if x[0]=='i1':

                                x[-1] = expr_replace(x[-1], final_bound_values[0][-2], final_bound_values[0][-1][-2])

                         f_axioms,o_axioms,a_axioms, const_map, closed_form = rec_solver_controlflow({},{},list_fun_axm_2+[s1_new_2])
                        
                         temp2 = find_each_bound(a_axioms[-1])

                         if temp2 is not None and temp1 is not None:

                             temp2[-1]=['or',temp1[-1],temp2[-1]]

                             #print('%%%%%%%%%%%%%%%%%%%%%%%%2')

                             #print(temp2)

                             #print('%%%%%%%%%%%%%%%%%%%%%%%%2')

                             return temp2

                         elif temp2 is not None:

                             return temp2

                      else:

                         s1_new_1 = copy.deepcopy(eq)

                         list_fun_axm_1 = copy.deepcopy(axioms)

                         list_fun_axm_1.append(s1_new_1)


                         f_axioms,o_axioms,a_axioms, const_map, closed_form = rec_solver_controlflow({},{},axioms)

                         for x in a_axioms:

                             if x[0]=='i1':

                                x[-1] = expr_replace(x[-1], final_bound_values[0][-2], final_bound_values[0][-1])

                         f_axioms,o_axioms,a_axioms, const_map, closed_form = rec_solver_controlflow({},{},a_axioms)

 
                         temp1 = find_each_bound(a_axioms[-1])

                         if temp1 is not None:

                             return temp1
                         




                   #s1_new = copy.deepcopy(smallest)

                   #axm_map = {}

                   #for x in final_bound_values:

                   #   for y in list_fun_axm:

                   #      y[-1] = expr_replace(y[-1], temp[-2], temp[-1])

                   #list_axioms_else.append(s1_new)

                   #


             else:

                    temp = find_each_bound(eq)

                    if temp is not None:

                       return temp













def controlFlowRefinement_Nest_Break(smallest, axioms, frames, cond_var_map, condition, final_bound_values):

       map_axioms = {}

       map_variable = {}

       list_axioms = []

       list_axioms_else = []

       for y in axioms:

           if y[0] == 'i1':

              y_new = copy.deepcopy(y)

              y_else_new = copy.deepcopy(y)

              if 'ite' in y_new[-1][0]:

                 y_new[-1] = y_new[-1][2]

                 y_else_new[-1] = y_else_new[-1][3]

              list_axioms.append(y_new)

              list_axioms_else.append(y_else_new)

           else:

              y_new = copy.deepcopy(y)

              y_else_new = copy.deepcopy(y)

              list_axioms.append(y_new)

              list_axioms_else.append(y_else_new)

       s1_new = copy.deepcopy(smallest)

       list_axioms.append(s1_new)

       f_axioms,o_axioms,a_axioms, const_map, closed_form = rec_solver_controlflow({},{},list_axioms)

       temp_list = []

       if a_axioms[-1][-1][2][0]=='and' or a_axioms[-1][-1][2][0]=='or':


          if a_axioms[-1][-1][-2][-2][0] in expr2string1(a_axioms[-1][-1][2][1]) and a_axioms[-1][-1][-2][-2][0] not in expr2string1(a_axioms[-1][-1][2][2]):

             a_axioms[-1][-1][2] = a_axioms[-1][-1][2][1]

             result = function_handling_nested( a_axioms[-1], a_axioms, final_bound_values)

             temp_list.append(result)


          elif a_axioms[-1][-1][-2][-2][0] not in expr2string1(a_axioms[-1][-1][2][1]) and a_axioms[-1][-1][-2][-2][0] in expr2string1(a_axioms[-1][-1][2][2]):

             a_axioms[-1][-1][2] = a_axioms[-1][-1][2][2]

             result = function_handling_nested( a_axioms[-1], a_axioms, final_bound_values)

             temp_list.append(result)


       else:


          result = function_handling_nested( a_axioms[-1], a_axioms, final_bound_values)

          temp_list.append(result)


       #for x in a_axioms:

       #    print(wff2string1(x))

       #print('#################################')

       s1_new = copy.deepcopy(smallest)

       list_axioms_else.append(s1_new)

       f_axioms,o_axioms,a_axioms, const_map, closed_form = rec_solver_controlflow({},{},list_axioms_else)

       if a_axioms[-1][-1][2][0]=='and' or a_axioms[-1][-1][2][0]=='or':

          if a_axioms[-1][-1][-2][-2][0] in expr2string1(a_axioms[-1][-1][2][1]) and a_axioms[-1][-1][-2][-2][0] not in expr2string1(a_axioms[-1][-1][2][2]):

             a_axioms[-1][-1][2] = a_axioms[-1][-1][2][1]

             result = function_handling_nested( a_axioms[-1], a_axioms, final_bound_values)

             temp_list.append(result)


          elif a_axioms[-1][-1][-2][-2][0] not in expr2string1(a_axioms[-1][-1][2][1]) and a_axioms[-1][-1][-2][-2][0] in expr2string1(a_axioms[-1][-1][2][2]):

             a_axioms[-1][-1][2] = a_axioms[-1][-1][2][2]

             result =  function_handling_nested( a_axioms[-1], a_axioms, final_bound_values)

             temp_list.append(result)


       else:


          result = function_handling_nested( a_axioms[-1], a_axioms, final_bound_values)

          temp_list.append(result)


       if len(temp_list)==2:
          

          temp_list[0][-1]=['or',temp_list[0][-1],temp_list[1][-1]]

          return temp_list[0]


       else:
          
          return temp_list[0]

       






def controlFlowRefinement_constant(smallest, axioms, frames, cond_var_map, condition, final_bound_values):

       map_axioms = {}

       map_variable = {}

       #print('-------------------------controlFlowRefinement_constant')

       for x in condition:           

           for y in axioms:

                if y[0] == 'i0':

                    if 'break' not in y[-2][0]:

                        y_new = copy.deepcopy(y)

                        y_new[-1] = getRecForCondtion(y_new[-1],condition[x])

                        if x in map_axioms:

                           list_axioms = map_axioms[x]

                           list_axioms.append(y_new)

                           map_axioms[x] = list_axioms

                        else:

                           list_axioms = []

                           list_axioms.append(y_new)

                           map_axioms[x] = list_axioms

                elif y[0] == 'i1':

                    if 'break_' not  in y[-2][0]:

                        y_new = copy.deepcopy(y)

                        map_variable[x]=y_new[2]

                        y_new[-1] = getRecForCondtion(y_new[-1],condition[x])

                        if x in map_axioms:

                           list_axioms = map_axioms[x]

                           list_axioms.append(y_new)

                           map_axioms[x] = list_axioms

                        else:

                           list_axioms = []

                           list_axioms.append(y_new)

                           map_axioms[x] = list_axioms

                else:

                        y_new = copy.deepcopy(y)

                        if x in map_axioms:

                           list_axioms = map_axioms[x]

                           list_axioms.append(y_new)

                           map_axioms[x] = list_axioms

                        else:

                           list_axioms = []

                           list_axioms.append(y_new)

                           map_axioms[x] = list_axioms

       for y in axioms:

           if y[0] == 'i0':

              if 'break' not in y[-2][0]:

                  y_new = copy.deepcopy(y)

                  y_new[-1] = getRecForCondtion(y_new[-1],[])
              

                  if 'else' in map_axioms:

                     list_axioms = map_axioms['else']

                     list_axioms.append(y_new)

                     map_axioms['else'] = list_axioms

                  else:

                     list_axioms = []

                     list_axioms.append(y_new)

                     map_axioms['else'] = list_axioms

           elif y[0] == 'i1':

              if 'break_' not  in y[-2][0]:

                  y_new = copy.deepcopy(y)

                  map_variable[x]=y_new[2]

                  y_new[-1] = getRecForCondtion(y_new[-1],[])


                  if 'else' in map_axioms:

                     list_axioms = map_axioms['else']

                     list_axioms.append(y_new)

                     map_axioms['else'] = list_axioms

                  else:

                     list_axioms = []

                     list_axioms.append(y_new)

                     map_axioms['else'] = list_axioms

              else:

                  y_new = copy.deepcopy(y)

                  if 'else' in map_axioms:

                     list_axioms = map_axioms['else']

                     list_axioms.append(y_new)

                     map_axioms['else'] = list_axioms

                  else:

                     list_axioms = []

                     list_axioms.append(y_new)

                     map_axioms['else'] = list_axioms

           else:

                y_new = copy.deepcopy(y)

                if 'else' in map_axioms:

                    list_axioms = map_axioms['else']

                    list_axioms.append(y_new)

                    map_axioms['else'] = list_axioms

                else:

                    list_axioms = []

                    list_axioms.append(y_new)

                    map_axioms['else'] = list_axioms



       temp_list = []

       temp_temp_list = []

       

       for x in map_axioms:  

           args=expr_args(smallest[-1][-1])

           op=expr_op(smallest[-1][-1])


           if op in _infix_op:

              map_axioms[x].append(copy.deepcopy(smallest))



              f_axioms,o_axioms,a_axioms, const_map, closed_form = rec_solver_controlflow({},{},map_axioms[x])

              temp = find_each_bound(a_axioms[-1])


              if temp is not None:

                 if len(temp_list)>0:

                    if temp_list[-1][-1]!=temp[-1]:

                       temp[-1]=['or',temp_list[-1][-1],temp[-1]]

                 temp_list.append(temp)

                 if len(temp_list) == len(map_axioms):
                 
                     return temp_list[-1]
              else:
 

                fun_map = isFunOnlyBigN(a_axioms[-1][-1][2])

                x_new = a_axioms[-1][-1][2]

                if x_new[0] == '<=' or x_new[0] == '>=':

                     if len(final_bound_values)==0:

                        x_new = expr_replace(x_new, a_axioms[-1][-1][1][1], eval("['-'," + str(a_axioms[-1][-1][1][2]) + ",['1']]"))

                        result = tempateAbstarctSum(x_new, a_axioms[-1][-1][1][2], fun_map, a_axioms, final_bound_values)
                        if result is not None:

                           temp_list = []

                           temp_list.append(a_axioms[-1][-1][1][2])

                           temp_list.append(a_axioms[-1][-1][1][2])

                           temp_list.append(result)

                           #print(temp_list)

                           #print("***********************")

                           return temp_list

                     else:


                        temp = function_handling_nested(a_axioms[-1], a_axioms,final_bound_values)

                        if temp is not None:

                           if len(temp_list)>0:

                              if temp_list[-1][-1]!=temp[-1]:

                                 temp[-1]=['or',temp_list[-1][-1],temp[-1]]

                           temp_list.append(temp)

                        if len(temp_list) == len(map_axioms):
                 
                             return temp_list[-1]
      

                elif x_new[0] == '<' or x_new[0] == '>':

                     if len(final_bound_values)==0:

                        x_new = expr_replace(x_new, a_axioms[-1][-1][1][1], a_axioms[-1][-1][1][2])

                        result = tempateAbstarctSum(x_new, a_axioms[-1][-1][1][2], fun_map, a_axioms, final_bound_values)
                        if result is not None:

                           temp_list = []

                           temp_list.append(a_axioms[-1][-1][1][2])

                           temp_list.append(a_axioms[-1][-1][1][2])

                           temp_list.append(result)

                           #print(temp_list)

                           #print("***********************")

                           return temp_list

                     else:

                        temp = function_handling_nested(a_axioms[-1], a_axioms,final_bound_values)

                        if temp is not None:

                           if len(temp_list)>0:

                              if temp_list[-1][-1]!=temp[-1]:

                                 temp[-1]=['or',temp_list[-1][-1],temp[-1]]

                           temp_list.append(temp)

                        if len(temp_list) == len(map_axioms):
                 
                             return temp_list[-1]


                        #return result


           elif op=='or' or op=='and':

               temp_temp_list = []

               
               for arg in args:

                   map_axioms_list = copy.deepcopy(map_axioms[x])

                   s1_new = copy.deepcopy(y)

                   s1_new[-1][-1] = arg

                   map_axioms_list.append(s1_new)
 

                   f_axioms,o_axioms,a_axioms, const_map, closed_form = rec_solver_controlflow({},{},map_axioms_list)

                   temp = find_each_bound(a_axioms[-1])

                   if temp is None:


                      if expr_find(a_axioms[-1][-1][1][1],a_axioms[-1][-1])==False:
                         temp=[]
                         temp.append(a_axioms[-1][-1][1][1])
                         temp.append(a_axioms[-1][-1][1][1])
                         temp.append(['-',['1']])

                         if len(temp_temp_list)>0:

                            if op=='and':

                               temp[-1]=['or' , temp_temp_list[-1][-1], temp[-1]]

                            else:

                               temp[-1]=['and' , temp_temp_list[-1][-1], temp[-1]]
                           
                         temp_temp_list.append(temp)


                   elif temp is not None:

                      if len(temp_temp_list)>0:

                         if op=='and':

                            temp[-1]=['or' , temp_temp_list[-1][-1], temp[-1]]

                         else:

                            temp[-1]=['and' , temp_temp_list[-1][-1], temp[-1]]


                      temp_temp_list.append(temp)


               if len(temp_temp_list)>0:
                   
                  if len(temp_list)>0:
                  
                      temp_temp_list[-1][-1]=['or',temp_temp_list[-1][-1],temp_list[-1][-1]]

                  temp_list.append(temp_temp_list[-1])

               if len(temp_list) == len(map_axioms):
                 
                   return temp_list[-1]






def isBreakCheck(axioms):

    status = False

    for y in axioms:

        if y[0] == 'i0':

           if 'break' in y[-2][0]:

               status= True
    return status





def isCrossCheck(function_type_map, if_type_map, else_type_map):

    result = all(element == list(function_type_map.values())[0] for element in list(function_type_map.values()))


    
    if result == True and len(function_type_map.values())>0:

       element = list(function_type_map.values())[0]

       if_type = list(if_type_map.values())

       else_type = list(else_type_map.values())
 
       if len(if_type)>1 and len(else_type)>1 and if_type[0]==element and if_type[1]=='constant' and else_type[1]==element and else_type[0]=='constant':

          #if len(function_type_map)==len(if_type_map) and len(function_type_map)==len(else_type_map):

          return True

       elif len(if_type)>1 and len(else_type)>1 and if_type[1]==element and if_type[0]=='constant' and else_type[0]==element and else_type[1]=='constant':

          #if len(function_type_map)==len(if_type_map) and len(function_type_map)==len(else_type_map):

          return True


    return False



def checkFlagValues(e,exp):

    args=expr_args(e)
    op=expr_op(e)
    if op=='ite':

       if args[1]!=exp:

          return args[0]

       else:

          if args[2]=='ite':

             checkFlagValues(args[2],exp)
     
          elif args[2]!=exp:
          
             return ['else']

    return None



def controlFlowRefinement_Condition_Based(axioms, smallest, cond_var_map, condition):

       list_axioms=[]

       for y in axioms:

           if y[0] == 'i0':

              if 'break' not in y[-2][0]:

                  y_new = copy.deepcopy(y)

                  y_new[-1] = getRecForCondtion(y_new[-1],condition)

                  list_axioms.append(y_new)
              
           elif y[0] == 'i1':

              if 'break_' not  in y[-2][0]:

                  y_new = copy.deepcopy(y)

                  y_new[-1] = getRecForCondtion(y_new[-1],condition)

                  list_axioms.append(y_new)

           else:

               y_new = copy.deepcopy(y)

               list_axioms.append(y_new)

       if smallest[-1][-2][0] in _infix_op:

              list_axioms.append(copy.deepcopy(smallest))


              f_axioms,o_axioms,a_axioms, const_map, closed_form = rec_solver_controlflow({},{},list_axioms)


              temp = find_each_bound(a_axioms[-1])


              if temp is not None:

                 return temp



def controlFlowCrossCheckCase1(condition, variable, constant, smallest_map, list_axioms, list_axioms_else):

      temp_list = []

      s1_new = ['s1',['implies',['<',[variable],[constant]], condition]]


      list_axioms.append(s1_new)


      f_axioms,o_axioms,a_axioms, const_map, closed_form = rec_solver_controlflow({},{}, list_axioms)

  

      temp = find_each_bound(a_axioms[-1])

      

      if temp is not None:


         temp_list.append(temp)

                   
         list_axioms_else_else = copy.deepcopy(list_axioms_else)


         for y in list_axioms_else:

             if y[0]=='i0':

                for z in closed_form:

                    if z[-2][0]==y[-2][0]:

                       y[-1] = z[-1]

                       y[-1] = expr_replace(y[-1], temp[-2], temp[-1])



         s1_new = ['s1',['implies',['<',[variable],[constant]],smallest_map[list(smallest_map.keys())[0]]]]

                   
         list_axioms_else.append(s1_new)

         list_axioms_else_else.append(copy.deepcopy(s1_new))


         f_axioms,o_axioms,a_axioms, const_map, closed_form = rec_solver_controlflow({},{}, list_axioms_else)


         args=expr_args(a_axioms[-1][-1][-1])

         op=expr_op(a_axioms[-1][-1][-1])


         if op in _infix_op:


            temp = find_each_bound(a_axioms[-1])


            if temp is not None:
                                         
               temp[-1]=['+',temp_list[-1][-1],temp[-1]]

               temp_list.append(temp)

               return temp

            else:

              if temp is None and variable not in expr2string1(a_axioms[-1][-1][-1]) and constant not in expr2string1(a_axioms[-1][-1][-1]):

                  temp = []

                  temp.append(temp_list[-1][-3])

                  temp.append(temp_list[-1][-2])

                  temp.append(temp_list[-1][-1])

                  return temp

         else:

             temp_temp_list=[]             

             for arg in args:
                 
                 smallest = copy.deepcopy(a_axioms[-1])

                 smallest[-1][-1] = arg


                 temp = find_each_bound(smallest)


                 if temp is not None:
                                         
                    temp[-1]=['+',temp_list[-1][-1],temp[-1]]

                    temp_list.append(temp)

                    if len(temp_temp_list)>0:

                       temp_temp_list[-1][-1]=[op, temp_temp_list[-1][-1], temp[-1]]

                    temp_temp_list.append(temp)

                    #return temp

                 else:

                    if temp is None and variable not in expr2string1(a_axioms[-1][-1][-1]) and constant not in expr2string1(a_axioms[-1][-1][-1]):

                       temp = []

                       temp.append(temp_list[-1][-3])

                       temp.append(temp_list[-1][-2])

                       temp.append(temp_list[-1][-1])

                       if len(temp_temp_list)>0:

                          temp_temp_list[-1][-1]=[op, temp_temp_list[-1][-1], temp[-1]]

                       temp_temp_list.append(temp)

                 #print(temp_temp_list)
                   

             if len(temp_temp_list)>0:

                return temp_temp_list[-1]
                




def controlFlowCrossCheckCase2(condition, variable, constant, smallest_map, list_axioms, list_axioms_else):

      temp_list = []

      s1_new = ['s1',['implies',['<',[variable],[constant]], condition ]]


      list_axioms.append(s1_new)


      f_axioms,o_axioms,a_axioms, const_map, closed_form = rec_solver_controlflow({},{}, list_axioms)


      temp = find_each_bound(a_axioms[-1])


      if temp is not None:


         temp_list.append(temp)

                   
         list_axioms_else_else = copy.deepcopy(list_axioms_else)


         for y in list_axioms_else:

             if y[0]=='i0':

                for z in closed_form:

                    if z[-2][0]==y[-2][0]:

                       y[-1] = z[-1]

                       y[-1] = expr_replace(y[-1], temp[-2], temp[-1])



         s1_new = ['s1',['implies',['<',[variable],[constant]],smallest_map[list(smallest_map.keys())[0]]]]

                   
         list_axioms_else.append(s1_new)

         list_axioms_else_else.append(copy.deepcopy(s1_new))

         f_axioms,o_axioms,a_axioms, const_map, closed_form = rec_solver_controlflow({},{}, list_axioms_else)


         temp = find_each_bound(a_axioms[-1])


         if temp is not None:
                                         
              temp[-1]=['+',temp_list[-1][-1],temp[-1]]

              temp_list.append(temp)

              if temp is not None:

                 f_axioms,o_axioms,a_axioms, const_map, closed_form = rec_solver_controlflow({},{}, list_axioms_else_else)
                 temp = find_each_bound(a_axioms[-1])

                 temp[-1]=['or',temp_list[-1][-1],temp[-1]]

                 return temp


         else:

              if temp is None and variable not in expr2string1(a_axioms[-1][-1][-1]) and cond_var_map[variable] not in expr2string1(a_axioms[-1][-1][-1]):

                  temp = []

                  temp.append(temp_list[-1][-3])

                  temp.append(temp_list[-1][-2])

                  temp.append(temp_list[-1][-1])

                  return temp








def controlFlowRefinement(axioms, frames, cond_var_map, condition, break_condition):

    if len(condition)==len(break_condition):  

       map_axioms = {}

       map_variable = {}


       for x in condition:           

           for y in axioms:

                if y[0] == 'i0':

                    if 'break' not in y[-2][0]:

                        y_new = copy.deepcopy(y)

                        y_new[-1] = getRecForCondtion(y_new[-1],condition[x])

                        if x in map_axioms:

                           list_axioms = map_axioms[x]

                           list_axioms.append(y_new)

                           map_axioms[x] = list_axioms

                        else:

                           list_axioms = []

                           list_axioms.append(y_new)

                           map_axioms[x] = list_axioms

                elif y[0] == 'i1':

                    if 'break_' not  in y[-2][0]:

                        y_new = copy.deepcopy(y)

                        map_variable[x]=y_new[2]

                        y_new[-1] = getRecForCondtion(y_new[-1],condition[x])

                        if x in map_axioms:

                           list_axioms = map_axioms[x]

                           list_axioms.append(y_new)

                           map_axioms[x] = list_axioms

                        else:

                           list_axioms = []

                           list_axioms.append(y_new)

                           map_axioms[x] = list_axioms
        


       prev_closed_form = None
       prev_big_N = None

       temp_list = []

       for x in map_axioms:  

           if prev_closed_form is not None: 

              for y in map_axioms[x]:

                  if y[0]=='i0':

                     for z in prev_closed_form:

                         if z[-2][0]==y[-2][0]:

                            y[-1] = z[-1]

           s1_new = ['s1',['implies',['<',[map_variable[x]],[cond_var_map[map_variable[x]]]],condition[x]]]

           map_axioms[x].append(s1_new)


           f_axioms,o_axioms,a_axioms, const_map, closed_form = rec_solver_controlflow({},{},map_axioms[x])


           temp = find_each_bound(a_axioms[-1])

           if temp is not None:

              for ax in closed_form:

                  ax[-1] = expr_replace(ax[-1], temp[-2], temp[-1])

              prev_closed_form = closed_form

              prev_big_N = temp[-2]

              if len(temp_list)>0:

                 temp[-1]=['+',temp_list[-1][-1],temp[-1]]

              temp_list.append(temp)

              if len(temp_list) == len(map_axioms):
                 
                 return temp_list[-1]

    elif  isConditionalBody(axioms)==True and len(condition)==1:

          smallest_map={}

          function_type_map={}

          if_type_map={}

          else_type_map={}

          is_Constant = True

          variable = None

          temp_list = []

          for axiom in axioms:

              if axiom[0] == 's1':

                 smallest_map[expr2string1(axiom[-1][2])]=axiom[-1][2]

          for x in condition:

              if condition[x][0]=='<' or condition[x][0]=='<=':

                 if is_number(expr2string1(condition[x][1])) or expr2string1(condition[x][1]) in list(frames.keys()):

                    function_type_map[condition[x][2][0]]='Decreasing'

                 elif is_number(expr2string1(condition[x][2])) or expr2string1(condition[x][2]) in list(frames.keys()):

                    function_type_map[condition[x][1][0]]='Increasing'


              elif condition[x][0]=='>' or condition[x][0]=='>=':

                 if is_number(expr2string1(condition[x][1])) or expr2string1(condition[x][1]) in list(frames.keys()):

                    function_type_map[condition[x][2][0]]='Increasing'

                 elif is_number(expr2string1(condition[x][2])) or expr2string1(condition[x][2]) in list(frames.keys()):

                    function_type_map[condition[x][1][0]]='Decreasing'


          for x in smallest_map:

              if smallest_map[x][0]=='<' or smallest_map[x][0]=='<=':

                 if is_number(expr2string1(smallest_map[x][1])) or expr2string1(smallest_map[x][1]) in list(frames.keys()):

                    function_type_map[smallest_map[x][2][0]]='Decreasing'

                 elif is_number(expr2string1(smallest_map[x][2])) or expr2string1(smallest_map[x][2]) in list(frames.keys()):

                    function_type_map[smallest_map[x][1][0]]='Increasing'


              elif smallest_map[x][0]=='>' or smallest_map[x][0]=='>=':

                 if is_number(expr2string1(smallest_map[x][1])) or expr2string1(smallest_map[x][1]) in list(frames.keys()):

                    function_type_map[smallest_map[x][2][0]]='Increasing'

                 elif is_number(expr2string1(smallest_map[x][2])) or expr2string1(smallest_map[x][2]) in list(frames.keys()):

                    function_type_map[smallest_map[x][1][0]]='Decreasing'


          list_axioms = []

          list_axioms_else = []


          for y in axioms:

              if y[0] == 'i0':

                 y_new = copy.deepcopy(y)

                 y_new_el = copy.deepcopy(y)

                 y_new[-1] = getRecForCondtion(y_new[-1],condition[list(condition.keys())[0]])

                 y_new_el[-1] = getRecForCondtion(y_new_el[-1],['not',condition[list(condition.keys())[0]]])

                 list_axioms.append(y_new)
                 list_axioms_else.append(y_new_el)

              elif y[0] == 'i1':

                  variable = y[2]

                  y_new = copy.deepcopy(y)

                  y_new_el = copy.deepcopy(y)

                  y_left = copy.deepcopy(y_new[-2])

                  y_left = expr_replace(y_left, ['+', [y_new[2]], ['1']], [y_new[2]])


                  y_new[-1] = getRecForCondtion(y_new[-1],condition[list(condition.keys())[0]])

                  y_new_el[-1] = getRecForCondtion(y_new_el[-1],['not',condition[list(condition.keys())[0]]])

                  if expr2string1(y_left) in expr2string1(y_new[-1]):

                     eq_axiom = simplify(expr2string1(y_new[-1])+'-'+expr2string1(y_left))

                     if is_number(str(eq_axiom))==True and eq_axiom>0:

                        if_type_map[y_new[-2][0]]='Increasing'

                     elif is_number(str(eq_axiom))==True and eq_axiom<0:

                        if_type_map[y_new[-2][0]]='Decreasing'

                     else:

                        for x in frames:

                           if x == str(eq_axiom):

                              if_type_map[y_new[-2][0]] ='Increasing'

                              break;

                           elif x == str(simplify("-1*"+str(eq_axiom))):

                              if_type_map[y_new[-2][0]] ='Decreasing'

                              break;

                           else:

                              if_type_map[y_new[-2][0]] ='constant'


                  elif is_number(expr2string1(y_new[-1]))==True:

                       if_type_map[y_new[-2][0]]='constant'

                  else:

                       if_type_map[y_new[-2][0]]='undecided'



                  if expr2string1(y_left) in expr2string1(y_new_el[-1]):

                     eq_axiom = simplify(expr2string1(y_new_el[-1])+'-'+expr2string1(y_left))

                     if is_number(str(eq_axiom))==True and eq_axiom>0:

                        else_type_map[y_new_el[-2][0]]='Increasing'

                     elif is_number(str(eq_axiom))==True and eq_axiom<0:

                        else_type_map[y_new_el[-2][0]]='Decreasing'

                     else:

                        for x in frames:

                           if x == str(eq_axiom):

                              else_type_map[y_new_el[-2][0]]='Increasing'

                              break;

                           elif x == str(simplify("-1*"+str(eq_axiom))):

                              else_type_map[y_new_el[-2][0]]='Decreasing'

                              break;

                           else:

                              else_type_map[y_new_el[-2][0]]='constant'

                  elif is_number(expr2string1(y_new_el[-1]))==True:

                       else_type_map[y_new_el[-2][0]]='constant'

                  else:

                       else_type_map[y_new_el[-2][0]]='undecided'

                  list_axioms_else.append(y_new_el)
                  list_axioms.append(y_new)

          #print(function_type_map) 

          #print(if_type_map)

          #print(else_type_map)   

          #print(isCrossCheck(function_type_map, if_type_map, else_type_map))


          if ( function_type_map==if_type_map) or isCrossCheck(function_type_map, if_type_map, else_type_map)==True:


             is_else_cont = None

             if list(else_type_map.values())==['constant','constant']:


                s1_new = ['s1',['implies',['<',[variable],[cond_var_map[variable]]],condition[list(condition.keys())[0]]]]


                list_axioms.append(s1_new)


                f_axioms,o_axioms,a_axioms, const_map, closed_form = rec_solver_controlflow({},{}, list_axioms)


                temp = find_each_bound(a_axioms[-1])


                if temp is not None:

                   return temp



             elif list(if_type_map.values()) == list(else_type_map.values()) or isCrossCheck(function_type_map, if_type_map, else_type_map)==True:

                #list_axioms_rev = copy.deepcopy(list_axioms)

                #list_axioms_else_rev = copy.deepcopy(list_axioms_else)

                #print(len(function_type_map))

                temp =  None
                if len(function_type_map)==0:


                   result = controlFlowCrossCheckCase1(condition[list(condition.keys())[0]], variable, cond_var_map[variable], smallest_map, copy.deepcopy(list_axioms), copy.deepcopy(list_axioms_else))
                   if result is not None:

                       temp = result

                       #return result

                   smallest = expr_complement(copy.deepcopy(condition[list(condition.keys())[0]]))

                   result = controlFlowCrossCheckCase1(smallest, variable, copy.deepcopy(cond_var_map[variable]), smallest_map, copy.deepcopy(list_axioms_else), copy.deepcopy(list_axioms))

                   if result is not None:

                       result[-1] = ['or', temp[-1], result[-1] ]

                       return result



                elif len(function_type_map)==1:

                   result = controlFlowCrossCheckCase1(condition[list(condition.keys())[0]], variable, cond_var_map[variable], smallest_map, copy.deepcopy(list_axioms), copy.deepcopy(list_axioms_else))
                   if result is not None:

                       temp = result

                       #return result

                   smallest = expr_complement(copy.deepcopy(condition[list(condition.keys())[0]]))

                   result = controlFlowCrossCheckCase1(smallest, variable, copy.deepcopy(cond_var_map[variable]), smallest_map, copy.deepcopy(list_axioms_else), copy.deepcopy(list_axioms))

                   if result is not None:

                       result[-1] = ['or', temp[-1], result[-1] ]

                       return result

                else:
                   result = controlFlowCrossCheckCase2(condition[list(condition.keys())[0]], variable, cond_var_map[variable], smallest_map, list_axioms, list_axioms_else)

                   if result is not None:

                       return result

             else:

                 print('works in progress')

          else:

               
               print('works in progress')
               temp = None

               for x in smallest_map:

                   left_exp=None

                   right_exp=None

                   flag_condition= None              

                   variable=None
     
                   if smallest_map[x][1]==['0'] or smallest_map[x][1]==['1']:
                      left_exp = smallest_map[x][1]
                   if smallest_map[x][2]==['0'] or smallest_map[x][1]==['1']:
                      right_exp = smallest_map[x][2]


                   fun_map = isFunOnlyBigN(smallest_map[x])
        


                   for y in axioms:

                      if y[0] == 'i1':

                         if y[-2][0] in fun_map:

                            variable=y[2]

                            if left_exp is not None:

                               flag_condition = checkFlagValues(y[-1],left_exp)

                            if right_exp is not None:

                               flag_condition = checkFlagValues(y[-1],right_exp)


                   if flag_condition is not None and variable is not None:

                      smallest = ['s1',['implies',['<',[variable],[cond_var_map[variable]]],flag_condition]]

                      t_temp = controlFlowRefinement_Condition_Based(axioms, smallest, cond_var_map, flag_condition)
                      if t_temp is not None:

                         if temp is not None:

                            temp[-1]=['or',t_temp[-1],temp[-1]]

                         else:

                            temp = t_temp

                            temp[-1]=['or',['1'],temp[-1]]


               if temp is not None:
                  return temp



def isOnlyAndOr(func_map):
    result = None 
    for xfun in func_map:
        if (xfun=='and' or xfun=='or') and (result is None or result!=False):
        
           result=True

        else:

           result=False

    return result


def solveEachCondition(e):

    args=expr_args(e[-1][-1])

    op=expr_op(e[-1][-1])

    list_bound_values=[]

    if op=='or' or op=='and':

       for arg in args:

          x = copy.deepcopy(e)

          x[-1][-1] = arg

          if x[-1][2][0] == '<=' or x[-1][2][0] == '>=' or x[-1][2][0] == '==':

             x_new = copy.deepcopy(x[-1][2])
             x_new = expr_replace(x_new, x[-1][1][1], eval("['-'," + str(x[-1][1][2]) + ",['1']]"))
             x_new[1], x_new[2] = normalRearrange(x_new, x[-1][1][2])

             if x_new[2] is not None:

                temp_list = []
                temp_list.append(x[-1][1][2])
                temp_list.append(x_new[1])
                if len(list_bound_values)>0:
                   if op=='and':
                      temp_list.append(['or',list_bound_values[-1][-1],x_new[2]])
                   else:
                      temp_list.append(['and',list_bound_values[-1][-1],x_new[2]])
                else:
                   temp_list.append(x_new[2])
                list_bound_values.append(temp_list)

             else:
                x_new = copy.deepcopy(x[-1][2])
                x_new = expr_replace(x_new, x[-1][1][1], eval("['-'," + str(x[-1][1][2]) + ",['1']]"))
                x_new[1], x_new[2] = normalRearrangeWolfForm(x_new, x[-1][1][2])


                if x_new[2] is not None:

                   temp_list = []
                   #list_var_derived_val[x[-1][1][1][0]] = expr2string1(x_new[2])
                   temp_list.append(x[-1][1][2])
                   temp_list.append(x_new[1])
                   if len(list_bound_values)>0:
                      if op=='and':

                         temp_list.append(['or',list_bound_values[-1][-1],x_new[2]])

                      else:

                         temp_list.append(['and',list_bound_values[-1][-1],x_new[2]])
                   else:
                      temp_list.append(x_new[2])

                   list_bound_values.append(temp_list)

          elif x[-1][2][0] == '<' or x[-1][2][0] == '>' or x[-1][2][0] == '!=':

               x_new = copy.deepcopy(x[-1][2])
               x_new = expr_replace(x_new, x[-1][1][1], x[-1][1][2])
               x_new[1], x_new[2] = normalRearrange(x_new, x[-1][1][2])

               if x_new[2] is not None:

                  temp_list = []

                  temp_list.append(x[-1][1][2])
                  temp_list.append(x_new[1])
                  if len(list_bound_values)>0:
                     if op=='and':
                        temp_list.append(['and',list_bound_values[-1][-1],x_new[2]])
                     else:
                        temp_list.append(['or',list_bound_values[-1][-1],x_new[2]])
                  else:
                     temp_list.append(x_new[2])
                  list_bound_values.append(temp_list)
               else:
                   x_new = copy.deepcopy(x[-1][2])
                   x_new = expr_replace(x_new, x[-1][1][1], x[-1][1][2])

                   x_new[1], x_new[2] = normalRearrangeWolfForm(x_new, x[-1][1][2])


                   if x_new[2] is not None:

                      temp_list = []
                      #list_var_derived_val[x[-1][1][1][0]] = expr2string1(x_new[2])
                      temp_list.append(x[-1][1][2])
                      temp_list.append(x_new[1])
                      if len(list_bound_values)>0:
                         if op=='and':
                            temp_list.append(['and',list_bound_values[-1][-1],x_new[2]])
                         else:

                            temp_list.append(['or',list_bound_values[-1][-1],x_new[2]])
                      else:
                         temp_list.append(x_new[2])
                      list_bound_values.append(temp_list)
    #print(list_bound_values)
    if len(list_bound_values)>0:
       return list_bound_values[-1]
    else:
       return None



def isSingleIeration(axioms, e):

    flag = None 

    for axiom in axioms:

        if (axiom[0]=='s1' or axiom[0]=='s0') and (flag is None or flag!=False):

           flag = True

        else:

           flag = False


    if flag== True:

          if expr_find(e[-1][-2][-2],e[-1][-1])==False:

             expr1 = e[-1][-1]
             
             expr2 = expr_complement(copy.deepcopy(e[-1][-1]))
         
             status1 = query2z3_update([], wff2z3_update(['s0',expr1]), [], '')

             status1 = status1.decode("utf-8")

             status2 = query2z3_update([], wff2z3_update(['s0',expr2]), [], '')

             status2 = status2.decode("utf-8")

             if 'Counter Example' in status1 and 'Successfully Proved' in status2:

                temp_list=[]
                temp_list.append(e[-1][-2][-1])
                temp_list.append(e[-1][-2][-1])
                temp_list.append(['1'])

                return temp_list

             return None

    return None


     

# expr_replace_power(e): replace all subterm ['**'] in e by ['power']

def expr_replace_op_power(e): #e: expr
    args=expr_args(e)
    op=expr_op(e)
    if len(args)>0:
        if op=='**' or '**' in op :
            return eval("['power']")+list(expr_replace_op_power(x) for x in expr_args(e))
        else:
            return e[:1]+list(expr_replace_op_power(x) for x in expr_args(e))
    else:
        return e

    




def prove_auto_strategy1(program, property, program_analysis, program_analysis_decl):
    start_time = current_milli_time()
    if program is None:
        print ('Something is Wrong')
        return
    if program is not None:
        for name in program.getAxiomeMap():
            axiom = program.getAxiomeMap()[name]
            witnessXml = program.getWitnessXmlMap()[name]
            main_axiom = getAll_Smallest_S0(axiom)
            base_case_values = []
            is_non_det_present=None
            condition_exp_map={}
            break_conditions_map={}
            contflow_condition_exp_map={}

            for x in axiom.getOther_axioms():

                x[-1]=expr_replace_op_power(x[-1])

            for x in axiom.getOutput_equations():

                axiom.getOutput_equations()[x][-1]=expr_replace_op_power(axiom.getOutput_equations()[x][-1])

                axiom.getOutput_equations()[x][-2]=expr_replace_op_power(axiom.getOutput_equations()[x][-2])

            for x in axiom.getFrame_axioms():

                axiom.getFrame_axioms()[x][-1]=expr_replace_op_power(axiom.getFrame_axioms()[x][-1])

                axiom.getFrame_axioms()[x][-2]=expr_replace_op_power(axiom.getFrame_axioms()[x][-1])


            for x in axiom.getOther_axioms_2():

                x[-1]=expr_replace_op_power(x[-1])

            for x in axiom.getOutput_equations_2():

                axiom.getOutput_equations_2()[x][-1]=expr_replace_op_power(axiom.getOutput_equations_2()[x][-1])

                axiom.getOutput_equations_2()[x][-2]=expr_replace_op_power(axiom.getOutput_equations_2()[x][-2])

            for x in axiom.getFrame_axioms_2():

                axiom.getFrame_axioms_2()[x][-1]=expr_replace_op_power(axiom.getFrame_axioms_2()[x][-1])

                axiom.getFrame_axioms_2()[x][-2]=expr_replace_op_power(axiom.getFrame_axioms_2()[x][-1])


            for x in axiom.getOther_axioms_3():

                x[-1]=expr_replace_op_power(x[-1])

            for x in axiom.getOutput_equations_3():

                axiom.getOutput_equations_3()[x][-1]=expr_replace_op_power(axiom.getOutput_equations_3()[x][-1])

                axiom.getOutput_equations_3()[x][-2]=expr_replace_op_power(axiom.getOutput_equations_3()[x][-2])

            for x in axiom.getFrame_axioms_3():

                axiom.getFrame_axioms_3()[x][-1]=expr_replace_op_power(axiom.getFrame_axioms_3()[x][-1])

                axiom.getFrame_axioms_3()[x][-2]=expr_replace_op_power(axiom.getFrame_axioms_3()[x][-1])


            for x in axiom.getAsserts():

               x[-1] = expr_replace_op_power(x[-1])

            for x in axiom.getAssumes():

               x[-1] = expr_replace_op_power(x[-1])

            for x in axiom.getAsserts_2():

               x[-1] = expr_replace_op_power(x[-1])

            for x in axiom.getAssumes_2():

               x[-1] = expr_replace_op_power(x[-1])

            for x in axiom.getAsserts_3():

               x[-1] = expr_replace_op_power(x[-1])

            for x in axiom.getAssumes_3():

               x[-1] = expr_replace_op_power(x[-1])



            post_condition={}

            for w in axiom.getAsserts():
                
                if w[-1][:1]==['ite']:

                   w[-1]=simplifyPostCondition(w[-1])

                if w[0]=='i1':

                   var_cstr_map={}
                   rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                   list_var_str=qualifier_list(var_cstr_map.keys())
                   list_cstr_str=cstr_list(var_cstr_map.values())
                   if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                           rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                   if list_var_str is not None and list_cstr_str is not None:
                      if w[0] == 'i1':

                         post_condition["ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))"]=w
                                                           
                      else:

                         post_condition['ForAll(['+list_var_str+'],'+rhs+")"]=w

                   else:
                        post_condition[rhs]=w
                                    
                elif w[0]=='c1':

                     var_cstr_map={}
                     rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                     list_var_str=qualifier_list(var_cstr_map.keys())
                     list_cstr_str=cstr_list(var_cstr_map.values())
                     if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                           rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                           if list_var_str is not None and list_cstr_str is not None:

                              if w[0] == 'i1':

                                 post_condition["ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))"]=w
                                                            
                              else:

                                 post_condition['ForAll(['+list_var_str+'],'+rhs+")"]=w
                           else:

                               post_condition[rhs]=w
                else:
                    if w[0]!='i0':
                       var_cstr_map={}
                       rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                       list_var_str=qualifier_list(var_cstr_map.keys())
                       list_cstr_str=cstr_list(var_cstr_map.values())
                       if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                           rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                       if list_var_str is not None and list_cstr_str is not None:
                          if w[0] == 'i1':
                             post_condition["ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))"]=w
                                                                  
                          else:
                             post_condition['ForAll(['+list_var_str+'],'+rhs+")"]=w
                       else:
                          post_condition[rhs]=w


            post_condition_2={}

            for w in axiom.getAsserts_2():
                
                if w[-1][:1]==['ite']:

                   w[-1]=simplifyPostCondition(w[-1])

                if w[0]=='i1':

                   var_cstr_map={}
                   rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                   list_var_str=qualifier_list(var_cstr_map.keys())
                   list_cstr_str=cstr_list(var_cstr_map.values())
                   if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                           rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                   if list_var_str is not None and list_cstr_str is not None:
                      if w[0] == 'i1':

                         post_condition_2["ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))"]=w
                                                           
                      else:

                         post_condition_2['ForAll(['+list_var_str+'],'+rhs+")"]=w

                   else:
                        post_condition_2[rhs]=w
                                    
                elif w[0]=='c1':

                     var_cstr_map={}
                     rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                     list_var_str=qualifier_list(var_cstr_map.keys())
                     list_cstr_str=cstr_list(var_cstr_map.values())
                     if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                           rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                           if list_var_str is not None and list_cstr_str is not None:

                              if w[0] == 'i1':

                                 post_condition_2["ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))"]=w
                                                            
                              else:

                                 post_condition_2['ForAll(['+list_var_str+'],'+rhs+")"]=w
                           else:

                               post_condition_2[rhs]=w
                else:
                    if w[0]!='i0':
                       var_cstr_map={}
                       rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                       list_var_str=qualifier_list(var_cstr_map.keys())
                       list_cstr_str=cstr_list(var_cstr_map.values())
                       if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                           rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                       if list_var_str is not None and list_cstr_str is not None:
                          if w[0] == 'i1':
                             post_condition_2["ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))"]=w
                                                                  
                          else:
                             post_condition_2['ForAll(['+list_var_str+'],'+rhs+")"]=w
                       else:
                          post_condition_2[rhs]=w


            post_condition_3={}

            for w in axiom.getAsserts_3():
                
                if w[-1][:1]==['ite']:

                   w[-1]=simplifyPostCondition(w[-1])

                if w[0]=='i1':

                   var_cstr_map={}
                   rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                   list_var_str=qualifier_list(var_cstr_map.keys())
                   list_cstr_str=cstr_list(var_cstr_map.values())
                   if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                           rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                   if list_var_str is not None and list_cstr_str is not None:
                      if w[0] == 'i1':

                         post_condition_3["ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))"]=w
                                                           
                      else:

                         post_condition_3['ForAll(['+list_var_str+'],'+rhs+")"]=w

                   else:
                        post_condition_3[rhs]=w
                                    
                elif w[0]=='c1':

                     var_cstr_map={}
                     rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                     list_var_str=qualifier_list(var_cstr_map.keys())
                     list_cstr_str=cstr_list(var_cstr_map.values())
                     if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                           rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                           if list_var_str is not None and list_cstr_str is not None:

                              if w[0] == 'i1':

                                 post_condition_3["ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))"]=w
                                                            
                              else:

                                 post_condition_3['ForAll(['+list_var_str+'],'+rhs+")"]=w
                           else:

                               post_condition_3[rhs]=w
                else:
                    if w[0]!='i0':
                       var_cstr_map={}
                       rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                       list_var_str=qualifier_list(var_cstr_map.keys())
                       list_cstr_str=cstr_list(var_cstr_map.values())
                       if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                           rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                       if list_var_str is not None and list_cstr_str is not None:
                          if w[0] == 'i1':
                             post_condition_3["ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))"]=w
                                                                  
                          else:
                             post_condition_3['ForAll(['+list_var_str+'],'+rhs+")"]=w
                       else:
                          post_condition_3[rhs]=w


            #print(post_condition)

            #print(post_condition_2)

            #print(post_condition_3)


            for p_condition in post_condition.keys():

                axiom.setAsserts((p_condition,post_condition[p_condition]))

                status=prove_assert_tactic1(axiom,witnessXml)

                list_dis_info = program.getDispalyMapInfo()['1MOM']

                list_dis_info.append(status)


            for p_condition in post_condition_2.keys():

                axiom.setAsserts_2((p_condition,post_condition_2[p_condition]))

                status=prove_assert_tactic1_2(axiom,witnessXml)

                list_dis_info = program.getDispalyMapInfo()['2MOM']

                list_dis_info.append(status)


            for p_condition in post_condition_3.keys():

                axiom.setAsserts_3((p_condition,post_condition_3[p_condition]))

                status=prove_assert_tactic1_3(axiom,witnessXml)

                list_dis_info = program.getDispalyMapInfo()['3MOM']

                list_dis_info.append(status)


        return program.getDispalyMapInfo()
        #for name in program.getDispalyMapInfo():

        #    list_dis_info = program.getDispalyMapInfo()[name]

        #    for x in list_dis_info:

        #        print(x)
        













     

       

        
                                

                                

def polyDegreeExpression(e,list_degree):

    args=expr_args(e)

    op=expr_op(e)

    if op=='or' or op=='and':

       if args[0][0]=='or' or args[0][0]=='and':

          polyDegreeExpression(args[0],list_degree)

       else:

          expression=expr2string1(args[0])

          if is_number(expression)==True:

             if simplify(expression)==1:

               list_degree.append(0)

             else:

               list_degree.append(1)

          elif 'sqrt' in str(expression):

             list_degree.append(0.5)

          else:

             list_degree.append(max(degree_list(expression)))



       if args[1][0]=='or' or args[1][0]=='and':

          polyDegreeExpression(args[1],list_degree)

       else:

          expression=expr2string1(args[0])

          if is_number(expression)==True:

             if simplify(expression)==1:

               list_degree.append(0)

             else:

               list_degree.append(1)

          elif 'sqrt' in str(expression):

             list_degree.append(0.5)

          else:

             list_degree.append(max(degree_list(expression)))






    







                

def caseAnalysisFindTheComplexity(loop_info_list, index, axiom):
    
    list_of_info = loop_info_list[index]
    
    
    condition_map_to_prove = list_of_info[5]
    
    list_break_non_return = list_of_info[8]
    
    list_break_return  = list_of_info[9]
    
    x_break_conditon_map = list_of_info[3]
        
    temp_all_solution_information =None
    
    if len(list_of_info)==11:
        
        temp_all_solution_information = list_of_info[10]
        
    
    ec_rec_equ_list  = list_of_info[0]
    
    var = list_of_info[6]
    
    const_list = list_of_info[7]
    
    const_in = copy.deepcopy(const_list)
    
    const_in[0]=const_in[0].replace('_N','_CE')
    
    variables_list=[]
    
    constant_list=[]
    
    constraint_list=[]
    
    base_values={}
    
    all_solution_information=[]
    
    for e in loop_info_list:
        
        variables_list.append(e[6])
        
        constant_list.append(e[7])
        
        
        for p_e in e[0]:
                                        
            constraint_list.append(wff2z3_update(p_e))
            
    if len(condition_map_to_prove) > 0:
                
        for key in condition_map_to_prove:
            
            list_seq_cond = []
                                
            ec = condition_map_to_prove[key]
                                
            ec_base= copy.deepcopy(ec)
                                
            ec_base = expr_replace(ec_base, eval("['" + var + "']"), eval("['0']"))
                                
            for p_var in variables_list:
                                    
                ec_base = expr_replace(ec_base, eval("['" + p_var + "']"), eval("['0']"))
                                    
                                        
            status = query2z3_update(constraint_list, wff2z3_update(eval("['a',"+str(ec_base)+"]")), axiom.getVfact(), '')
            status = status.decode("utf-8")
            if 'Successfully Proved' in status:
                
                if temp_all_solution_information is  None:
                
                    ec_rec_equ_list1 =[]
                
                    for e in ec_rec_equ_list:

                        e_new = copy.deepcopy(e)
                
                        result = getTheExpressionCond(e_new[-1], ec)
                                        
                        if result is not None:
                                            
                            e_new[-1] = result
                            
                        else:
                            if e_new[0]=='i1':
                                            
                                e_new[-1] = expr_replace(copy.deepcopy(e_new[-2]), eval("['+',['" + var + "'],['1']]"), eval("['" + var + "']"))
                                            
                                ec_rec_equ_list2.append(e_new)

                        
                        ec_rec_equ_list1.append(e_new)
                                            
                    results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)
                    

                    
                    if len(results)==0:
                    
                        solution_list=[]
                    
                        solution_list_init=[]
                    
                        e_c_s1=eval("['implies',"+"['and',"+"['<=',['0'],['"+var+"']],"+"['<',['"+var+"'],"+str(const_in)+"]"+"],"+str(ec)+"]")
                    
                        #print  expr2string1(e_c_s1)   
                    
                        e_c_s2=expr_complement(copy.deepcopy(ec))
                    
                        e_c_s2 =expr_replace(e_c_s2, eval("['" + var + "']"), const_in)
                    
                        #print  expr2string1(e_c_s2)

                    
                        for key in soln_map:
                        
                            e_sol = copy.deepcopy(soln_map[key])
                        
                            e_sol_cont = copy.deepcopy(soln_map[key])
                                                
                            e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                            e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                
                            solution_list.append(soln_map[key])
                        
                            solution_list.append(e_sol)
                        
                            e_sol_cont[-2] = expr_replace(e_sol_cont[-2], eval("['" + var + "']"),  eval("['0']"))
                        
                            e_sol_cont[-1] = expr_replace(e_sol_cont[-1], eval("['" + var + "']"), const_in)
                        
                            e_sol_cont= eval("['i0',0,"+str(e_sol_cont[-2] )+","+str(e_sol_cont[-1] )+"]")
                        
                            solution_list_init.append(e_sol_cont)
                        
                        #Check for None Return Condition
                        if len(solution_list_init)>0:
        
                            for e_c in list_break_non_return:
                            
                                solution_information=[]
                            
                                solution_list=[]
                            
                                smallest_con_list=[]
                            
                                ec_rec_equ_list2 =[]
                
                                for e in ec_rec_equ_list:
                    
                                    e_new = copy.deepcopy(e)
                
                                    result = getTheExpressionCond(e_new[-1], e_c)
                                        
                                    if result is not None:
                                            
                                        e_new[-1] = result
                                
                                        ec_rec_equ_list2.append(e_new)
                                        
                                    else:
                                        
                                        if e_new[0]=='i1':
                                            
                                            e_new[-1] = expr_replace(copy.deepcopy(e_new[-2]), eval("['+',['" + var + "'],['1']]"), eval("['" + var + "']"))
                                            
                                            ec_rec_equ_list2.append(e_new)
                                    
                                    
                                for e in solution_list_init:
                                
                                    e_new = copy.deepcopy(e)
                                
                                    ec_rec_equ_list2.append(e_new)
                                    
                                results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list2)

                                for key in soln_map:
                                    
                                    soln_map[key][-1] = expr_replace(soln_map[key][-1], eval("['" + var + "']"), eval("['1']"))
                                    
                                    e_sol = copy.deepcopy(soln_map[key])
                                                                        
                                    e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                                    e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)

                                    solution_list.append(soln_map[key])
                                    solution_list.append(e_sol)
                            
                                e_c_s3=copy.deepcopy(e_c)
                    
                                e_c_s3 =expr_replace(e_c_s3, eval("['" + var + "']"), const_in)
                            
                                smallest_con_list.append(e_c_s1)
                            
                                smallest_con_list.append(e_c_s2)
                            
                                smallest_con_list.append(e_c_s3)
                                
                                smallest_con_list.append(eval("['==',"+str(const_list)+",['+',"+str(const_in)+",['1']]]"))
                            
                                solution_information.append(solution_list)
                            
                                solution_information.append(smallest_con_list)
                                
                                solution_information.append(getBreakFunctionName(x_break_conditon_map, e_c))
                            
                            
                                all_solution_information.append(solution_information)
                else:
                    for x_solution_information in temp_all_solution_information:
                        
                        x_solution_list = x_solution_information[0]
                        
                        x_smallest_con_list = x_solution_information[1]    
                
                        ec_rec_equ_list1 =[]
                
                        for e in ec_rec_equ_list:
                    
                            e_new = copy.deepcopy(e)
                
                            result = getTheExpressionCond(e_new[-1], ec)
                                        
                            if result is not None:
                                
                                for x in x_solution_list:
                                    
                                    result =expr_replace(result, x[-2], x[-1])
                                            
                                e_new[-1] = result
                            else:
                                    if e_new[0]=='i1':
                                            
                                        e_new[-1] = expr_replace(copy.deepcopy(e_new[-2]), eval("['+',['" + var + "'],['1']]"), eval("['" + var + "']"))
                            ec_rec_equ_list1.append(e_new)
                                            
                        results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)
                
                        if len(results)==0:
                    
                            solution_list=[]
                    
                            solution_list_init=[]
                    
                            e_c_s1=eval("['implies',"+"['and',"+"['<=',['0'],['"+var+"']],"+"['<',['"+var+"'],"+str(const_in)+"]"+"],"+str(ec)+"]")
                    
                            #print  expr2string1(e_c_s1)   
                    
                            e_c_s2=expr_complement(copy.deepcopy(ec))
                    
                            e_c_s2 =expr_replace(e_c_s2, eval("['" + var + "']"), const_in)
                    
                            #print  expr2string1(e_c_s2)

                    
                            for key in soln_map:
                        
                                e_sol = copy.deepcopy(soln_map[key])
                        
                                e_sol_cont = copy.deepcopy(soln_map[key])
                                                
                                e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                                e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                
                                solution_list.append(soln_map[key])
                        
                                solution_list.append(e_sol)
                        
                                e_sol_cont[-2] = expr_replace(e_sol_cont[-2], eval("['" + var + "']"),  eval("['0']"))
                        
                                e_sol_cont[-1] = expr_replace(e_sol_cont[-1], eval("['" + var + "']"), const_in)
                        
                                e_sol_cont= eval("['i0',0,"+str(e_sol_cont[-2] )+","+str(e_sol_cont[-1] )+"]")
                        
                                solution_list_init.append(e_sol_cont)
                        
                            #Check for None Return Condition
                            if len(solution_list_init)>0:
        
                                for e_c in list_break_non_return:
                            
                                    solution_information=[]
                            
                                    solution_list=[]
                            
                                    smallest_con_list=[]
                            
                                    ec_rec_equ_list2 =[]
                
                                    for e in ec_rec_equ_list:
                    
                                        e_new = copy.deepcopy(e)
                
                                        result = getTheExpressionCond(e_new[-1], e_c)
                                        
                                        if result is not None:
                                            
                                            for x in x_solution_list:
                                                
                                                result =expr_replace(result, x[-2], x[-1])

                                                
                                            e_new[-1] = result
                                
                                            ec_rec_equ_list2.append(e_new)
                                            
                                        else:
                                            if e_new[0]=='i1':
                                                
                                                e_new[-1] = expr_replace(copy.deepcopy(e_new[-2]), eval("['+',['" + var + "'],['1']]"), eval("['" + var + "']"))
                                                
                                                ec_rec_equ_list2.append(e_new)
                                            
                                    
                                    for e in solution_list_init:
                                
                                        e_new = copy.deepcopy(e)
                                
                                        ec_rec_equ_list2.append(e_new)
                                
                                    results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list2)
                            
                                    for key in soln_map:
                                
                                        soln_map[key][-1] = expr_replace(soln_map[key][-1], eval("['" + var + "']"), eval("['1']"))
                                        
                                        e_sol = copy.deepcopy(soln_map[key])
                                                                        
                                        e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                                        e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)

                                        solution_list.append(soln_map[key])
                                
                                        solution_list.append(e_sol)
                            
                                    e_c_s3=copy.deepcopy(e_c)
                    
                                    e_c_s3 =expr_replace(e_c_s3, eval("['" + var + "']"), const_in)
                            
                                    smallest_con_list.append(e_c_s1)
                            
                                    smallest_con_list.append(e_c_s2)
                            
                                    smallest_con_list.append(e_c_s3)
                                    
                                    smallest_con_list.append(eval("['==',"+str(const_list)+",['+',"+str(const_in)+",['1']]]"))
                                    
                            
                                    solution_information.append(solution_list)
                            
                                    solution_information.append(smallest_con_list+x_smallest_con_list+x_solution_list)
                                    
                                    solution_information.append(getBreakFunctionName(x_break_conditon_map, e_c))
                            
                                    all_solution_information.append(solution_information)

            else:
                if temp_all_solution_information is  None:
                    
                    init_count = 0
                    
                    ec_rec_equ_list1 =[]
                
                    for e in ec_rec_equ_list:
                    
                        e_new = copy.deepcopy(e)
                
                        result = getTheExpressionCond(e_new[-1], ec)
                                        
                        if result is not None:
                                            
                            e_new[-1] = result
                        
                        else:
                        
                            if e_new[0]=='i0':
                            
                                init_count = init_count+1
                            
                                base_values["_CV"+str(init_count)] = e_new[-1] 

                                e_new[-1] = eval("['_CV"+str(init_count)+"']")
                                
                            if e_new[0]=='i1':
                                
                                e_new[-1] = expr_replace(copy.deepcopy(e_new[-2]), eval("['+',['" + var + "'],['1']]"), eval("['" + var + "']"))
                            
                        
                        ec_rec_equ_list1.append(e_new)
                                            
                    results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)
                
                    if len(results)==0:
                    
                        solution_list=[]
                    
                        solution_list_init=[]
                    
                        e_c_s1=eval("['implies',"+"['and',"+"['<=',['0'],['"+var+"']],"+"['<',['"+var+"'],"+str(const_in)+"]"+"],"+str(ec)+"]")
                    
                        #print  expr2string1(e_c_s1)   
                    
                        e_c_s2=expr_complement(copy.deepcopy(ec))
                    
                        e_c_s2 =expr_replace(e_c_s2, eval("['" + var + "']"), const_in)
                    
                        #print  expr2string1(e_c_s2)

                    
                        for key in soln_map:
                        
                            e_sol = copy.deepcopy(soln_map[key])
                        
                            e_sol_cont = copy.deepcopy(soln_map[key])
                                                
                            e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                            e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                
                            solution_list.append(soln_map[key])
                        
                            solution_list.append(e_sol)
                        
                            e_sol_cont[-2] = expr_replace(e_sol_cont[-2], eval("['" + var + "']"),  eval("['0']"))
                        
                            e_sol_cont[-1] = expr_replace(e_sol_cont[-1], eval("['" + var + "']"), const_in)
                        
                            e_sol_cont= eval("['i0',0,"+str(e_sol_cont[-2] )+","+str(e_sol_cont[-1] )+"]")
                        
                            solution_list_init.append(e_sol_cont)
                
                            #print  expr2string1(soln_map[key][-1])
                            #print  expr2string1(e_sol[-1])
                            #print  expr2string1(e_sol_cont[-1])
                        
                        #Check for None Return Condition
                        if len(solution_list_init)>0:
                            
                            for e_c in list_break_non_return:
                            
                                solution_information=[]
                            
                                solution_list=[]
                            
                                smallest_con_list=[]
                            
                                ec_rec_equ_list2 =[]
                
                                for e in ec_rec_equ_list:
                    
                                    e_new = copy.deepcopy(e)
                
                                    result = getTheExpressionCond(e_new[-1], e_c)
                                        
                                    if result is not None:
                                            
                                        e_new[-1] = result
                                
                                        ec_rec_equ_list2.append(e_new)
                                    
                                for e in solution_list_init:
                                
                                    e_new = copy.deepcopy(e)
                                
                                    ec_rec_equ_list2.append(e_new)
                                
                                results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list2)
                                
                                for key in soln_map:
                                
                    
                                
                                    soln_map[key][-1] = expr_replace(soln_map[key][-1], eval("['" + var + "']"), eval("['1']"))
                                    
                                    e_sol = copy.deepcopy(soln_map[key])
                                                                        
                                    e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                                    e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)

                                    solution_list.append(soln_map[key])
                                
                                    solution_list.append(e_sol)
                            
                                e_c_s3=copy.deepcopy(e_c)
                    
                                e_c_s3 =expr_replace(e_c_s3, eval("['" + var + "']"), const_in)
                                
                            
                                smallest_con_list.append(e_c_s1)
                            
                                smallest_con_list.append(e_c_s2)
                            
                                smallest_con_list.append(e_c_s3)
                                
                                smallest_con_list.append(eval("['==',"+str(const_list)+",['+',"+str(const_in)+",['1']]]"))
                                
                                #smallest_con_list.append(ec_base)
                                

                            
                                solution_information.append(solution_list)
                                
                                solution_information.append(smallest_con_list)
                                
                                solution_information.append(getBreakFunctionName(x_break_conditon_map, e_c))
                                
                                
                            
                                all_solution_information.append(solution_information)
                else:
                    
                     for x_solution_information in temp_all_solution_information:
                        
                        init_count = 0
                        
                        x_solution_list = x_solution_information[0]
                        
                        x_smallest_con_list = x_solution_information[1]    
                       
                        ec_rec_equ_list1 =[]
                
                        for e in ec_rec_equ_list:
                    
                            e_new = copy.deepcopy(e)
                                                    
                            result = getTheExpressionCond(e_new[-1], ec)
                        
                                        
                            if result is not None:
                                
                                for x in x_solution_list:
                                
                                    result =expr_replace(result, x[-2], x[-1])
                                            
                                e_new[-1] = result
                        
                            else:
                                #Need to Plug more path
                                #if e_new[0]=='i0':
                            
                                #    init_count = init_count+1
                            
                                #    base_values["_CV"+str(init_count)] = e_new[-1] 

                                #    e_new[-1] = eval("['_CV"+str(init_count)+"']")
                                    
                                if e_new[0]=='i1':
                                    
                                    e_new[-1] = expr_replace(copy.deepcopy(e_new[-2]), eval("['+',['" + var + "'],['1']]"), eval("['" + var + "']"))
                            #print wff2string1(e_new)
                            ec_rec_equ_list1.append(e_new)
                        
                        results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)
            
                        if len(results)==0:
                    
                            solution_list=[]
                    
                            solution_list_init=[]
                    
                            e_c_s1=eval("['implies',"+"['and',"+"['<=',['0'],['"+var+"']],"+"['<',['"+var+"'],"+str(const_in)+"]"+"],"+str(ec)+"]")
                    
                            #print  expr2string1(e_c_s1)   
                    
                            e_c_s2=expr_complement(copy.deepcopy(ec))
                    
                            e_c_s2 =expr_replace(e_c_s2, eval("['" + var + "']"), const_in)
                    
                            #print  expr2string1(e_c_s2)

                    
                            for key in soln_map:
                        
                                e_sol = copy.deepcopy(soln_map[key])
                        
                                e_sol_cont = copy.deepcopy(soln_map[key])
                                                
                                e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                                e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                
                                solution_list.append(soln_map[key])
                        
                                solution_list.append(e_sol)
                        
                                e_sol_cont[-2] = expr_replace(e_sol_cont[-2], eval("['" + var + "']"),  eval("['0']"))
                        
                                e_sol_cont[-1] = expr_replace(e_sol_cont[-1], eval("['" + var + "']"), const_in)
                        
                                e_sol_cont= eval("['i0',0,"+str(e_sol_cont[-2] )+","+str(e_sol_cont[-1] )+"]")
                        
                                solution_list_init.append(e_sol_cont)
                
                                #print  expr2string1(soln_map[key][-1])
                                #print  expr2string1(e_sol[-1])
                                #print  expr2string1(e_sol_cont[-1])
                        
                            #Check for None Return Condition
                            if len(solution_list_init)>0:
                            
                                for e_c in list_break_non_return:
                            
                                    solution_information=[]
                            
                                    solution_list=[]
                            
                                    smallest_con_list=[]
                            
                                    ec_rec_equ_list2 =[]
                
                                    for e in ec_rec_equ_list:

                                        e_new = copy.deepcopy(e)
                
                                        result = getTheExpressionCond(e_new[-1], e_c)
                                        
                                        if result is not None:
                                            
                                            for x in x_solution_list:
                                                
                                                result =expr_replace(result, x[-2], x[-1])
                                                
                                            e_new[-1] = result
                                            
                                            ec_rec_equ_list2.append(e_new)
                                            
                                        else:
                                            if e_new[0]=='i1':
                                            
                                                e_new[-1] = expr_replace(copy.deepcopy(e_new[-2]), eval("['+',['" + var + "'],['1']]"), eval("['" + var + "']"))
                                                
                                                ec_rec_equ_list2.append(e_new)

                                    
                                    for e in solution_list_init:
                                
                                        e_new = copy.deepcopy(e)
                                
                                        ec_rec_equ_list2.append(e_new)
                                
                                    results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list2)
                                    
                                    for key in soln_map:
                                
                                        soln_map[key][-1] = expr_replace(soln_map[key][-1], eval("['" + var + "']"), eval("['1']"))
                                        
                                        e_sol = copy.deepcopy(soln_map[key])
                                                                        
                                        e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                                        e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)

                                        solution_list.append(soln_map[key])
                                
                                        solution_list.append(e_sol)
                            
                                    e_c_s3=copy.deepcopy(e_c)
                    
                                    e_c_s3 =expr_replace(e_c_s3, eval("['" + var + "']"), const_in)
                            
                                    smallest_con_list.append(e_c_s1)
                            
                                    smallest_con_list.append(e_c_s2)
                            
                                    smallest_con_list.append(e_c_s3)
                                    
                                    smallest_con_list.append(eval("['==',"+str(const_list)+",['+',"+str(const_in)+",['1']]]"))
                                    
                                    #smallest_con_list.append(ec_base)
                                    

                                    solution_information.append(solution_list)
                                
                                    solution_information.append(smallest_con_list+x_smallest_con_list+x_solution_list)
                                    
                                    solution_information.append(getBreakFunctionName(x_break_conditon_map, e_c))
                            
                                    all_solution_information.append(solution_information)
    else:
        if temp_all_solution_information is  None:
            
            ec_rec_equ_list1 =[]
            
            for e in ec_rec_equ_list:
                
                e_new = copy.deepcopy(e)
                                                                                        
                ec_rec_equ_list1.append(e_new)
                
            results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)
            
            if len(results)==0:
                    
                solution_list=[]
                
                smallest_con_list=[]
                
                solution_information=[]
                    

                
                    
                for key in soln_map:
                                
                    e_sol = copy.deepcopy(soln_map[key])
                                
                                                                    
                    e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                    e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                                                
                    solution_list.append(e_sol)
                        
                    solution_list.append(soln_map[key])

                solution_information.append(solution_list)
                                
                solution_information.append(smallest_con_list)
                            
                all_solution_information.append(solution_information)

        else:
            
            for x_solution_information in temp_all_solution_information:
                
                x_solution_list = x_solution_information[0]
                
                x_smallest_con_list = x_solution_information[1]     
            
                ec_rec_equ_list1 =[]
                
                for e in ec_rec_equ_list:
                    
                    e_new = copy.deepcopy(e)
                                                                
                    for x in x_solution_list:
                        
                        e_new[-1] =expr_replace(e_new[-1], x[-2], x[-1])
                        
                    ec_rec_equ_list1.append(e_new)
                    
                results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)
            
                if len(results)==0:
                    
                    solution_information=[]
                    
                    solution_list=[]
                    
                    smallest_con_list=[]
                    
                    for key in soln_map:
                                
                        e_sol = copy.deepcopy(soln_map[key])
                                
                                                                    
                        e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                        e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                                                
                        solution_list.append(e_sol)
                        
                        solution_list.append(soln_map[key])
                        
                solution_information.append(solution_list)
                                
                solution_information.append(smallest_con_list+x_smallest_con_list+x_solution_list)
                            
                all_solution_information.append(solution_information)

    index=index-1
    if index>=0 and index <len(loop_info_list):
        list_of_info = loop_info_list[index]
        #print '~~~~~~~~~~~~~~~~~~~~~~'
        #for x in all_solution_information:
        #    for y in x[0]:
        #        print expr2string1(y[-2])
         #       print expr2string1(y[-1])

        list_of_info.append(all_solution_information)
        loop_info_list[index]=list_of_info 
        #caseAnalysisFindTheComplexity(loop_info_list, index, axiom)
    else:
        return all_solution_information
    return None





def caseAnalysisFindTheComplexity2(loop_info_list, index, axiom):
    
    list_of_info = loop_info_list[index]
    
    condition_map_to_prove = list_of_info[2]
    
    smallest_main_list = list_of_info[1]
            
    temp_all_solution_information =None
    
    if len(list_of_info)>=6:
        
        temp_all_solution_information = list_of_info[10]

    ec_rec_equ_list  = list_of_info[0]
    
    var = list_of_info[3]
    
    const_list = list_of_info[4]
    
    const_in = copy.deepcopy(const_list)
    
    const_in[0]=const_in[0].replace('_N','_CE')

    all_solution_information=[]
    
    
    if len(condition_map_to_prove) > 0:
        
        if temp_all_solution_information is  None:
            
            for key in condition_map_to_prove:
            
                ec_rec_equ_list1 =[]
                
                ec = condition_map_to_prove[key]
            
                for e in ec_rec_equ_list:

                    e_new = copy.deepcopy(e)
                
                    result = getTheExpressionCond(e_new[-1], ec)
                                        
                    if result is not None:
                                            
                        e_new[-1] = result
                            
                    else:
                            if e_new[0]=='i1':
                                            
                                e_new[-1] = expr_replace(copy.deepcopy(e_new[-2]), eval("['+',['" + var + "'],['1']]"), eval("['" + var + "']"))
                    
                    ec_rec_equ_list1.append(e_new)
                    
                results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)
                    
                if len(results)==0:
                        
                    solution_information=[]
                    
                    solution_list=[]
                    
                    smallest_con_list=[]
                    
                    for key in soln_map:
                                
                        e_sol = copy.deepcopy(soln_map[key])
                                
                                                                    
                        e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                        e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                            
                        solution_list.append(e_sol)
                            
                        solution_list.append(soln_map[key])
                            
                    smallest_con_list.append(ec)
                            
                        
                        
                    for e_s in smallest_main_list:
                            
                        new_e_s = copy.deepcopy(e_s)
                            
                        for e_sol in solution_list:
                                
                            new_e_s[-1] = expr_replace(new_e_s[-1], e_sol[-2], e_sol[-1])
                                
                        smallest_con_list.append(new_e_s)

                                                
                    solution_information.append(solution_list)
                                
                    solution_information.append(smallest_con_list)
                                    
                            
                    all_solution_information.append(solution_information)
        else:
            
            for x_solution_information in temp_all_solution_information:
                
                x_solution_list = x_solution_information[0]
                
                x_smallest_con_list = x_solution_information[1]     

                for key in condition_map_to_prove:
            
                    ec_rec_equ_list1 =[]
                    
                    ec = condition_map_to_prove[key]
            
                    for e in ec_rec_equ_list:

                        e_new = copy.deepcopy(e)
                
                        result = getTheExpressionCond(e_new[-1], ec)
                                        
                        if result is not None:
                            
                            for x in x_solution_list:
                        
                                e_new[-1] =expr_replace(e_new[-1], x[-2], x[-1])

                                            
                            e_new[-1] = result
                            
                        else:
                            
                            if e_new[0]=='i1':
                                            
                                e_new[-1] = expr_replace(copy.deepcopy(e_new[-2]), eval("['+',['" + var + "'],['1']]"), eval("['" + var + "']"))
                                            
                        ec_rec_equ_list1.append(e_new)
                    
                    results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)
                    
                    if len(results)==0:
                        
                        solution_information=[]
                    
                        solution_list=[]
                    
                        smallest_con_list=[]
                    
                        for key in soln_map:
                                
                            e_sol = copy.deepcopy(soln_map[key])
                                
                                                                    
                            e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                            e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                            
                            solution_list.append(e_sol)
                            
                            solution_list.append(soln_map[key])
                            
                        smallest_con_list.append(ec)
                            
                        for e_s in smallest_main_list:
                            
                            new_e_s = copy.deepcopy(e_s)
                            
                            for e_sol in solution_list:
                                
                                new_e_s[-1] = expr_replace(new_e_s[-1], e_sol[-2], e_sol[-1])
                                
                            smallest_con_list.append(new_e_s)
                                                
                        solution_information.append(solution_list)
                                
                        solution_information.append(smallest_con_list)
                                                                
                        all_solution_information.append(solution_information)
    else:
    
        if temp_all_solution_information is  None:
                        
            ec_rec_equ_list1 =[]
            
            for e in ec_rec_equ_list:

                e_new = copy.deepcopy(e)
                                
                ec_rec_equ_list1.append(e_new)
                    
            results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)
            
                
            if len(results)==0:
                        
                solution_information=[]
                    
                solution_list=[]
                    
                smallest_con_list=[]
                    
                for key in soln_map:
                                
                    e_sol = copy.deepcopy(soln_map[key])
                                
                                                                    
                    e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                    e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                            
                    solution_list.append(e_sol)
                            
                    solution_list.append(soln_map[key])
                            
                            
                    
                for e_s in smallest_main_list:
                            
                    new_e_s = copy.deepcopy(e_s)
                            
                    for e_sol in solution_list:
                                
                        new_e_s[-1] = expr_replace(new_e_s[-1], e_sol[-2], e_sol[-1])
                                
                    smallest_con_list.append(new_e_s)

                                                
                solution_information.append(solution_list)
                                
                solution_information.append(smallest_con_list)
                                    
                    
                all_solution_information.append(solution_information)
                    
        else:
            
            for x_solution_information in temp_all_solution_information:
                
                x_solution_list = x_solution_information[0]
                
                x_smallest_con_list = x_solution_information[1]     
            
                ec_rec_equ_list1 =[]
            
                for e in ec_rec_equ_list:

                    e_new = copy.deepcopy(e)
                
                    for x in x_solution_list:
                        
                        e_new[-1] =expr_replace(e_new[-1], x[-2], x[-1])

                    ec_rec_equ_list1.append(e_new)
                    
                results, soln_map = solution_closed_form.rec_solver_group(ec_rec_equ_list1)

                if len(results)==0:
                        
                    solution_information=[]
                    
                    solution_list=[]
                    
                    smallest_con_list=[]
                    
                    for key in soln_map:
                                
                        e_sol = copy.deepcopy(soln_map[key])
                                
                                                                    
                        e_sol[-1] = expr_replace(e_sol[-1], eval("['" + var + "']"), const_list)
                        
                        e_sol[-2] = expr_replace(e_sol[-2], eval("['" + var + "']"), const_list)
                            
                        solution_list.append(e_sol)
                            
                        solution_list.append(soln_map[key])
                            
                            
                        
                    for e_s in smallest_main_list:
                            
                        new_e_s = copy.deepcopy(e_s)
                            
                        for e_sol in solution_list:
                                
                            new_e_s[-1] = expr_replace(new_e_s[-1], e_sol[-2], e_sol[-1])
                                
                        smallest_con_list.append(new_e_s)

                                                
                    solution_information.append(solution_list)
                                
                    solution_information.append(smallest_con_list)
                                    
                            
                    all_solution_information.append(solution_information)

    index=index-1
    if index>=0 and index <len(loop_info_list):
        list_of_info = loop_info_list[index]
        #print '~~~~~~~~~~~~~~~~~~~~~~'
        #for x in all_solution_information:
        #    for y in x[0]:
        #        print expr2string1(y[-2])
        #        print expr2string1(y[-1])

        list_of_info.append(all_solution_information)
        loop_info_list[index]=list_of_info 
        #caseAnalysisFindTheComplexity(loop_info_list, index, axiom)
    else:
        return all_solution_information
    return None















def getBreakFunctionName(break_con_map, cond):             
        for f_n in break_con_map:
            cond_list = break_con_map[f_n]
            if cond in cond_list:
                return f_n
        return None
        
            
            
            
            
            
        







def getSeqCond(e, list_cond, list_seq_cond):
    args = expr_args(e)
    op = expr_op(e)
    if op == 'ite':
        if args[0] not in list_cond and args[0] not in list_seq_cond:
            list_seq_cond.append(args[0])
        if args[1][0] == 'ite':
            return getSeqCond(args[1], list_cond, list_seq_cond)
        if args[2][0] == 'ite':
            return getSeqCond(args[2], list_cond, list_seq_cond)


def getTheExpressionCond(e, ec):
    args = expr_args(e)
    op = expr_op(e)
    if op == 'ite':
        if ec == args[0]:
            return args[1]
        if args[1][0] == 'ite':
            return getTheExpressionCond(args[1], ec)
        if args[2][0] == 'ite':
            return getTheExpressionCond(args[2], ec)
        else:
            return args[2]


def getAllConditionsFesible(e, condition_exp_map):
    args = expr_args(e)
    op = expr_op(e)
    if op == 'ite':
        key = expr2string1(args[0])
        if key not in list(condition_exp_map.keys()):
            condition_exp_map[key] = args[0]
        if args[2][0] == 'ite':
            getAllConditionsFesible(args[2], condition_exp_map)


def getInductiveExpression(e, var):
    args = expr_args(e)
    op = expr_op(e)
    if op == 'ite':
        if args[1][0] == 'ite':
            return getInductiveExpression(args[1], var)
        if expr_find(args[1], var) == True:
            return args[1]
        if args[2][0] == 'ite':
            return getInductiveExpression(args[2], var)
        if expr_find(args[2], var) == True:
            return args[2]


def getAllConditionFromS0(e, condition_list):
    args = expr_args(e)
    op = expr_op(e)
    if op == 'or':
        if args[0][0] == 'or':
            getAllConditionFromS0(args[0], condition_list)
        else:
            condition_list.append(args[0])
        if args[1][0] == 'or':
            getAllConditionFromS0(args[1], condition_list)
        else:
            condition_list.append(args[1])
    else:
        condition_list.append(e)


def getConditionsFesible(e, condition_exp_map, key_value):
    args = expr_args(e)
    op = expr_op(e)
    if op == 'ite':
        key = expr2string1(args[0])
        if key in list(condition_exp_map.keys()):
            list1 = condition_exp_map[key]
            temp_list = []
            temp_list.append(key_value)
            temp_list.append(args[1])
            list1.append(temp_list)
            condition_exp_map[key] = list1
        else:
            list1 = []
            list1.append(args[0])
            temp_list = []
            temp_list.append(key_value)
            temp_list.append(args[1])
            list1.append(temp_list)
            condition_exp_map[key] = list1
        if args[2][0] == 'ite':
            getConditionsFesible(args[2], condition_exp_map, key_value)
        else:
            key = None
            if key in list(condition_exp_map.keys()):
                list1 = condition_exp_map[key]
                temp_list = []
                temp_list.append(key_value)
                temp_list.append(args[2])
                list1.append(args[1])
                condition_exp_map[key] = list1
            else:
                list1 = []
                list1.append(None)
                temp_list = []
                temp_list.append(key_value)
                temp_list.append(args[1])
                list1.append(args[2])
                condition_exp_map[key] = list1


def getBreakConditions(e, condition_list):
    args = expr_args(e)
    op = expr_op(e)
    if op == 'ite':
        if args[1][0] == 'ite':
            getBreakConditions(args[1], condition_list)
        elif args[1][0] == '1':
            condition_list.append(args[0])
        if args[2][0] == 'ite':
            getBreakConditions(args[2], condition_list)
        elif args[2][0] == '1':
            condition_list.append(args[0])

def getNoneBreakConditions(e, condition_list):
    args = expr_args(e)
    op = expr_op(e)
    if op == 'ite':
        if args[1][0] == 'ite':
            getNoneBreakConditions(args[1], condition_list)
        elif args[0] not in condition_list:
            condition_list.append(args[0])
        if args[2][0] == 'ite':
            getNoneBreakConditions(args[2], condition_list)





def getAll_Smallest_S0(axiom):
    main_axiom = []
    prev_big_N = None
    temp_list = None
    for x in axiom.getOther_axioms():
        if prev_big_N is None:
            temp_list = []
            temp_list.append(x)
            prev_big_N = x
        elif x[0] == 's1':
            temp_list.append(x)
            main_axiom.append(temp_list)
            prev_big_N = None
        else:
            temp_list.append(x)

    return main_axiom





def update_bound_smallest(axiom,witnessXml):
    global fun_call_map
    pre_condition=[]
    post_condition=[]
    constraint_list=[]
    condition_map={}
    update_equation=[]
    small_macro_eq=[]
        
        
    for w in axiom.getAssumes():
        if w[0]=='i1':
            var_cstr_map={}
            rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
            list_var_str=qualifier_list(list(var_cstr_map.keys()))
            list_cstr_str=cstr_list(list(var_cstr_map.values()))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                if w[0] == 'i1':
                    pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                else:
                    pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
            else:
                pre_condition.append(rhs)
        elif w[0]=='c1':
            var_cstr_map={}
            rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
            list_var_str=qualifier_list(list(var_cstr_map.keys()))
            list_cstr_str=cstr_list(list(var_cstr_map.values()))
            if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
            if list_var_str is not None and list_cstr_str is not None:
                if w[0] == 'c1':
                    pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                else:
                    pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
            else:
                pre_condition.append(rhs)
        else:
            if w[0]!='i0':
                var_cstr_map={}
                rhs=expr2z3_update_postCond(w[-1],var_cstr_map)
                list_var_str=qualifier_list(list(var_cstr_map.keys()))
                list_cstr_str=cstr_list(list(var_cstr_map.values()))
                if 'Or' not in rhs and 'And' not in rhs and 'If' not in rhs and '/' not in rhs:
                    rhs=convert_pow_op_fun(simplify_expand_sympy(rhs))
                if list_var_str is not None and list_cstr_str is not None:
                    if w[0] == 'i1':
                        pre_condition.append("ForAll(["+list_var_str+"],Implies("+list_cstr_str+","+rhs+"))")
                    else:
                        pre_condition.append('ForAll(['+list_var_str+'],'+rhs+")")
                else:
                    pre_condition.append(rhs)
	
        
    frame_axioms=eqset2constraintlist_update(axiom.getFrame_axioms())
    for x in frame_axioms:
        constraint_list.append(x)
    out_axioms=eqset2constraintlist_update(axiom.getOutput_equations())

    subs_list=eqset2subs_list(axiom.getOutput_equations())
    for x in axiom.getOutput_equations():
            if axiom.getOutput_equations()[x][1][0]!='main':
                getAllCondtion_tactic8(axiom.getOutput_equations()[x],condition_map)
    for x in out_axioms:
        constraint_list.append(x)
        if len(condition_map)==1:
            for x in condition_map:
                temp_temp=[]
                temp_temp.append('s0')
                temp_temp.append(condition_map[x])
                constraint_list.append(wff2z3_update(temp_temp))

    for x in axiom.getOther_axioms(): 
            equations=wff2z3_update(x)
            equations_sp=None
            if x[0]=='s0':
                    if 'Implies' not in equations and 'If' not in equations and 'And' not in  equations and 'Or' not in  equations and 'Not' not in  equations and 'ForAll' and 'Exists' not in  equations and 'Implies' not in equations:
                        if simplify(equations)!=False:
                            constraint_list.append(equations)
                    else:
                        constraint_list.append(equations)
            else:
                    constraint_list.append(equations)
            if x[0]=='s1':
                equations_sp=wff2z3SC_update(x)
                if equations_sp is not None:
                    constraint_list.append(equations_sp)        		
    for x in axiom.getConstraints():
        constraint_list.append(x)
    for x in pre_condition:
        constraint_list.append(x)
                
        prev_big_N = None
	
        for x in axiom.getOther_axioms():
            if x[0]=='s0':
                result = isBigNPresent(x[-1])
                if result is not None:
                    prev_big_N = x
            elif x[0]=='s1':
                if prev_big_N is not None:
                    if prev_big_N[-1][0]=='<=' or prev_big_N[-1][0]=='>=':
                        expression = normal_form_constant(expr2string1(prev_big_N[-1]), expr2string1(x[-1][1][2]))
                        if '**' not in str(expression):
                            parser = c_parser.CParser()
                            ast = parser.parse("void test(){"+str(expression)+";}")
                            statement_temp=ast.ext[0].body.block_items[0]
                            axupdate = construct_expression_normalC(eval(expressionCreator_C(statement_temp)))
                            if x[-1][1][2] == axupdate[-1][1]:
                                x_new=copy.deepcopy(axupdate)
                                x_new[-1][0]='=='
                                status=query2z3_cond(constraint_list,wff2z3_update1(x_new,axiom.getConst_var_map()),axiom.getVfact())
                                print(status)
                                if 'Successfully' in status:
                                    result_list=[]
                                    result_list.append(x_new[-1][1])
                                    result_list.append(x_new[-1][2])
                                    small_macro_eq.append(result_list)
                    else:
                        x_new=copy.deepcopy(x)
                        x_new[-1] = expr_replace(x_new[-1][2],x_new[-1][1][1],eval("['-',"+str(x_new[-1][1][2])+",['1']]"))
                        x_new[0] ='s0'
                        expression = normal_form_constant(expr2string1(x_new[-1]), expr2string1(x[-1][1][2]))
                        if '**' not in str(expression):
                            parser = c_parser.CParser()
                            ast = parser.parse("void test(){"+str(expression)+";}")
                            statement_temp=ast.ext[0].body.block_items[0]
                            axupdate = construct_expression_normalC(eval(expressionCreator_C(statement_temp)))
                            if x[-1][1][2] == axupdate[-1][1]:
                                if axupdate[-1][0]=='<=' or axupdate[-1][0]=='>=':
                                    x_new=copy.deepcopy(axupdate)
                                    x_new[-1][0]='=='
                                    status=query2z3_cond(constraint_list,wff2z3_update1(x_new,axiom.getConst_var_map()),axiom.getVfact())
                                    print(status)
                                    if 'Successfully' in status:
                                        result_list=[]
                                        result_list.append(x_new[-1][1])
                                        result_list.append(x_new[-1][2])
                                        small_macro_eq.append(result_list)
                        

                    prev_big_N=None
        return small_macro_eq



def reduceArraySize1(program):
    #print program
    #print '--------------------------'
    status=False
    sub_status=False
    parser = GnuCParser()
    
    
    
    ast = parser.parse(program)
    try:
        for e in ast.ext:
            if type(e) is c_ast.FuncDef: 
                function_body = e.body
                if function_body.block_items is not None:
                    for x in function_body.block_items:
                        if type(x) is c_ast.Decl:
                            stmt = programPrint(x)
                            
                            if isSubsVar(x.name)==True:
                                sub_status=True

                            if ('[60]' in stmt) and '_PROVE' not in stmt:
                                status=True
                            elif ('[40]' in stmt) and '_PROVE' not in stmt:
                                status=True
                    e.body.block_items=reduceArraySizeBlock1(function_body.block_items)
                    return ast.ext[0],status,sub_status
        return None,False,False
    except Exception as e:
        writeLogFile( "j2llogs.logs" ,str(e))
        print(str(e))
        return None,False



def reduceArraySizeBlock1(statements):
    parser = GnuCParser()
    update_statements=[]
    for statement in statements:
        if type(statement) is c_ast.Decl:
            stmt = programPrint(statement)
            if '[60]' in stmt:
                stmt=stmt.replace('[60]','[10]')
                ast1 = parser.parse(stmt+';')
                update_statements.append(ast1.ext[0])
            elif '[40]' in stmt:
                stmt=stmt.replace('[40]','[10]')
                ast1 = parser.parse(stmt+';')
                update_statements.append(ast1.ext[0])
            else:
                 update_statements.append(statement)
        elif type(statement) is c_ast.While:
            cond=reduceArrayStatement1(statement.cond)
            stmts=reduceArraySizeBlock1(statement.stmt.block_items)
            statement=c_ast.While(cond=cond, stmt=c_ast.Compound(block_items=stmts))
            update_statements.append(statement)
        elif type(statement) is c_ast.If:
            update_statements.append(reduceArraySizeBlockIf1(statement))
        elif type(statement) is c_ast.Assignment:
            update_statements.append(c_ast.Assignment(op=statement.op,lvalue=reduceArrayStatement1(statement.lvalue),rvalue=reduceArrayStatement1(statement.rvalue)))
        else:
            update_statements.append(statement)
    return update_statements


def reduceArraySizeBlockIf1(statement):
    If_stmt=None
    Else_stmt=None
    if type(statement) is c_ast.If:
        if type(statement.iftrue) is c_ast.Compound:
            new_block_temp=reduceArraySizeBlock1(statement.iftrue.block_items)
            If_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            If_stmt=statement.iftrue
    if type(statement.iffalse) is c_ast.Compound:
        if statement.iffalse.block_items is not None:
            new_block_temp=reduceArraySizeBlock1(statement.iffalse.block_items)
            Else_stmt=c_ast.Compound(block_items=new_block_temp)
        else:
            Else_stmt=statement.iffalse
    else:
        if type(statement.iffalse) is c_ast.If:
            Else_stmt=reduceArraySizeBlockIf1(statement.iffalse)
        else:
            Else_stmt=statement.iffalse
    return c_ast.If(cond=reduceArrayStatement1(statement.cond), iftrue=If_stmt, iffalse=Else_stmt)
    
    
def reduceArrayStatement1(statement):
    if type(statement) is c_ast.BinaryOp:
        return c_ast.BinaryOp(op=statement.op, left=reduceArrayStatement1(statement.left), right=reduceArrayStatement1(statement.right))
    elif type(statement) is c_ast.Constant:
        if statement.type=='int' and (statement.value=='40'):
            return c_ast.Constant(type=statement.type,value='10')
        elif statement.type=='int' and (statement.value=='60'):
            return c_ast.Constant(type=statement.type,value='10')
        return statement
    elif type(statement) is c_ast.ArrayRef:
        return c_ast.ArrayRef(name=statement.name,subscript=reduceArrayStatement1(statement.subscript))
    else:
        return statement


